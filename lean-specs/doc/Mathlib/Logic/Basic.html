<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Basic</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Basic";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Batteries/Logic.html">Batteries.Logic</a></li><li><a href="../.././Batteries/Tactic/Trans.html">Batteries.Tactic.Trans</a></li><li><a href="../.././Batteries/Util/LibraryNote.html">Batteries.Util.LibraryNote</a></li><li><a href="../.././Mathlib/Tactic/AdaptationNote.html">Mathlib.Tactic.AdaptationNote</a></li><li><a href="../.././Mathlib/Tactic/Basic.html">Mathlib.Tactic.Basic</a></li><li><a href="../.././Mathlib/Data/Int/Notation.html">Mathlib.Data.Int.Notation</a></li><li><a href="../.././Mathlib/Data/Nat/Notation.html">Mathlib.Data.Nat.Notation</a></li><li><a href="../.././Mathlib/Tactic/Attr/Register.html">Mathlib.Tactic.Attr.Register</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#hidden"><span class="name">hidden</span></a></div><div class="nav_link"><a class="break_within" href="#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#congr_heq"><span class="name">congr_heq</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_heq"><span class="name">congr_arg_heq</span></a></div><div class="nav_link"><a class="break_within" href="#dcongr_heq"><span class="name">dcongr_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></div><div class="nav_link"><a class="break_within" href="#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></div><div class="nav_link"><a class="break_within" href="#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></div><div class="nav_link"><a class="break_within" href="#Fact"><span class="name">Fact</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.LibraryNote.«fact non-instances»"><span class="name">Mathlib</span>.<span class="name">LibraryNote</span>.<span class="name">«fact non-instances»</span></a></div><div class="nav_link"><a class="break_within" href="#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#fact_iff"><span class="name">fact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableFact"><span class="name">instDecidableFact</span></a></div><div class="nav_link"><a class="break_within" href="#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#and_or_imp"><span class="name">and_or_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em"><span class="name">dec_em</span></a></div><div class="nav_link"><a class="break_within" href="#dec_em'"><span class="name">dec_em'</span></a></div><div class="nav_link"><a class="break_within" href="#em"><span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#em'"><span class="name">em'</span></a></div><div class="nav_link"><a class="break_within" href="#or_not"><span class="name">or_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_or_ne"><span class="name">eq_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_or_eq"><span class="name">ne_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#by_contradiction"><span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#by_cases"><span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#by_contra"><span class="name">by_contra</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.LibraryNote.«decidable namespace»"><span class="name">Mathlib</span>.<span class="name">LibraryNote</span>.<span class="name">«decidable namespace»</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.LibraryNote.«decidable arguments»"><span class="name">Mathlib</span>.<span class="name">LibraryNote</span>.<span class="name">«decidable arguments»</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_not"><span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_ne_iff"><span class="name">not_ne_iff</span></a></div><div class="nav_link"><a class="break_within" href="#of_not_imp"><span class="name">of_not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_comm"><span class="name">not_imp_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_self"><span class="name">not_imp_self</span></a></div><div class="nav_link"><a class="break_within" href="#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'"><span class="name">Xor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_def"><span class="name">xor_def</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableXor'"><span class="name">instDecidableXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_true"><span class="name">xor_true</span></a></div><div class="nav_link"><a class="break_within" href="#xor_false"><span class="name">xor_false</span></a></div><div class="nav_link"><a class="break_within" href="#xor_comm"><span class="name">xor_comm</span></a></div><div class="nav_link"><a class="break_within" href="#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_self"><span class="name">xor_self</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_left"><span class="name">xor_not_left</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_right"><span class="name">xor_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#xor_not_not"><span class="name">xor_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></div><div class="nav_link"><a class="break_within" href="#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_right"><span class="name">and_symm_right</span></a></div><div class="nav_link"><a class="break_within" href="#and_symm_left"><span class="name">and_symm_left</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></div><div class="nav_link"><a class="break_within" href="#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></div><div class="nav_link"><a class="break_within" href="#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></div><div class="nav_link"><a class="break_within" href="#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></div><div class="nav_link"><a class="break_within" href="#not_or_of_imp"><span class="name">not_or_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#or_not_of_imp"><span class="name">or_not_of_imp</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp_not"><span class="name">not_imp_not</span></a></div><div class="nav_link"><a class="break_within" href="#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_left'"><span class="name">or_congr_left'</span></a></div><div class="nav_link"><a class="break_within" href="#or_congr_right'"><span class="name">or_congr_right'</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or"><span class="name">imp_or</span></a></div><div class="nav_link"><a class="break_within" href="#imp_or'"><span class="name">imp_or'</span></a></div><div class="nav_link"><a class="break_within" href="#not_imp"><span class="name">not_imp</span></a></div><div class="nav_link"><a class="break_within" href="#peirce"><span class="name">peirce</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_not"><span class="name">not_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff_comm"><span class="name">not_iff_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_iff"><span class="name">not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#iff_not_comm"><span class="name">iff_not_comm</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_not_right"><span class="name">not_and_not_right</span></a></div><div class="nav_link"><a class="break_within" href="#not_and_or"><span class="name">not_and_or</span></a></div><div class="nav_link"><a class="break_within" href="#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></div><div class="nav_link"><a class="break_within" href="#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#not_xor"><span class="name">not_xor</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#xor_iff_or_and_not_and"><span class="name">xor_iff_or_and_not_and</span></a></div><div class="nav_link"><a class="break_within" href="#forall_cond_comm"><span class="name">forall_cond_comm</span></a></div><div class="nav_link"><a class="break_within" href="#forall_mem_comm"><span class="name">forall_mem_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_equivalence"><span class="name">eq_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_left"><span class="name">congr_refl_left</span></a></div><div class="nav_link"><a class="break_within" href="#congr_refl_right"><span class="name">congr_refl_right</span></a></div><div class="nav_link"><a class="break_within" href="#congr_arg_refl"><span class="name">congr_arg_refl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></div><div class="nav_link"><a class="break_within" href="#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq'"><span class="name">eqRec_heq'</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#cast_heq_iff_heq"><span class="name">cast_heq_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_cast_iff_heq"><span class="name">heq_cast_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq_cast"><span class="name">heq_of_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#eq_cast_iff_heq"><span class="name">eq_cast_iff_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_iff_exists_eq_cast"><span class="name">heq_iff_exists_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#heq_iff_exists_cast_eq"><span class="name">heq_iff_exists_cast_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_imp"><span class="name">forall₂_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_imp"><span class="name">forall₃_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_swap"><span class="name">forall_swap</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_swap"><span class="name">forall₂_swap</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff"><span class="name">imp_forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#imp_forall_iff_forall"><span class="name">imp_forall_iff_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_swap"><span class="name">exists_swap</span></a></div><div class="nav_link"><a class="break_within" href="#exists_and_exists_comm"><span class="name">exists_and_exists_comm</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall_not"><span class="name">not_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></div><div class="nav_link"><a class="break_within" href="#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></div><div class="nav_link"><a class="break_within" href="#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff"><span class="name">forall_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_iff'"><span class="name">forall_true_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#and_forall_ne"><span class="name">and_forall_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></div><div class="nav_link"><a class="break_within" href="#exists_apply_eq"><span class="name">exists_apply_eq</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></div><div class="nav_link"><a class="break_within" href="#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#exists₂_comm"><span class="name">exists₂_comm</span></a></div><div class="nav_link"><a class="break_within" href="#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_left"><span class="name">forall_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#forall_or_right"><span class="name">forall_or_right</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_index"><span class="name">forall_and_index</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_index'"><span class="name">forall_and_index'</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></div><div class="nav_link"><a class="break_within" href="#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr"><span class="name">forall_prop_congr</span></a></div><div class="nav_link"><a class="break_within" href="#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_eq"><span class="name">imp_congr_eq</span></a></div><div class="nav_link"><a class="break_within" href="#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></div><div class="nav_link"><a class="break_within" href="#eq_true_intro"><span class="name">eq_true_intro</span></a></div><div class="nav_link"><a class="break_within" href="#eq_false_intro"><span class="name">eq_false_intro</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#iff_eq_eq"><span class="name">iff_eq_eq</span></a></div><div class="nav_link"><a class="break_within" href="#forall_true_left"><span class="name">forall_true_left</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></div><div class="nav_link"><a class="break_within" href="#bex_def"><span class="name">bex_def</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></div><div class="nav_link"><a class="break_within" href="#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#not_exists_mem"><span class="name">not_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#not_forall₂"><span class="name">not_forall₂</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_and"><span class="name">forall₂_and</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_left"><span class="name">forall_and_left</span></a></div><div class="nav_link"><a class="break_within" href="#forall_and_right"><span class="name">forall_and_right</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or"><span class="name">exists_mem_or</span></a></div><div class="nav_link"><a class="break_within" href="#forall₂_or_left"><span class="name">forall₂_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff"><span class="name">dite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff"><span class="name">ite_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#eq_ite_iff"><span class="name">eq_ite_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></div><div class="nav_link"><a class="break_within" href="#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></div><div class="nav_link"><a class="break_within" href="#apply_dite₂"><span class="name">apply_dite₂</span></a></div><div class="nav_link"><a class="break_within" href="#apply_ite₂"><span class="name">apply_ite₂</span></a></div><div class="nav_link"><a class="break_within" href="#dite_apply"><span class="name">dite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_apply"><span class="name">ite_apply</span></a></div><div class="nav_link"><a class="break_within" href="#ite_and"><span class="name">ite_and</span></a></div><div class="nav_link"><a class="break_within" href="#ite_or"><span class="name">ite_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_dite_comm"><span class="name">dite_dite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_ite_comm"><span class="name">ite_ite_comm</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></div><div class="nav_link"><a class="break_within" href="#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></div><div class="nav_link"><a class="break_within" href="#if_ctx_congr"><span class="name">if_ctx_congr</span></a></div><div class="nav_link"><a class="break_within" href="#if_congr"><span class="name">if_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_notMem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_notMem</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_notMem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_notMem'</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></div><div class="nav_link"><a class="break_within" href="#mem_dite"><span class="name">mem_dite</span></a></div><div class="nav_link"><a class="break_within" href="#dite_mem"><span class="name">dite_mem</span></a></div><div class="nav_link"><a class="break_within" href="#mem_ite"><span class="name">mem_ite</span></a></div><div class="nav_link"><a class="break_within" href="#ite_mem"><span class="name">ite_mem</span></a></div><div class="nav_link"><a class="break_within" href="#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_decide"><span class="name">beq_eq_decide</span></a></div><div class="nav_link"><a class="break_within" href="#beq_eq_beq"><span class="name">beq_eq_beq</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext"><span class="name">beq_ext</span></a></div><div class="nav_link"><a class="break_within" href="#beq_ext_iff"><span class="name">beq_ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Basic-logic-properties">Basic logic properties <a class="hover-link" href="#Basic-logic-properties">#</a></h1><p>This file is one of the earliest imports in mathlib.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Theorems that require decidability hypotheses are in the namespace <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code>.
Classical versions are in the namespace <code>Classical</code>.</p></div><div class="decl" id="hidden"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L32-L35">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#hidden"><span class="name">hidden</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>An identity function with its main argument implicit. This will be printed as <code><a href="../.././Mathlib/Logic/Basic.html#hidden">hidden</a></code> even
if it is applied to a large term, so it can be used for elision,
as done in the <code>elide</code> and <code>unelide</code> tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#hidden">hidden</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-hidden" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="decidableEq_of_subsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L39-L40">source</a></div><div class="attributes">@[instance 10]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton"><span class="name">decidableEq_of_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#decidableEq_of_subsingleton">decidableEq_of_subsingleton</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonSubtype_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L42-L43">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instSubsingletonSubtype_mathlib"><span class="name">instSubsingletonSubtype_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href="../.././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span>)</span></span></div></div></div></div><div class="decl" id="congr_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L45-L47">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_heq"><span class="name">congr_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">f</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">g</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="congr_arg_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L49-L51">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_heq"><span class="name">congr_arg_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a₁</span></span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span></span></span></div></div></div></div><div class="decl" id="dcongr_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L53-L65">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dcongr_heq"><span class="name">dcongr_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α₁ </span><span class="fn">α₂</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β₁</span> : <span class="fn"><span class="fn">α₁</span> → <a href="../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β₂</span> : <span class="fn"><span class="fn">α₂</span> → <a href="../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f₁</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α₁</span>) → <span class="fn"><span class="fn">β₁</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f₂</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α₂</span>) → <span class="fn"><span class="fn">β₂</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁</span> : <span class="fn">α₁</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂</span> : <span class="fn">α₂</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hargs</span> : <span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">a₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn">∀ (<span class="fn">t₁</span> : <span class="fn">α₁</span>) (<span class="fn">t₂</span> : <span class="fn">α₂</span>), <span class="fn"><span class="fn">t₁</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">t₂</span> → <span class="fn"><span class="fn">β₁</span> <span class="fn">t₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">β₂</span> <span class="fn">t₂</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">α₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α₂</span> → <span class="fn"><span class="fn">β₁</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">β₂</span> → <span class="fn">f₁</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">f₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f₁</span> <span class="fn">a₁</span></span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn"><span class="fn">f₂</span> <span class="fn">a₂</span></span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L67-L68">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_left"><span class="name">eq_iff_eq_cancel_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="eq_iff_eq_cancel_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L70-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_iff_eq_cancel_right"><span class="name">eq_iff_eq_cancel_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ {<span class="fn">c</span> : <span class="fn">α</span>}, <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ne_and_eq_iff_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L73-L74">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_and_eq_iff_right"><span class="name">ne_and_eq_iff_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Fact"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L76-L96">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact"><span class="name">Fact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Wrapper for adding elementary propositions to the type class systems.
Warning: this can easily be abused. See the rest of this docstring for details.</p><p>Certain propositions should not be treated as a class globally,
but sometimes it is very convenient to be able to use the type class system
in specific circumstances.</p><p>For example, <code>ZMod p</code> is a field if and only if <code>p</code> is a prime number.
In order to be able to find this field instance automatically by type class search,
we have to turn <code>p.prime</code> into an instance implicit assumption.</p><p>On the other hand, making <code>Nat.prime</code> a class would require a major refactoring of the library,
and it is questionable whether making <code>Nat.prime</code> a class is desirable at all.
The compromise is to add the assumption <code>[Fact p.prime]</code> to <code>ZMod.field</code>.</p><p>In particular, this class is not intended for turning the type class system
into an automated theorem prover for first-order logic.</p><ul class="structure_fields" id="Fact.mk"><li id="Fact.out" class="structure_field"><div class="structure_field_info">out : <span class="fn">p</span></div><div class="structure_field_doc"><p><code><a href="../.././Mathlib/Logic/Basic.html#Fact.out">Fact.out</a></code> contains the unwrapped witness for the fact represented by the instance of
<code><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> p</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Fact" class="instances-list"></ul></details></div></div><div class="decl" id="Mathlib.LibraryNote.«fact non-instances»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L98-L102">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Mathlib.LibraryNote.«fact non-instances»"><span class="name">Mathlib</span>.<span class="name">LibraryNote</span>.<span class="name">«fact non-instances»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/Basic.html#LibraryNote">LibraryNote</a></div></div><p>In most cases, we should not have global instances of <code><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a></code>; typeclass search is not an
advanced proof search engine, and adding any such instance has the potential to cause
slowdowns everywhere. We instead declare them as lemmata and make them local instances as required.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#Mathlib.LibraryNote.«fact non-instances»">Mathlib.LibraryNote.«fact non-instances»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a></li></ul></details><details id="instances-for-list-Mathlib.LibraryNote.«fact non-instances»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Fact.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L104-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Fact.elim"><span class="name">Fact</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="fact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L105-L105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#fact_iff"><span class="name">fact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="instDecidableFact"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L107-L108">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instDecidableFact"><span class="name">instDecidableFact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn">p</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#instDecidableFact">instDecidableFact</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/PropLemmas.html#decidable_of_iff">decidable_of_iff</a> <span class="fn">p</span> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="Function.swap₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L110-L113">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.swap₂"><span class="name">Function</span>.<span class="name">swap₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₁</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₂</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₁</span> : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_4</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₂</span> : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">φ</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Sort</a> u_6</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn">(<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn">(<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) → <span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">φ</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></div></div><p>Swaps two pairs of arguments to a function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Function.swap₂">Function.swap₂</a> <span class="fn">f</span> <span class="fn">i₂</span> <span class="fn">j₂</span> <span class="fn">i₁</span> <span class="fn">j₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></li></ul></details><details id="instances-for-list-Function.swap₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-propositional-connectives">Declarations about propositional connectives <a class="hover-link" href="#Declarations-about-propositional-connectives">#</a></h3></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-implies">Declarations about <code>implies</code> <a class="hover-link" href="#Declarations-about-implies">#</a></h3></div><div class="decl" id="Iff.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L125-L125">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.imp"><span class="name">Iff</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#imp_congr">imp_congr</a></code>.</p></div></div><div class="decl" id="imp_iff_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L128-L129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_right_iff"><span class="name">imp_iff_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="and_or_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L132-L133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_or_imp"><span class="name">and_or_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Function.mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L135-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mt"><span class="name">Function</span>.<span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></span></div></div><p>Provide modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-not">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.not">not</a></code> <a class="hover-link" href="#Declarations-about-not">#</a></h3></div><div class="decl" id="dec_em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L140-L140">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em"><span class="name">dec_em</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#Decidable.em">Decidable.em</a></code>.</p></div></div><div class="decl" id="dec_em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L142-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dec_em'"><span class="name">dec_em'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L144-L144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em"><span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.em">Classical.em</a></code>.</p><hr></hr><p><strong>Diaconescu's theorem</strong>: excluded middle from choice, Function extensionality and propositional extensionality.</p></div></div><div class="decl" id="em'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L146-L146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#em'"><span class="name">em'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L148-L148">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not"><span class="name">or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span></div></div></div></div><div class="decl" id="Decidable.eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L150-L151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.eq_or_ne"><span class="name">Decidable</span>.<span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Decidable.ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L153-L154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.ne_or_eq"><span class="name">Decidable</span>.<span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="eq_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L156-L156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_or_ne"><span class="name">eq_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="ne_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L158-L158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_or_eq"><span class="name">ne_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L160-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contradiction"><span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L163-L164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_cases"><span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hpq</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hnpq</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div></div></div><div class="decl" id="by_contra"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L166-L166">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#by_contra"><span class="name">by_contra</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#False">False</a>)</span> → <span class="fn">p</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#by_contradiction">by_contradiction</a></code>.</p></div></div><div class="decl" id="Mathlib.LibraryNote.«decidable namespace»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L168-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Mathlib.LibraryNote.«decidable namespace»"><span class="name">Mathlib</span>.<span class="name">LibraryNote</span>.<span class="name">«decidable namespace»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/Basic.html#LibraryNote">LibraryNote</a></div></div><p>In most of mathlib, we use the law of excluded middle (LEM) and the axiom of choice (AC) freely.
The <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code> namespace contains versions of lemmas from the root namespace that explicitly
attempt to avoid the axiom of choice, usually by adding decidability assumptions on the inputs.</p><p>You can check if a lemma uses the axiom of choice by using <code>#print axioms foo</code> and seeing if
<code><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a></code> appears in the list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#Mathlib.LibraryNote.«decidable namespace»">Mathlib.LibraryNote.«decidable namespace»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a></li></ul></details><details id="instances-for-list-Mathlib.LibraryNote.«decidable namespace»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.LibraryNote.«decidable arguments»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L177-L186">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Mathlib.LibraryNote.«decidable arguments»"><span class="name">Mathlib</span>.<span class="name">LibraryNote</span>.<span class="name">«decidable arguments»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/Basic.html#LibraryNote">LibraryNote</a></div></div><p>As mathlib is primarily classical,
if the type signature of a <code>def</code> or <code><a href="../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a></code> does not require any <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code> instances to state,
it is preferable not to introduce any <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code> instances that are needed in the proof
as arguments, but rather to use the <code>classical</code> tactic as needed.</p><p>In the other direction, when <code><a href="../.././Init/Prelude.html#Decidable">Decidable</a></code> instances do appear in the type signature,
it is better to use explicitly introduced ones rather than allowing Lean to automatically infer
classical ones, as these may cause instance mismatch errors later.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#Mathlib.LibraryNote.«decidable arguments»">Mathlib.LibraryNote.«decidable arguments»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a></li></ul></details><details id="instances-for-list-Mathlib.LibraryNote.«decidable arguments»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L193-L193">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_not"><span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_ne_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L195-L195">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_ne_iff"><span class="name">not_ne_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="of_not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L197-L197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#of_not_imp"><span class="name">of_not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Not.decidable_imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L199-L199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.decidable_imp_symm"><span class="name">Not</span>.<span class="name">decidable_imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#Decidable.not_imp_symm">Decidable.not_imp_symm</a></code>.</p></div></div><div class="decl" id="Not.imp_symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L201-L201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Not.imp_symm"><span class="name">Not</span>.<span class="name">imp_symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="not_imp_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L203-L203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_comm"><span class="name">not_imp_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_imp_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L205-L205">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_self"><span class="name">not_imp_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Imp.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L207-L208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Imp.swap"><span class="name">Imp</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">a</span>) (<span class="fn">a</span> : <span class="fn">b</span>), <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a_1</span> : <span class="fn">b</span>) (<span class="fn">a</span> : <span class="fn">a</span>), <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Iff.not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L210-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not"><span class="name">Iff</span>.<span class="name">not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#not_congr">not_congr</a></code>.</p></div></div><div class="decl" id="Iff.not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L212-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_left"><span class="name">Iff</span>.<span class="name">not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Iff.not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L214-L214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.not_right"><span class="name">Iff</span>.<span class="name">not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="Iff.ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L216-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne"><span class="name">Iff</span>.<span class="name">ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>) → (<span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="Iff.ne_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L219-L220">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_left"><span class="name">Iff</span>.<span class="name">ne_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span>) → (<span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="Iff.ne_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L222-L223">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.ne_right"><span class="name">Iff</span>.<span class="name">ne_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>) → (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">d</span>)</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-Xor">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a></code> <a class="hover-link" href="#Declarations-about-Xor">#</a></h3></div><div class="decl" id="Xor'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L233-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'"><span class="name">Xor'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> a b</code> is the exclusive-or of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</li></ul></details><details id="instances-for-list-Xor'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="xor_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L236-L236">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_def"><span class="name">xor_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="instDecidableXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L238-L238">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instDecidableXor'"><span class="name">instDecidableXor'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">b</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Basic.html#instDecidableXor'">instDecidableXor'</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">(<a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>))</span></span></li></ul></details></div></div><div class="decl" id="xor_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L240-L240">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_true"><span class="name">xor_true</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#True">True</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Not">Not</a></div></div></div></div><div class="decl" id="xor_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L242-L242">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_false"><span class="name">xor_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#id">id</a></div></div></div></div><div class="decl" id="xor_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L244-L244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_comm"><span class="name">xor_comm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="instCommutativeXor'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L246-L246">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#instCommutativeXor'"><span class="name">instCommutativeXor'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Std.Commutative">Std.Commutative</a> <a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a></span></div></div></div></div><div class="decl" id="xor_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L248-L248">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_self"><span class="name">xor_self</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="xor_not_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L250-L250">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_left"><span class="name">xor_not_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>) <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L252-L252">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_right"><span class="name">xor_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L254-L254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_not_not"><span class="name">xor_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>) <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Xor'.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L256-L256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Xor'.or"><span class="name">Xor'</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-and">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.and">and</a></code> <a class="hover-link" href="#Declarations-about-and">#</a></h3></div><div class="decl" id="Iff.and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L260-L260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.and"><span class="name">Iff</span>.<span class="name">and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c </span><span class="fn">b </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">d</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#and_congr">and_congr</a></code>.</p></div></div><div class="decl" id="And.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L261-L261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.rotate"><span class="name">And</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#and_rotate">and_rotate</a></code>.</p></div></div><div class="decl" id="and_symm_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L263-L263">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_right"><span class="name">and_symm_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="and_symm_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L264-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_symm_left"><span class="name">and_symm_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">p</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-or">Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Xor'.or">or</a></code> <a class="hover-link" href="#Declarations-about-or">#</a></h3></div><div class="decl" id="Iff.or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L268-L268">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.or"><span class="name">Iff</span>.<span class="name">or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c </span><span class="fn">b </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">d</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#or_congr">or_congr</a></code>.</p></div></div><div class="decl" id="Or.rotate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L269-L269">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.rotate"><span class="name">Or</span>.<span class="name">rotate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../.././Init/PropLemmas.html#or_rotate">or_rotate</a></code>.</p></div></div><div class="decl" id="Or.elim3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L271-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.elim3"><span class="name">Or</span>.<span class="name">elim3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn">b</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">d</span></div></div></div></div><div class="decl" id="Or.imp3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L274-L276">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Or.imp3"><span class="name">Or</span>.<span class="name">imp3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">d </span><span class="fn">e </span><span class="fn">c </span><span class="fn">f</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">had</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">d</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbe</span> : <span class="fn"><span class="fn">b</span> → <span class="fn">e</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hcf</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> → <span class="fn">d</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">e</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="not_or_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L280-L280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_or_of_imp"><span class="name">not_or_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Decidable.or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L283-L284">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.or_not_of_imp"><span class="name">Decidable</span>.<span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">a</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></div></div></div></div><div class="decl" id="or_not_of_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L286-L286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_not_of_imp"><span class="name">or_not_of_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="imp_iff_not_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L288-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_not_or"><span class="name">imp_iff_not_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="imp_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L290-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_iff_or_not"><span class="name">imp_iff_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="not_imp_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L293-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp_not"><span class="name">not_imp_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="imp_and_neg_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L295-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_and_neg_imp_iff"><span class="name">imp_and_neg_imp_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">p</span> → <span class="fn">q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="Function.mtr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L297-L298">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Function.mtr"><span class="name">Function</span>.<span class="name">mtr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</span> → <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></span></div></div><p>Provide the reverse of modus tollens (<code><a href="../.././Init/Core.html#mt">mt</a></code>) as dot notation for implications.</p></div></div><div class="decl" id="or_congr_left'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L300-L301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_left'"><span class="name">or_congr_left'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">c</span> → (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="or_congr_right'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L303-L304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_congr_right'"><span class="name">or_congr_right'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> → (<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">c</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-distributivity">Declarations about distributivity <a class="hover-link" href="#Declarations-about-distributivity">#</a></h3></div><div class="mod_doc"><p>Declarations about <code><a href="../.././Mathlib/Logic/Basic.html#Iff.iff">iff</a></code></p></div><div class="decl" id="Iff.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L310-L310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.iff"><span class="name">Iff</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p₁ </span><span class="fn">p₂ </span><span class="fn">q₁ </span><span class="fn">q₂</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">q₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">p₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₁</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">p₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q₂</span>)</div></div><p><strong>Alias</strong> of <code><a href="../.././Init/SimpLemmas.html#iff_congr">iff_congr</a></code>.</p></div></div><div class="decl" id="iff_mpr_iff_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L313-L313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_mpr_iff_true_intro"><span class="name">iff_mpr_iff_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="imp_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L315-L316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or"><span class="name">imp_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">(<span class="fn">a</span> → <span class="fn">c</span>)</span></div></div></div></div><div class="decl" id="imp_or'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L318-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_or'"><span class="name">imp_or'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">c</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">a</span>), <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">a</span>), <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">a</span>), <span class="fn">c</span></span></div></div></div></div><div class="decl" id="not_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L321-L321">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_imp"><span class="name">not_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="peirce"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L323-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#peirce"><span class="name">peirce</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> → <span class="fn">a</span>)</span> → <span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L325-L325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_not"><span class="name">not_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="not_iff_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L327-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff_comm"><span class="name">not_iff_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</div></div></div></div><div class="decl" id="not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L329-L329">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_iff"><span class="name">not_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="iff_not_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L331-L331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_not_comm"><span class="name">iff_not_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</div></div></div></div><div class="decl" id="iff_iff_and_or_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L333-L334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_and_or_not_and_not"><span class="name">iff_iff_and_or_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div></div></div><div class="decl" id="iff_iff_not_or_and_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L336-L337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_iff_not_or_and_or_not"><span class="name">iff_iff_not_or_and_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="not_and_not_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L339-L340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_not_right"><span class="name">not_and_not_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="De-Morgan-s-laws">De Morgan's laws <a class="hover-link" href="#De-Morgan-s-laws">#</a></h3></div><div class="decl" id="not_and_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L344-L346">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_and_or"><span class="name">not_and_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span></div></div><p>One of <strong>de Morgan's laws</strong>: the negation of a conjunction is logically equivalent to the
disjunction of the negations.</p></div></div><div class="decl" id="or_iff_not_and_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L348-L349">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#or_iff_not_and_not"><span class="name">or_iff_not_and_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="and_iff_not_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L351-L352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_iff_not_or_not"><span class="name">and_iff_not_or_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="not_xor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L354-L355">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_xor"><span class="name">not_xor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</div></div></div></div><div class="decl" id="xor_iff_not_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L357-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff"><span class="name">xor_iff_not_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">P</span> <span class="fn">Q</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</div></div></div></div><div class="decl" id="xor_iff_iff_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L359-L359">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_iff_not"><span class="name">xor_iff_iff_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_iff_not_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L361-L361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_not_iff'"><span class="name">xor_iff_not_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="xor_iff_or_and_not_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L363-L365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#xor_iff_or_and_not_and"><span class="name">xor_iff_or_and_not_and</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Xor'">Xor'</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span>)</div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-equality">Declarations about equality <a class="hover-link" href="#Declarations-about-equality">#</a></h3></div><div class="decl" id="forall_cond_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L374-L376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_cond_comm"><span class="name">forall_cond_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="forall_mem_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L378-L380">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_mem_comm"><span class="name">forall_mem_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></span></div></div></div></div><div class="decl" id="ne_of_eq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L383-L383">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne"><span class="name">ne_of_eq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="ne_of_ne_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L384-L384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq"><span class="name">ne_of_ne_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Eq.trans_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L386-L386">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.trans_ne"><span class="name">Eq</span>.<span class="name">trans_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_eq_of_ne">ne_of_eq_of_ne</a></code>.</p></div></div><div class="decl" id="Ne.trans_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L387-L387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.trans_eq"><span class="name">Ne</span>.<span class="name">trans_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">c</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Logic/Basic.html#ne_of_ne_of_eq">ne_of_ne_of_eq</a></code>.</p></div></div><div class="decl" id="eq_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L389-L390">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_equivalence"><span class="name">eq_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <a href="../.././Init/Prelude.html#Eq">Eq</a></span></div></div></div></div><div class="decl" id="congr_refl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L396-L397">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_left"><span class="name">congr_refl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_refl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L400-L401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_refl_right"><span class="name">congr_refl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_arg_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L404-L406">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_arg_refl"><span class="name">congr_arg_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_fun_rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L409-L410">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_rfl"><span class="name">congr_fun_rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="congr_fun_congr_arg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L413-L414">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#congr_fun_congr_arg"><span class="name">congr_fun_congr_arg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">⋯</span></div></div></div></div><div class="decl" id="Eq.rec_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L416-L416">source</a></div><div class="attributes">@[deprecated eqRec_eq_cast (since := &quot;2025-09-16&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Eq.rec_eq_cast"><span class="name">Eq</span>.<span class="name">rec_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">x</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Batteries/Logic.html#eqRec_eq_cast">eqRec_eq_cast</a></code>.</p></div></div><div class="decl" id="eqRec_heq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L418-L418">source</a></div><div class="attributes">@[deprecated eqRec_heq_self (since := &quot;2025-09-16&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eqRec_heq'"><span class="name">eqRec_heq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">x</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Batteries/Logic.html#eqRec_heq_self">eqRec_heq_self</a></code>.</p></div></div><div class="decl" id="rec_heq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L420-L422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_of_heq"><span class="name">rec_heq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><span class="fn">C</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="rec_heq_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L424-L424">source</a></div><div class="attributes">@[deprecated eqRec_heq_iff_heq (since := &quot;2025-09-16&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#rec_heq_iff_heq"><span class="name">rec_heq_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">y</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">y</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Batteries/Logic.html#eqRec_heq_iff_heq">eqRec_heq_iff_heq</a></code>.</p></div></div><div class="decl" id="heq_rec_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L426-L426">source</a></div><div class="attributes">@[deprecated heq_eqRec_iff_heq (since := &quot;2025-09-16&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_rec_iff_heq"><span class="name">heq_rec_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">y</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">e</span> <a href="../.././Init/Prelude.html#Eq.rec">▸</a> <span class="fn">x</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">x</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Batteries/Logic.html#heq_eqRec_iff_heq">heq_eqRec_iff_heq</a></code>.</p></div></div><div class="decl" id="cast_heq_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L428-L430">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#cast_heq_iff_heq"><span class="name">cast_heq_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="heq_cast_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L432-L434">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_cast_iff_heq"><span class="name">heq_cast_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β </span><span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">γ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="heq_of_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L439-L439">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_of_eq_cast"><span class="name">heq_of_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span></span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="eq_cast_iff_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L441-L441">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_cast_iff_heq"><span class="name">eq_cast_iff_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">e</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="heq_iff_exists_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L443-L446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_iff_exists_eq_cast"><span class="name">heq_iff_exists_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="heq_iff_exists_cast_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L448-L450">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#heq_iff_exists_cast_eq"><span class="name">heq_iff_exists_cast_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-quantifiers">Declarations about quantifiers <a class="hover-link" href="#Declarations-about-quantifiers">#</a></h3></div><div class="decl" id="forall₂_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L460-L462">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_imp"><span class="name">forall₂_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="forall₃_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L464-L466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_imp"><span class="name">forall₃_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span> → <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Exists₂.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L468-L470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₂.imp"><span class="name">Exists₂</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Exists₃.imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L472-L474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists₃.imp"><span class="name">Exists₃</span>.<span class="name">imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) → <span class="fn"><span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">c</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="forall_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L480-L481">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_swap"><span class="name">forall_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">y</span> : <span class="fn">β</span>) (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="forall₂_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L483-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_swap"><span class="name">forall₂_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₁</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₂</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₁</span> : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₂</span> : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>) (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">i₂</span> : <span class="fn">ι₂</span>) (<span class="fn">j₂</span> : <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span>) (<span class="fn">i₁</span> : <span class="fn">ι₁</span>) (<span class="fn">j₁</span> : <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span>), <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></span></div></div></div></div><div class="decl" id="imp_forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L487-L490">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff"><span class="name">imp_forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">p</span> → <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span></div></div><p>We intentionally restrict the type of <code>α</code> in this lemma so that this is a safer to use in simp
than <code><a href="../.././Mathlib/Logic/Basic.html#forall_swap">forall_swap</a></code>.</p></div></div><div class="decl" id="imp_forall_iff_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L492-L493">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_forall_iff_forall"><span class="name">imp_forall_iff_forall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">A</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">B</span> : <span class="fn"><span class="fn">A</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">A</span> → <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">A</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">A</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="exists_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L495-L496">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_swap"><span class="name">exists_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="exists_and_exists_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L498-L500">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_and_exists_comm"><span class="name">exists_and_exists_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Q</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">((<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>) <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">b</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="not_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L504-L505">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall_not"><span class="name">not_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="forall_or_exists_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L509-L510">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_exists_not"><span class="name">forall_or_exists_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="exists_or_forall_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L512-L513">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_or_forall_not"><span class="name">exists_or_forall_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="forall_imp_iff_exists_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L515-L520">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_imp_iff_exists_imp"><span class="name">forall_imp_iff_exists_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">ha</span> : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> → <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn">b</span></span></div></div></div></div><div class="decl" id="forall_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L522-L523">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff"><span class="name">forall_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#True">True</a>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="forall_true_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L527-L528">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_iff'"><span class="name">forall_true_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="forall₂_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L531-L531">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_true_iff"><span class="name">forall₂_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">a</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>), <a href="../.././Init/Prelude.html#True">True</a>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="forall₃_true_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L534-L535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₃_true_iff"><span class="name">forall₃_true_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../.././foundational_types.html">Sort</a> u_4</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) (<span class="fn">a</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">a</span> <span class="fn">b</span></span>), <a href="../.././Init/Prelude.html#True">True</a>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="Decidable.and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L537-L539">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.and_forall_ne"><span class="name">Decidable</span>.<span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="and_forall_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L541-L542">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#and_forall_ne"><span class="name">and_forall_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Ne.ne_or_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L544-L545">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ne_or_ne"><span class="name">Ne</span>.<span class="name">ne_or_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">z</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">y</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">z</span></div></div></div></div><div class="decl" id="exists_apply_eq_apply'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L547-L548">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply'"><span class="name">exists_apply_eq_apply'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L550-L552">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2"><span class="name">exists_apply_eq_apply2</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply2'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L554-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply2'"><span class="name">exists_apply_eq_apply2'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L558-L561">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3"><span class="name">exists_apply_eq_apply3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">z</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="exists_apply_eq_apply3'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L563-L566">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq_apply3'"><span class="name">exists_apply_eq_apply3'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Sort</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">z</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">z</span></span></div></div></div></div><div class="decl" id="exists_apply_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L568-L574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_apply_eq"><span class="name">exists_apply_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">f</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div><p>The constant function witnesses that
there exists a function sending a given term to a given term.</p><p>This is sometimes useful in <code>simp</code> to discharge side conditions.</p></div></div><div class="decl" id="exists_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L576-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_eq_and"><span class="name">exists_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="exists_exists_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L580-L582">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_eq_and"><span class="name">exists_exists_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="exists_exists_and_exists_and_eq_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L584-L588">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_and_exists_and_eq_and"><span class="name">exists_exists_and_exists_and_eq_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="exists_exists_exists_and_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L590-L594">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_exists_exists_and_eq"><span class="name">exists_exists_exists_and_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">γ</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">c</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="forall_apply_eq_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L596-L597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_apply_eq_imp_iff'"><span class="name">forall_apply_eq_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></div></div></div></div><div class="decl" id="forall_eq_apply_imp_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L599-L600">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_eq_apply_imp_iff'"><span class="name">forall_eq_apply_imp_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></span></div></div></div></div><div class="decl" id="exists₂_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L602-L605">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists₂_comm"><span class="name">exists₂_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₁</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι₂</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₁</span> : <span class="fn"><span class="fn">ι₁</span> → <a href="../.././foundational_types.html">Sort</a> u_5</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ₂</span> : <span class="fn"><span class="fn">ι₂</span> → <a href="../.././foundational_types.html">Sort</a> u_6</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">i₁</span> : <span class="fn">ι₁</span>) → <span class="fn"><span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span> → <span class="fn">(<span class="fn">i₂</span> : <span class="fn">ι₂</span>) → <span class="fn"><span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₁</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₂</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span>) <a href="../.././Init/Core.html#Iff">↔</a>   <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₂</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₂</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₂</span> <span class="fn">i₂</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">i₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">ι₁</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">j₁</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">κ₁</span> <span class="fn">i₁</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">i₁</span> <span class="fn">j₁</span> <span class="fn">i₂</span> <span class="fn">j₂</span></span></div></div></div></div><div class="decl" id="And.exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L607-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#And.exists"><span class="name">And</span>.<span class="name">exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">hp</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">hq</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">q</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="forall_or_of_or_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L610-L612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_of_or_forall"><span class="name">forall_or_of_or_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L615-L618">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_left"><span class="name">Decidable</span>.<span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="forall_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L620-L621">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_left"><span class="name">forall_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="Decidable.forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L624-L625">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.forall_or_right"><span class="name">Decidable</span>.<span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="forall_or_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L627-L628">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_or_right"><span class="name">forall_or_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="forall_and_index"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L630-L633">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_index"><span class="name">forall_and_index</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span>), <span class="fn"><span class="fn">r</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">hp</span> : <span class="fn">p</span>) (<span class="fn">hq</span> : <span class="fn">q</span>), <span class="fn"><span class="fn">r</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="forall_and_index'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L635-L637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_index'"><span class="name">forall_and_index'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">q</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">hp</span> : <span class="fn">p</span>) (<span class="fn">hq</span> : <span class="fn">q</span>), <span class="fn"><span class="fn">r</span> <span class="fn">hp</span> <span class="fn">hq</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span>), <span class="fn"><span class="fn">r</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Exists.fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L639-L640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.fst"><span class="name">Exists</span>.<span class="name">fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span> → <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Exists.snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L642-L643">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.snd"><span class="name">Exists</span>.<span class="name">snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">b</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Prop.exists_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L645-L647">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.exists_iff"><span class="name">Prop</span>.<span class="name">exists_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././foundational_types.html">Prop</a><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="Prop.forall_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L649-L650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff"><span class="name">Prop</span>.<span class="name">forall_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">h</span> : <a href="../.././foundational_types.html">Prop</a>), <span class="fn"><span class="fn">p</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#False">False</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True">True</a></span></div></div></div></div><div class="decl" id="exists_iff_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L652-L653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_iff_of_forall"><span class="name">exists_iff_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span></div></div></div></div><div class="decl" id="exists_prop_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L655-L656">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_prop_of_false"><span class="name">exists_prop_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#Not">¬</a><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h'</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">p</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">h'</span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L660-L662">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr"><span class="name">forall_prop_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">p'</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q </span><span class="fn">q'</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hq</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="forall_prop_congr'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L664-L666">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_prop_congr'"><span class="name">forall_prop_congr'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">p'</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q </span><span class="fn">q'</span> : <span class="fn"><span class="fn">p</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hq</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">q'</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">p'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p'</span>), <span class="fn"><span class="fn">q'</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="imp_congr_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L668-L669">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_eq"><span class="name">imp_congr_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="imp_congr_ctx_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L671-L672">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#imp_congr_ctx_eq"><span class="name">imp_congr_ctx_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">c</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> → <span class="fn">b</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">c</span> → <span class="fn">d</span>)</span></div></div></div></div><div class="decl" id="eq_true_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L674-L674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_true_intro"><span class="name">eq_true_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a></div></div></div></div><div class="decl" id="eq_false_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L676-L676">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_false_intro"><span class="name">eq_false_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="Iff.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L679-L679">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Iff.eq"><span class="name">Iff</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Core.html#propext">propext</a></code>.</p><hr></hr><p>The <a href="https://lean-lang.org/doc/reference/4.24.0/find/?domain=Verso.Genre.Manual.section&amp;name=axioms">axiom</a> of <strong>propositional extensionality</strong>. It asserts that if
propositions <code>a</code> and <code>b</code> are logically equivalent (that is, if <code>a</code> can be proved from <code>b</code> and vice
versa), then <code>a</code> and <code>b</code> are <em>equal</em>, meaning <code>a</code> can be replaced with <code>b</code> in all contexts.</p><p>The standard logical connectives provably respect propositional extensionality. However, an axiom is
needed for higher order expressions like <code>P a</code> where <code>P : Prop → Prop</code> is unknown, as well as for
equality. Propositional extensionality is intuitionistically valid.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../.././Mathlib/Logic/Basic.html#Iff.eq">Iff.eq</a> <a href="../.././Init/Prelude.html#Eq">=</a> @<a href="../.././Init/Core.html#propext">propext</a></li></ul></details><details id="instances-for-list-Iff.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="iff_eq_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L681-L681">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#iff_eq_eq"><span class="name">iff_eq_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</div></div></div></div><div class="decl" id="forall_true_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L685-L687">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_true_left"><span class="name">forall_true_left</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../.././Init/Prelude.html#True">True</a> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#True">True</a>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <a href="../.././Init/Prelude.html#True.intro">True.intro</a></span></div></div><p>See <code>IsEmpty.<a href="../.././Mathlib/Logic/Basic.html#Prop.forall_iff">forall_iff</a></code> for the <code><a href="../.././Init/Prelude.html#False">False</a></code> version.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Classical-lemmas">Classical lemmas <a class="hover-link" href="#Classical-lemmas">#</a></h3></div><div class="decl" id="Classical.dec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L696-L697">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.dec"><span class="name">Classical</span>.<span class="name">dec</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span></div></div><p>Any prop <code>p</code> is decidable classically. A shorthand for <code><a href="../.././Init/Classical.html#Classical.propDecidable">Classical.propDecidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.dec">Classical.dec</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.dec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decPred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L701-L702">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decPred"><span class="name">Classical</span>.<span class="name">decPred</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span></div></div><p>Any predicate <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decPred">Classical.decPred</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.decPred" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decRel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L704-L705">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decRel"><span class="name">Classical</span>.<span class="name">decRel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">p</span></span></div></div><p>Any relation <code>p</code> is decidable classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decRel">Classical.decRel</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.decRel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L707-L708">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.decEq"><span class="name">Classical</span>.<span class="name">decEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span></div></div><p>Any type <code>α</code> has decidable equality classically.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.decEq">Classical.decEq</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Classical.decEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.existsCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L710-L713">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.existsCases"><span class="name">Classical</span>.<span class="name">existsCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H0</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>Construct a function from a default value <code>H0</code>, and a function to use if there exists a value
satisfying the predicate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.existsCases">Classical.existsCases</a> <span class="fn">H0</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> then <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span> else <span class="fn">H0</span></span></li></ul></details><details id="instances-for-list-Classical.existsCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.some_spec₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L715-L716">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.some_spec₂"><span class="name">Classical</span>.<span class="name">some_spec₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hpq</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">q</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">choose</a> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Classical.byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L718-L720">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'"><span class="name">Classical</span>.<span class="name">byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A version of <code>byContradiction</code> that uses types instead of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Classical.byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choice_of_byContradiction'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L722-L724">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'"><span class="name">Classical</span>.<span class="name">choice_of_byContradiction'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contra</span> : <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#False">False</a></span>) → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></div></div><p><code><a href="../.././Mathlib/Logic/Basic.html#Classical.byContradiction'">Classical.byContradiction'</a></code> is equivalent to lean's axiom <code><a href="../.././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Basic.html#Classical.choice_of_byContradiction'">Classical.choice_of_byContradiction'</a> <span class="fn">contra</span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">contra</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Classical.choice_of_byContradiction'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Classical.choose_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L726-L726">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq"><span class="name">Classical</span>.<span class="name">choose_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span>.<a href="../.././Init/Classical.html#Exists.choose">choose</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Classical.choose_eq'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L728-L730">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.choose_eq'"><span class="name">Classical</span>.<span class="name">choose_eq'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">⋯</span>.<a href="../.././Init/Classical.html#Exists.choose">choose</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Classical.axiom_of_choice"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L732-L732">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.axiom_of_choice"><span class="name">Classical</span>.<span class="name">axiom_of_choice</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">f</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.axiomOfChoice">Classical.axiomOfChoice</a></code>.</p><hr></hr><p>the axiom of choice</p></div></div><div class="decl" id="Classical.by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L733-L733">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_cases"><span class="name">Classical</span>.<span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hpq</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hnpq</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byCases">Classical.byCases</a></code>.</p></div></div><div class="decl" id="Classical.by_contradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L734-L734">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.by_contradiction"><span class="name">Classical</span>.<span class="name">by_contradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.byContradiction">Classical.byContradiction</a></code>.</p></div></div><div class="decl" id="Classical.prop_complete"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L740-L740">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Classical.prop_complete"><span class="name">Classical</span>.<span class="name">prop_complete</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#True">True</a> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#False">False</a></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Classical.html#Classical.propComplete">Classical.propComplete</a></code>.</p></div></div><div class="decl" id="Exists.classicalRecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L744-L749">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn"><span class="name">Exists</span>.<span class="name">classicalRecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">C</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>This function has the same type as <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code>, and can be used to case on an equality,
but <code><a href="../.././Init/Core.html#Exists.recOn">Exists.recOn</a></code> can only eliminate into Prop, while this version eliminates into any universe
using the axiom of choice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">h</span>.<a href="../.././Mathlib/Logic/Basic.html#Exists.classicalRecOn">classicalRecOn</a></span> <span class="fn">H</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">H</span> <span class="fn">(<a href="../.././Init/Classical.html#Classical.choose">Classical.choose</a> <span class="fn">h</span>)</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Exists.classicalRecOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Declarations-about-bounded-quantifiers">Declarations about bounded quantifiers <a class="hover-link" href="#Declarations-about-bounded-quantifiers">#</a></h3></div><div class="decl" id="bex_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L756-L757">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#bex_def"><span class="name">bex_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="BEx.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L759-L760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.elim"><span class="name">BEx</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) → <span class="fn"><span class="fn">(∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h</span></span> → <span class="fn">b</span></span>)</span> → <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="BEx.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L762-L763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.intro"><span class="name">BEx</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">P</span> <span class="fn">a</span> <span class="fn">h₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="BAll.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L765-L766">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_right"><span class="name">BAll</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="BEx.imp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L768-L769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_right"><span class="name">BEx</span>.<span class="name">imp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="BAll.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L771-L772">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BAll.imp_left"><span class="name">BAll</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="BEx.imp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L774-L775">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#BEx.imp_left"><span class="name">BEx</span>.<span class="name">imp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="exists_mem_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L777-L778">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_of_exists"><span class="name">exists_mem_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="exists_of_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L780-L781">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_of_exists_mem"><span class="name">exists_of_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span>) → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="not_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L784-L784">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_exists_mem"><span class="name">not_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="not_forall₂_of_exists₂_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L786-L787">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂_of_exists₂_not"><span class="name">not_forall₂_of_exists₂_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span></span></div></div></div></div><div class="decl" id="Decidable.not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L790-L793">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Decidable.not_forall₂"><span class="name">Decidable</span>.<span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) → <span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span>)</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="not_forall₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L795-L796">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_forall₂"><span class="name">not_forall₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="forall₂_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L798-L799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_and"><span class="name">forall₂_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>), <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="forall_and_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L801-L802">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_left"><span class="name">forall_and_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">q</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="forall_and_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L804-L805">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall_and_right"><span class="name">forall_and_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">q</span></div></div></div></div><div class="decl" id="exists_mem_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L807-L808">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or"><span class="name">exists_mem_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">h</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">x</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="forall₂_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L810-L811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#forall₂_or_left"><span class="name">forall₂_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="exists_mem_or_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L813-L816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#exists_mem_or_left"><span class="name">exists_mem_or_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p </span><span class="fn">q</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span>) <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">x_1</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">q</span> <span class="fn">x</span></span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="dite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L825-L826">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff"><span class="name">dite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="ite_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L828-L829">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff"><span class="name">ite_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="eq_ite_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L831-L832">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#eq_ite_iff"><span class="name">eq_ite_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">c</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="dite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L834-L836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_iff'"><span class="name">dite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="ite_eq_iff'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L838-L838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_iff'"><span class="name">ite_eq_iff'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">P</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></div></div></div></div><div class="decl" id="dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L840-L841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_left_iff"><span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L843-L844">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_ne_right_iff"><span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L846-L847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_left_iff"><span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L849-L850">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ne_right_iff"><span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Ne.dite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L852-L853">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_left_iff"><span class="name">Ne</span>.<span class="name">dite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.dite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L855-L856">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_eq_right_iff"><span class="name">Ne</span>.<span class="name">dite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_eq_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L858-L859">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_left_iff"><span class="name">Ne</span>.<span class="name">ite_eq_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_eq_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L861-L862">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_eq_right_iff"><span class="name">Ne</span>.<span class="name">ite_eq_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.dite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L864-L865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_left_iff"><span class="name">Ne</span>.<span class="name">dite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">P</span>) =&gt; <span class="fn">a</span>)</span> <span class="fn">B</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.dite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L867-L868">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.dite_ne_right_iff"><span class="name">Ne</span>.<span class="name">dite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>) =&gt; <span class="fn">b</span></span>)</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_ne_left_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L870-L871">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_left_iff"><span class="name">Ne</span>.<span class="name">ite_ne_left_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span></div></div></div></div><div class="decl" id="Ne.ite_ne_right_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L873-L874">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Ne.ite_ne_right_iff"><span class="name">Ne</span>.<span class="name">ite_ne_right_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span></div></div></div></div><div class="decl" id="dite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L878-L879">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_eq_or_eq"><span class="name">dite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span> <span class="fn">h</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">A</span> <span class="fn">B</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="ite_eq_or_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L881-L882">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_eq_or_eq"><span class="name">ite_eq_or_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="apply_dite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L884-L889">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_dite₂"><span class="name">apply_dite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">a</span> <span class="fn">b</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">c</span> <span class="fn">d</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">a</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">c</span> <span class="fn">h</span>)</span></span> else <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">b</span> <span class="fn">h</span>)</span> <span class="fn">(<span class="fn">d</span> <span class="fn">h</span>)</span></span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#dite">dite</a></code>s is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="apply_ite₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L891-L895">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#apply_ite₂"><span class="name">apply_ite₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Sort</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">d</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">d</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">d</span></span></div></div><p>A two-argument function applied to two <code><a href="../.././Init/Prelude.html#ite">ite</a></code>s is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> of that two-argument function
applied to each of the branches.</p></div></div><div class="decl" id="dite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L897-L900">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_apply"><span class="name">dite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn">P</span> then <span class="fn"><span class="fn">f</span> <span class="fn">h</span> <span class="fn">a</span></span> else <span class="fn"><span class="fn">g</span> <span class="fn">h</span> <span class="fn">a</span></span></span></div></div><p>A 'dite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#dite">dite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L902-L905">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_apply"><span class="name">ite_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">σ</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">g</span>) <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></div></div><p>A 'ite' producing a <code>Pi</code> type <code>Π a, σ a</code>, applied to a value <code>a : α</code> is a <code><a href="../.././Init/Prelude.html#ite">ite</a></code> that applies
either branch to <code>a</code>.</p></div></div><div class="decl" id="ite_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L910-L911">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_and"><span class="name">ite_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="ite_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L913-L914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_or"><span class="name">ite_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="dite_dite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L916-L919">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_dite_comm"><span class="name">dite_dite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">A</span> : <span class="fn"><span class="fn">P</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">B</span> : <span class="fn"><span class="fn">Q</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span> → <span class="fn">α</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">if q : <span class="fn">Q</span> then <span class="fn"><span class="fn">B</span> <span class="fn">q</span></span> else <span class="fn">if p : <span class="fn">P</span> then <span class="fn"><span class="fn">A</span> <span class="fn">p</span></span> else <span class="fn"><span class="fn">C</span> <span class="fn">p</span> <span class="fn">q</span></span></span></span></div></div></div></div><div class="decl" id="ite_ite_comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L921-L924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_ite_comm"><span class="name">ite_ite_comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">c</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#ite">else</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="ite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L930-L931">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_or"><span class="name">ite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q </span><span class="fn">R</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">R</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">R</span></div></div></div></div><div class="decl" id="dite_prop_iff_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L933-L935">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_or"><span class="name">dite_prop_iff_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Q</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">p</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">Q</span> <span class="fn">p</span></span>) <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">p</span> <a href="../.././Init/Core.html#Exists">:</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">R</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="ite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L938-L939">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_prop_iff_and"><span class="name">ite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q </span><span class="fn">R</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">R</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">P</span> → <span class="fn">Q</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <span class="fn">R</span>)</span></div></div></div></div><div class="decl" id="dite_prop_iff_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L941-L943">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_prop_iff_and"><span class="name">dite_prop_iff_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Q</span> : <span class="fn"><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#dite">dite</a> <span class="fn">P</span> <span class="fn">Q</span> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">P</span>), <span class="fn"><span class="fn">Q</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">P</span>), <span class="fn"><span class="fn">R</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="if_ctx_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L949-L950">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_ctx_congr"><span class="name">if_ctx_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">u </span><span class="fn">v</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h_c</span> : <span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_t</span> : <span class="fn"><span class="fn">Q</span> → <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">u</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_e</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">Q</span> → <span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">u</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="if_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L952-L953">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#if_congr"><span class="name">if_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">Q</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">Q</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">u </span><span class="fn">v</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h_c</span> : <span class="fn">P</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">Q</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_t</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">u</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_e</span> : <span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">P</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">Q</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">u</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">v</span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Membership">Membership <a class="hover-link" href="#Membership">#</a></h3></div><div class="decl" id="Membership.mem.ne_of_notMem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L961-L961">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_notMem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_notMem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem">ne_of_mem_of_not_mem</a></code>.</p></div></div><div class="decl" id="Membership.mem.ne_of_notMem'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L962-L962">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_notMem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_notMem'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span> → <span class="fn">s</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">t</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem'">ne_of_mem_of_not_mem'</a></code>.</p></div></div><div class="decl" id="Membership.mem.ne_of_not_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L964-L965">source</a></div><div class="attributes">@[deprecated Membership.mem.ne_of_notMem (since := &quot;2025-05-23&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem">ne_of_mem_of_not_mem</a></code>.</p><hr></hr><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem">ne_of_mem_of_not_mem</a></code>.</p></div></div><div class="decl" id="Membership.mem.ne_of_not_mem'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L967-L968">source</a></div><div class="attributes">@[deprecated Membership.mem.ne_of_notMem' (since := &quot;2025-05-23&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#Membership.mem.ne_of_not_mem'"><span class="name">Membership</span>.<span class="name">mem</span>.<span class="name">ne_of_not_mem'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span> → <span class="fn">s</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">t</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem'">ne_of_mem_of_not_mem'</a></code>.</p><hr></hr><p><strong>Alias</strong> of <code><a href="../.././Init/PropLemmas.html#ne_of_mem_of_not_mem'">ne_of_mem_of_not_mem'</a></code>.</p></div></div><div class="decl" id="mem_dite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L974-L976">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#mem_dite"><span class="name">mem_dite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">if h : <span class="fn">p</span> then <span class="fn"><span class="fn">s</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">t</span> <span class="fn">h</span></span></span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">s</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span>), <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">t</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="dite_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L978-L980">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#dite_mem"><span class="name">dite_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn"><span class="fn">p</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(if h : <span class="fn">p</span> then <span class="fn"><span class="fn">a</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">b</span> <span class="fn">h</span></span>)</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><span class="fn">a</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span>), <span class="fn"><span class="fn">b</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="mem_ite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L982-L983">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#mem_ite"><span class="name">mem_ite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">s</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">t</span>) <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">p</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span>)</span></div></div></div></div><div class="decl" id="ite_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L985-L986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#ite_mem"><span class="name">ite_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn">p</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">(<a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">p</span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></div></div></div></div><div class="decl" id="not_beq_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L990-L991">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#not_beq_of_ne"><span class="name">not_beq_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ne</span> : <span class="fn">a</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a>(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="beq_eq_decide"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L993-L993">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_decide"><span class="name">beq_eq_decide</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></div></div><p><strong>Alias</strong> of <code><a href="../.././Init/Data/Bool.html#Bool.beq_eq_decide_eq">Bool.beq_eq_decide_eq</a></code>.</p></div></div><div class="decl" id="beq_eq_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L995-L996">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_eq_beq"><span class="name">beq_eq_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₁ </span><span class="fn">b₂</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn">a₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">b₁</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span>) <a href="../.././Init/Core.html#Iff">↔</a> (<span class="fn">a₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span>)</div></div></div></div><div class="decl" id="beq_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L998-L1005">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext"><span class="name">beq_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">inst1 </span><span class="fn">inst2</span> : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></div></div></div></div><div class="decl" id="beq_ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L998-L998">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#beq_ext_iff"><span class="name">beq_ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst1 </span><span class="fn">inst2</span> : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">x</span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">y</span>)</span></div></div></div></div><div class="decl" id="lawful_beq_subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Basic.lean#L1007-L1013">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Basic.html#lawful_beq_subsingleton"><span class="name">lawful_beq_subsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">inst1 </span><span class="fn">inst2</span> : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">inst1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst2</span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Function.DependsOn</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Function.DependsOn";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Function</span>.<span class="name">DependsOn</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Data/Set/Restrict.html">Mathlib.Data.Set.Restrict</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Function.DependsOn" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#DependsOn"><span class="name">DependsOn</span></a></div><div class="nav_link"><a class="break_within" href="#dependsOn_iff_factorsThrough"><span class="name">dependsOn_iff_factorsThrough</span></a></div><div class="nav_link"><a class="break_within" href="#dependsOn_iff_exists_comp"><span class="name">dependsOn_iff_exists_comp</span></a></div><div class="nav_link"><a class="break_within" href="#dependsOn_univ"><span class="name">dependsOn_univ</span></a></div><div class="nav_link"><a class="break_within" href="#dependsOn_const"><span class="name">dependsOn_const</span></a></div><div class="nav_link"><a class="break_within" href="#DependsOn.mono"><span class="name">DependsOn</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#DependsOn.empty"><span class="name">DependsOn</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Set.dependsOn_restrict"><span class="name">Set</span>.<span class="name">dependsOn_restrict</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Functions-depending-only-on-some-variables">Functions depending only on some variables <a class="hover-link" href="#Functions-depending-only-on-some-variables">#</a></h1><p>When dealing with a function <code>f : Π i, α i</code> depending on many variables, some operations
may get rid of the dependency on some variables (see <code>Function.updateFinset</code> or
<code>MeasureTheory.lmarginal</code> for example). However considering this new function
as having a different domain with fewer points is not comfortable in Lean, as it requires the use
of subtypes and can lead to tedious writing.</p><p>On the other hand one wants to be able for example to describe some function as constant
with respect to some variables, and be able to deduce this when applying transformations
mentioned above. This is why we introduce the predicate <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> f s</code>, which states that
if <code>x</code> and <code>y</code> coincide over the set <code>s</code>, then <code>f x = f y</code>.
This is equivalent to <code><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">Function.FactorsThrough</a> f s.restrict</code>.</p><h2 class="markdown-heading" id="Main-definition">Main definition <a class="hover-link" href="#Main-definition">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> f s</code>: If <code>x</code> and <code>y</code> coincide over the set <code>s</code>, then <code>f x</code> equals <code>f y</code>.</li>
</ul><h2 class="markdown-heading" id="Main-statement">Main statement <a class="hover-link" href="#Main-statement">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#dependsOn_iff_factorsThrough">dependsOn_iff_factorsThrough</a></code>: A function <code>f</code> depends on <code>s</code> if and only if it factors
through <code>s.restrict</code>.</li>
</ul><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>When we write <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> f s</code>, i.e. <code>f</code> only depends on <code>s</code>, it should be interpreted as
&quot;<code>f</code> <em>potentially</em> depends only on variables in <code>s</code>&quot;. However it might be the case
that <code>f</code> does not depend at all on variables in <code>s</code>, for example if <code>f</code> is constant.
As a consequence, <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> f univ</code> is always true, see <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#dependsOn_univ">dependsOn_univ</a></code>.</p><p>The predicate <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> f s</code> can also be interpreted as saying that <code>f</code> is independent of all
the variables which are not in <code>s</code>. Although this phrasing might seem more natural, we choose to go
with <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a></code> because writing mathematically &quot;independent of variables in <code>s</code>&quot; would boil down to
<code>∀ x y, (∀ i ∉ s, x i = y i) → f x = f y</code>, which is the same as <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> f sᶜ</code>.</p><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>depends on</p></div><div class="decl" id="DependsOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L53-L60">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn"><span class="name">DependsOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span>)</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">ι</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A function <code>f</code> depends on <code>s</code> if, whenever <code>x</code> and <code>y</code> coincide over <code>s</code>, <code>f x = f y</code>.</p><p>It should be interpreted as &quot;<code>f</code> <em>potentially</em> depends only on variables in <code>s</code>&quot;.
However it might be the case that <code>f</code> does not depend at all on variables in <code>s</code>,
for example if <code>f</code> is constant. As a consequence, <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> f univ</code> is always true,
see <code><a href="../../.././Mathlib/Logic/Function/DependsOn.html#dependsOn_univ">dependsOn_univ</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ ⦃<span class="fn">x </span><span class="fn">y</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span></span>⦄, <span class="fn"><span class="fn">(∀ <span class="fn">i</span> ∈ <span class="fn">s</span>, <span class="fn"><span class="fn">x</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span> <span class="fn">i</span></span>)</span> → <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span></span></li></ul></details><details id="instances-for-list-DependsOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="dependsOn_iff_factorsThrough"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L62-L65">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#dependsOn_iff_factorsThrough"><span class="name">dependsOn_iff_factorsThrough</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span>)</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.FactorsThrough">Function.FactorsThrough</a> <span class="fn">f</span> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span></span></div></div></div></div><div class="decl" id="dependsOn_iff_exists_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L67-L69">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#dependsOn_iff_exists_comp"><span class="name">dependsOn_iff_exists_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span>)</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">g</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">↑<span class="fn">s</span></span>) → <span class="fn"><span class="fn">α</span> <span class="fn">↑<span class="fn">i</span></span></span>)</span> → <span class="fn">β</span></span>), <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span></span></div></div></div></div><div class="decl" id="dependsOn_univ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#dependsOn_univ"><span class="name">dependsOn_univ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span>)</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div></div></div></div><div class="decl" id="dependsOn_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L76-L77">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#dependsOn_const"><span class="name">dependsOn_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span></span>) =&gt; <span class="fn">b</span>)</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span></div></div><p>A constant function does not depend on any variable.</p></div></div><div class="decl" id="DependsOn.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L79-L80">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn.mono"><span class="name">DependsOn</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span>)</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hst</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">t</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">f</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">f</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="DependsOn.empty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L82-L83">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn.empty"><span class="name">DependsOn</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span>)</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn">f</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></div></div><p>A function which depends on the empty set is constant.</p></div></div><div class="decl" id="Set.dependsOn_restrict"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Logic/Function/DependsOn.lean#L85-L86">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Logic/Function/DependsOn.html#Set.dependsOn_restrict"><span class="name">Set</span>.<span class="name">dependsOn_restrict</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">ι</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Function/DependsOn.html#DependsOn">DependsOn</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <span class="fn">s</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
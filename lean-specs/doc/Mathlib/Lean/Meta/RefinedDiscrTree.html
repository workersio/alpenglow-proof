<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Lean.Meta.RefinedDiscrTree</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Lean.Meta.RefinedDiscrTree";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">RefinedDiscrTree</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Lean/Meta/RefinedDiscrTree.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Initialize.html">Mathlib.Lean.Meta.RefinedDiscrTree.Initialize</a></li><li><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Lookup.html">Mathlib.Lean.Meta.RefinedDiscrTree.Lookup</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Lean.Meta.RefinedDiscrTree" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.RefinedDiscrTree.findImportMatches"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">RefinedDiscrTree</span>.<span class="name">findImportMatches</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.RefinedDiscrTree.findModuleMatches"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">RefinedDiscrTree</span>.<span class="name">findModuleMatches</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.RefinedDiscrTree.findMatches"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">RefinedDiscrTree</span>.<span class="name">findMatches</span></a></div></nav><main>
<div class="mod_doc"><p>A discrimination tree for the purpose of unifying local expressions with library results.</p><p>This data structure is based on <code><a href="../../.././Lean/Meta/DiscrTreeTypes.html#Lean.Meta.DiscrTree">Lean.Meta.DiscrTree</a></code> and <code>Lean.Meta.LazyDiscrTree</code>,
and includes many more features.</p><h2 class="markdown-heading" id="New-features">New features <a class="hover-link" href="#New-features">#</a></h2><ul>
<li><p>The keys <code>Key.lam</code>, <code>Key.forall</code> and <code>Key.bvar</code> have been introduced in order to allow for
matching under lambda and forall binders. <code>Key.lam</code> has arity 1 and indexes the body.
<code>Key.forall</code> has arity 2 and indexes the domain and the body. The reason for not indexing the
domain of a lambda expression is that it is usually already determined, for example in
<code>∃ a : α, p</code>, which is <code>@Exists α fun a : α =&gt; p</code>, we don't want to index the domain <code>α</code> twice.
In a forall expression we should index the domain, because in an implication <code>p → q</code>
we need to index both <code>p</code> and <code>q</code>. <code>Key.bvar</code> works the same as <code>Key.fvar</code>, but stores the
De Bruijn index to identify the variable.</p>
<p>For example, this allows for more specific matching with the left-hand side of
<code>∑ i ∈ Finset.range n, i = n * (n - 1) / 2</code>, which is indexed by
<code>[⟨Finset.sum, 5⟩, ⟨Nat, 0⟩, ⟨Nat, 0⟩, *0, ⟨Finset.Range, 1⟩, *1, λ, ⟨#0, 0⟩]</code>.</p>
</li>
<li><p>The key <code>Key.star</code> takes a <code><a href="../../.././Init/Prelude.html#Nat">Nat</a></code> identifier as an argument. For example,
the library pattern <code>?a + ?a</code> is encoded as <code>@HAdd.hAdd *0 *0 *1 *2 *3 *3</code>.
<code>*0</code> corresponds to the type of <code>?a</code>, <code>*1</code> to the outParam of <code><a href="../../.././Init/Prelude.html#HAdd.hAdd">HAdd.hAdd</a></code>,
<code>*2</code> to the <code><a href="../../.././Init/Prelude.html#HAdd">HAdd</a></code> instance, and <code>*3</code> to <code>a</code>. This means that it will only match an expression
<code>x + y</code> if <code>x</code> is indexed the same as <code>y</code>. The matching algorithm ensures that both
instances of <code>*3</code> match with the same pattern in the lookup expression.</p>
</li>
<li><p>We evaluate the matching score of a unification.
This score represents the number of keys that had to be the same for the unification to succeed.
For example, matching <code>(1 + 2) + 3</code> with <code>add_comm</code> gives a score of 2,
since the pattern of <code>add_comm</code> is <code>@HAdd.hAdd *0 *0 *0 *1 *2 *3</code>: matching <code><a href="../../.././Init/Prelude.html#HAdd.hAdd">HAdd.hAdd</a></code>
gives 1 point, and matching <code>*0</code> again after its first appearance gives another point.
Similarly, matching it with <code><a href="../../.././Init/Data/Nat/Basic.html#Nat.add_comm">Nat.add_comm</a></code> gives a score of 3, and <code>add_assoc</code> gives a score of 5.</p>
</li>
<li><p>Patterns that have the potential to be η-reduced are put into the <code>RefinedDiscrTree</code> under all
possible reduced key sequences. This is for terms of the form <code>fun x =&gt; f (?m x₁ .. xₙ)</code>, where
<code>?m</code> is a metavariable, one of <code>x₁, .., xₙ</code> is <code>x</code>, and <code>f</code> is not a metavariable.
For example, the pattern <code>Continuous fun y =&gt; Real.exp (f y)])</code> is indexed by
both <code>@Continuous *0 ℝ *1 *2 (λ, Real.exp *3)</code>
and  <code>@Continuous *0 ℝ *1 *2 Real.exp</code>,
so that it also comes up if you look up <code>Continuous Real.exp</code>.</p>
</li>
<li><p>How to deal with number literals is waiting for this issue to be resolved:
<a href="https://github.com/leanprover/lean4/issues/2867">https://github.com/leanprover/lean4/issues/2867</a></p>
</li>
<li><p>The key <code>Key.opaque</code> only matches with a <code>Key.star</code> key.
Depending on the configuration, β-reduction and ζ-reduction may be disabled, so the resulting
applied lambda expressions or let-expressions are indexed by <code>Key.opaque</code>.</p>
</li>
</ul><h2 class="markdown-heading" id="Lazy-computation">Lazy computation <a class="hover-link" href="#Lazy-computation">#</a></h2><p>To encode an <code>Expr</code> as a sequence of <code>Key</code>s, we start with a <code>LazyEntry</code> and
we have a incremental evaluation function of type
<code>LazyEntry → MetaM (Option (List (Key × LazyEntry)))</code>, which computes the next keys
and lazy entries, or returns <code>none</code> if the last key has been reached already.</p><p>The <code>RefinedDiscrTree</code> then stores these <code>LazyEntries</code> at its leafs, and evaluates them
only if the lookup algorithm reaches this leaf.</p><h2 class="markdown-heading" id="Alternative-optimizations">Alternative optimizations <a class="hover-link" href="#Alternative-optimizations">#</a></h2><p><code>RefinedDiscrTree</code> is a non-persistent lazy data-structure. Therefore, when using it, you should
try to use it linearly (i.e. having reference count 1). This is ideal for library search purposes,
which build the discrimination tree once, and store a reference to the tree.</p><p>However, for tactics like <code>simp</code> and <code>fun_prop</code> this is less ideal, because they can't use the
data-structure linearly, since copies of the data structure must regularly be stored in the
environment. For <code>fun_prop</code> this is not a serious problem since it doesn't have that many
different lemmas anyways.</p><h4 class="markdown-heading" id="Future-work">Future work: <a class="hover-link" href="#Future-work">#</a></h4><p>Make a version of <code>RefinedDiscrTree</code> that is optimal for tactics like <code>simp</code> and
<code>fun_prop</code>. This would mean using a persistent data structure, and possibly a non-lazy structure.</p><h2 class="markdown-heading" id="Matching-vs-Unification">Matching vs Unification <a class="hover-link" href="#Matching-vs-Unification">#</a></h2><p>A discrimination tree can be used in two ways: either with (unification) or without (matching)
allowing metavariables in the target expression to be instantiated.
Most applications use matching, and the only common use case where unification is used is
type class search. Since the intended applications of the <code>RefinedDiscrTree</code> currently use
matching, the lookup algorithm is most optimized for matching.</p><h4 class="markdown-heading" id="Future-work">Future work: <a class="hover-link" href="#Future-work">#</a></h4><p>Improve the unification lookup.</p></div><div class="decl" id="Lean.Meta.RefinedDiscrTree.findImportMatches"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Lean/Meta/RefinedDiscrTree.lean#L108-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree.html#Lean.Meta.RefinedDiscrTree.findImportMatches"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">RefinedDiscrTree</span>.<span class="name">findImportMatches</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../.././Lean/Environment.html#Lean.EnvExtension">EnvExtension</a> <span class="fn">(<a href="../../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Basic.html#Lean.Meta.RefinedDiscrTree">RefinedDiscrTree</a> <span class="fn">α</span>)</span>)</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">addEntry</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Name</a> → <span class="fn"><a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">ConstantInfo</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> (<a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Basic.html#Lean.Meta.RefinedDiscrTree.Key">Key</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Basic.html#Lean.Meta.RefinedDiscrTree.LazyEntry">LazyEntry</a>)</span>))</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ty</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">constantsPerTask</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">1000</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">capacityPerTask</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">128</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Lookup.html#Lean.Meta.RefinedDiscrTree.MatchResult">MatchResult</a> <span class="fn">α</span>)</span></span></div></div><p>Returns candidates from all imported modules that match the expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.RefinedDiscrTree.findImportMatches" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.RefinedDiscrTree.findModuleMatches"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Lean/Meta/RefinedDiscrTree.lean#L128-L134">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree.html#Lean.Meta.RefinedDiscrTree.findModuleMatches"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">RefinedDiscrTree</span>.<span class="name">findModuleMatches</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">moduleRef</span> : <span class="fn"><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Initialize.html#Lean.Meta.RefinedDiscrTree.ModuleDiscrTreeRef">ModuleDiscrTreeRef</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ty</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Lookup.html#Lean.Meta.RefinedDiscrTree.MatchResult">MatchResult</a> <span class="fn">α</span>)</span></span></div></div><p>Returns candidates from this module that match the expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.RefinedDiscrTree.findModuleMatches" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.RefinedDiscrTree.findMatches"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Lean/Meta/RefinedDiscrTree.lean#L136-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree.html#Lean.Meta.RefinedDiscrTree.findMatches"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">RefinedDiscrTree</span>.<span class="name">findMatches</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../.././Lean/Environment.html#Lean.EnvExtension">EnvExtension</a> <span class="fn">(<a href="../../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Basic.html#Lean.Meta.RefinedDiscrTree">RefinedDiscrTree</a> <span class="fn">α</span>)</span>)</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">addEntry</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Name</a> → <span class="fn"><a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">ConstantInfo</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> (<a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Basic.html#Lean.Meta.RefinedDiscrTree.Key">Key</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Basic.html#Lean.Meta.RefinedDiscrTree.LazyEntry">LazyEntry</a>)</span>))</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ty</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">constantsPerTask</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">1000</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">capacityPerTask</span> : <a href="../../.././Init/Prelude.html#Nat">Nat</a> := <span class="fn">128</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn"><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Lookup.html#Lean.Meta.RefinedDiscrTree.MatchResult">MatchResult</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree/Lookup.html#Lean.Meta.RefinedDiscrTree.MatchResult">MatchResult</a> <span class="fn">α</span></span>)</span></div></div><p><code><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree.html#Lean.Meta.RefinedDiscrTree.findMatches">findMatches</a></code> combines <code><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree.html#Lean.Meta.RefinedDiscrTree.findImportMatches">findImportMatches</a></code> and <code><a href="../../.././Mathlib/Lean/Meta/RefinedDiscrTree.html#Lean.Meta.RefinedDiscrTree.findModuleMatches">findModuleMatches</a></code>.</p><ul>
<li><code>ext</code> should be an environment extension with an <code><a href="../../.././Init/System/IO.html#IO.Ref">IO.Ref</a></code> for caching the <code>RefinedDiscrTree</code>.</li>
<li><code>addEntry</code> is the function for creating <code>RefinedDiscrTree</code> entries from constants.</li>
<li><code>ty</code> is the expression type.</li>
<li><code>constantsPerTask</code> is the number of constants in imported modules to be used for each
new task.</li>
<li><code>capacityPerTask</code> is the initial capacity of the <code>HashMap</code> at the root of the
<code>RefinedDiscrTree</code> for each new task.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.RefinedDiscrTree.findMatches" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
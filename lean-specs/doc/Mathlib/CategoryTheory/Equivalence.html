<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Equivalence</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Equivalence";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/EssentialImage.html">Mathlib.CategoryTheory.EssentialImage</a></li><li><a href="../.././Mathlib/CategoryTheory/Whiskering.html">Mathlib.CategoryTheory.Whiskering</a></li><li><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html">Mathlib.CategoryTheory.Functor.FullyFaithful</a></li><li><a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html">Mathlib.CategoryTheory.ObjectProperty.FullSubcategory</a></li><li><a href="../.././Mathlib/Tactic/CategoryTheory/Slice.html">Mathlib.Tactic.CategoryTheory.Slice</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Equivalence" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ext"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.«term_≌_»"><span class="name">CategoryTheory</span>.<span class="name">«term_≌_»</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.instCategory"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkHom"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">asNatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">hom_ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.hom_ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">hom_ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkHom_asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_asNatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.asNatTrans_mkHom"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">asNatTrans_mkHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.id_asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">id_asNatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.comp_asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">comp_asNatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.comp_asNatTrans_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">comp_asNatTrans_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkHom_id_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_id_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkHom_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkHom_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkIso_inv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkIso_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkIso_hom"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkIso_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functorFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functorFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functorFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functorFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functorFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functorFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counitInv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_naturality</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_naturality_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_naturality</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_naturality_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_naturality</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_naturality_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_naturality</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_naturality_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_unit_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.functor_unit_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_functor_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counitInv_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_app_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.counit_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_app_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_inverse_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_inverse_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_counitInv_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unit_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_app_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.unitInv_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_app_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fun_inv_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inv_fun_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointifyη"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointifyη</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointify_η_ε"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.adjointify_η_ε_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.refl_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.instInhabited"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.symm_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.mkHom_id_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_id_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.trans_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrLeft_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRight_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRightFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRightFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRightFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRightFunctor_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.congrRightFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRightFunctor_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unitInv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counit_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_unit_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.powNat"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">powNat</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.instPowInt"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instPowInt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_zero"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_one</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.pow_neg_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_neg_one</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurj_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurj_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullyFaithfulFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullyFaithfulInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.faithful_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.faithful_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.full_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.full_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeFunctor_trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.changeInverse_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.isEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.isEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.IsEquivalence.mk'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.asEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_refl"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_inv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_trans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_trans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringLeft"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringRight"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">fun_inv_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv_fun_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_iff_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_iff_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_of_comp_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.isEquivalence_of_comp_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.essSurjInducedFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurjInducedFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.inducedFunctorOfEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inducedFunctorOfEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.fullyFaithfulToEssImage"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulToEssImage</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ObjectProperty.fullSubcategoryCongr"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ObjectProperty.fullSubcategoryCongr_functor"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ObjectProperty.fullSubcategoryCongr_unitIso"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ObjectProperty.fullSubcategoryCongr_counitIso"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ObjectProperty.fullSubcategoryCongr_inverse"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.ofFullSubcategory"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.compInverseIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoCompInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.inverseCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_hom_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_inv_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoFunctorOfIsoInverse_isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_isoInverseOfIsoFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Iso.isoInverseOfIsoFunctor_isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_isoFunctorOfIsoInverse</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Equivalence-of-categories">Equivalence of categories <a class="hover-link" href="#Equivalence-of-categories">#</a></h1><p>An equivalence of categories <code>C</code> and <code>D</code> is a pair of functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> such
that <code>η : 𝟭 C ≅ F ⋙ G</code> and <code>ε : G ⋙ F ≅ 𝟭 D</code>. In many situations, equivalences are a better
notion of &quot;sameness&quot; of categories than the stricter isomorphism of categories.</p><p>Recall that one way to express that two functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> are adjoint is using
two natural transformations <code>η : 𝟭 C ⟶ F ⋙ G</code> and <code>ε : G ⋙ F ⟶ 𝟭 D</code>, called the unit and the
counit, such that the compositions <code>F ⟶ FGF ⟶ F</code> and <code>G ⟶ GFG ⟶ G</code> are the identity. Unfortunately,
it is not the case that the natural isomorphisms <code>η</code> and <code>ε</code> in the definition of an equivalence
automatically give an adjunction. However, it is true that</p><ul>
<li>if one of the two compositions is the identity, then so is the other, and</li>
<li>given an equivalence of categories, it is always possible to refine <code>η</code> in such a way that the
identities are satisfied.</li>
</ul><p>For this reason, in mathlib we define an equivalence to be a &quot;half-adjoint equivalence&quot;, which is
a tuple <code>(F, G, η, ε)</code> as in the first paragraph such that the composite <code>F ⟶ FGF ⟶ F</code> is the
identity. By the remark above, this already implies that the tuple is an &quot;adjoint equivalence&quot;,
i.e., that the composite <code>G ⟶ GFG ⟶ G</code> is also the identity.</p><p>We also define essentially surjective functors and show that a functor is an equivalence if and only
if it is full, faithful and essentially surjective.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../.././Init/Core.html#Equivalence">Equivalence</a></code>: bundled (half-)adjoint equivalences of categories</li>
<li><code>Functor.EssSurj</code>: type class on a functor <code>F</code> containing the data of the preimages
and the isomorphisms <code>F.obj (preimage d) ≅ d</code>.</li>
<li><code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">Functor.IsEquivalence</a></code>: type class on a functor <code>F</code> which is full, faithful and
essentially surjective.</li>
</ul><h2 class="markdown-heading" id="Main-results">Main results <a class="hover-link" href="#Main-results">#</a></h2><ul>
<li><code><a href="../.././Init/Core.html#Equivalence.mk">Equivalence.mk</a></code>: upgrade an equivalence to a (half-)adjoint equivalence</li>
<li><code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_iff_of_iso">isEquivalence_iff_of_iso</a></code>: when <code>F</code> and <code>G</code> are isomorphic functors,
<code>F</code> is an equivalence iff <code>G</code> is.</li>
<li><code>Functor.asEquivalenceFunctor</code>: construction of an equivalence of categories from
a functor <code>F</code> which satisfies the property <code>F.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></code> (i.e. <code>F</code> is full, faithful
and essentially surjective).</li>
</ul><h2 class="markdown-heading" id="Notation">Notation <a class="hover-link" href="#Notation">#</a></h2><p>We write <code>C ≌ D</code> (<code>\backcong</code>, not to be confused with <code>≅</code>/<code>\cong</code>) for a bundled equivalence.</p></div><div class="decl" id="CategoryTheory.Equivalence"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L65-L96">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (max u₁ u₂) v₁) v₂)</div></div><p>An equivalence of categories.</p><p>We define an equivalence between <code>C</code> and <code>D</code>, with notation <code>C ≌ D</code>, as a half-adjoint equivalence:
a pair of functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> with a unit <code>η : 𝟭 C ≅ F ⋙ G</code> and counit
<code>ε : G ⋙ F ≅ 𝟭 D</code>, such that the natural isomorphisms <code>η</code> and <code>ε</code> satisfy the triangle law for
<code>F</code>: namely, <code>Fη ≫ εF = 𝟙 F</code>. Or, in other words, the composite <code>F</code> ⟶ <code>F ⋙ G ⋙ F</code> ⟶ <code>F</code> is the
identity.</p><p>In <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp">unit_inverse_comp</a></code>, we show that this is sufficient to establish a full adjoint
equivalence. I.e., the composite <code>G</code> ⟶ <code>G ⋙ F ⋙ G</code> ⟶ <code>G</code> is also the identity.</p><p>The triangle equation <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unitIso_comp">functor_unitIso_comp</a></code> is written as a family of equalities between
morphisms. It is more complicated if we write it as an equality of natural transformations, because
then we would either have to insert natural transformations like <code>F ⟶ F𝟭</code> or abuse defeq.</p><ul class="structure_ext"><li id="CategoryTheory.Equivalence.mk'" class="structure_ext_ctor">mk' :: (</li><ul class="structure_ext_fields"><li id="CategoryTheory.Equivalence.functor" class="structure_field"><div class="structure_field_info">functor : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span></div><div class="structure_field_doc"><p>The forwards direction of an equivalence.</p></div></li><li id="CategoryTheory.Equivalence.inverse" class="structure_field"><div class="structure_field_info">inverse : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>The backwards direction of an equivalence.</p></div></li><li id="CategoryTheory.Equivalence.unitIso" class="structure_field"><div class="structure_field_info">unitIso : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div><div class="structure_field_doc"><p>The composition <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> is isomorphic to the identity.</p></div></li><li id="CategoryTheory.Equivalence.counitIso" class="structure_field"><div class="structure_field_info">counitIso : <span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span></div><div class="structure_field_doc"><p>The composition <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> is isomorphic to the identity.</p></div></li><li id="CategoryTheory.Equivalence.functor_unitIso_comp" class="structure_field"><div class="structure_field_info">functor_unitIso_comp<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div><div class="structure_field_doc"><p>The triangle law for the forwards direction of an equivalence: the unit and counit compose
to the identity when whiskered along the forwards direction.</p><p>We state this as a family of equalities among morphisms instead of an equality of natural
transformations to avoid abusing defeq or inserting natural transformations like <code>F ⟶ F𝟭</code>.</p></div></li></ul><li class="structure_ext_ctor">)</li></ul><details id="instances-for-list-CategoryTheory.Equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L79-L79">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝¹</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L79-L79">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ext"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">inst✝¹</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unitIso</span> : <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counitIso</span> : <span class="fn"><span class="fn">x</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#HEq">≍</a> <span class="fn"><span class="fn">y</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="CategoryTheory.«term_≌_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.«term_≌_»"><span class="name">CategoryTheory</span>.<span class="name">«term_≌_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>An equivalence of categories.</p><p>We define an equivalence between <code>C</code> and <code>D</code>, with notation <code>C ≌ D</code>, as a half-adjoint equivalence:
a pair of functors <code>F : C ⥤ D</code> and <code>G : D ⥤ C</code> with a unit <code>η : 𝟭 C ≅ F ⋙ G</code> and counit
<code>ε : G ⋙ F ≅ 𝟭 D</code>, such that the natural isomorphisms <code>η</code> and <code>ε</code> satisfy the triangle law for
<code>F</code>: namely, <code>Fη ≫ εF = 𝟙 F</code>. Or, in other words, the composite <code>F</code> ⟶ <code>F ⋙ G ⋙ F</code> ⟶ <code>F</code> is the
identity.</p><p>In <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp">unit_inverse_comp</a></code>, we show that this is sufficient to establish a full adjoint
equivalence. I.e., the composite <code>G</code> ⟶ <code>G ⋙ F ⋙ G</code> ⟶ <code>G</code> is also the identity.</p><p>The triangle equation <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unitIso_comp">functor_unitIso_comp</a></code> is written as a family of equalities between
morphisms. It is more complicated if we write it as an equality of natural transformations, because
then we would either have to insert natural transformations like <code>F ⟶ F𝟭</code> or abuse defeq.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.«term_≌_»">CategoryTheory.«term_≌_»</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`CategoryTheory.«term_≌_»</span> <span class="fn">10</span> <span class="fn">11</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ≌ &quot;</span>)</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">10</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.«term_≌_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.unit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L105-L107">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div><p>The unit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.unit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.counit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L109-L111">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span></div></div><p>The counit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.counit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L113-L115">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span></div></div><p>The inverse of the unit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.unitInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L117-L119">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div><p>The inverse of the counit of an equivalence of categories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.counitInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.instCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L123-L126">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instCategory"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instCategory</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{max u₁ v₂, max (max (max u₂ u₁) v₂) v₁}</a> (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.mkHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L128-L129">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span></div></div><p>Promote a natural transformation <code>e.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⟶ f.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> to a morphism in <code>C ≌ D</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">CategoryTheory.Equivalence.mkHom</a> <span class="fn">η</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">η</span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.mkHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.asNatTrans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L131-L133">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">asNatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div><p>Recover a natural transformation between <code>e.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> and <code>f.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> from the data of
a morphism <code>e ⟶ f</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">CategoryTheory.Equivalence.asNatTrans</a> <span class="fn">η</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">η</span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.asNatTrans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.hom_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L135-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.hom_ext"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">hom_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.hom_ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L135-L135">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.hom_ext_iff"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">hom_ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">β</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">β</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mkHom_asNatTrans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L138-L141">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom_asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_asNatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">η</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">η</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.asNatTrans_mkHom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L143-L146">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans_mkHom"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">asNatTrans_mkHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">η</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">η</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.id_asNatTrans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L148-L149">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.id_asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">id_asNatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">e</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.comp_asNatTrans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L151-L154">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.comp_asNatTrans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">comp_asNatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f </span><span class="fn">g</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">α</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.comp_asNatTrans_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L151-L151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.comp_asNatTrans_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">comp_asNatTrans_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f </span><span class="fn">g</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">β</span>)</span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">α</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">β</span>)</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mkHom_id_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L156-L157">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom_id_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_id_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">e</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mkHom_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L159-L162">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f </span><span class="fn">g</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">α</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mkHom_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L159-L159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f </span><span class="fn">g</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">g</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">β</span>)</span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">α</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">β</span>)</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mkIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L164-L169">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">f</span></div></div><p>Construct an isomorphism in <code>C ≌ D</code> from a natural isomorphism between the functors
of the equivalences.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkIso">CategoryTheory.Equivalence.mkIso</a> <span class="fn">η</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.mk">{</a> <span class="fn">hom</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">CategoryTheory.Equivalence.mkHom</a> <span class="fn"><span class="fn">η</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></span>, <span class="fn">inv</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">CategoryTheory.Equivalence.mkHom</a> <span class="fn"><span class="fn">η</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></span>, <span class="fn">hom_inv_id</span> := <span class="fn">⋯</span>,
    <span class="fn">inv_hom_id</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.mk">}</a></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.mkIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.mkIso_inv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L166-L166">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkIso_inv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkIso_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkIso">mkIso</a> <span class="fn">η</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn"><span class="fn">η</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mkIso_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L166-L166">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkIso_hom"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkIso_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkIso">mkIso</a> <span class="fn">η</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn"><span class="fn">η</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functorFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L172-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functorFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functorFunctor</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>) <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span>)</span></span></div></div><p>The <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> functor that sends an equivalence of categories to its functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.functorFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.functorFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L173-L173">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functorFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functorFunctor_obj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functorFunctor">functorFunctor</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functorFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L173-L173">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functorFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functorFunctor_map</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X✝ </span><span class="fn">Y✝</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn">X✝</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functorFunctor">functorFunctor</a> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_unit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L182-L185">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_unit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">{</a> <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">}</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_counit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L187-L190">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_counit"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">{</a> <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">}</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L192-L195">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_unitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_unitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">{</a> <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">}</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L197-L200">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.Equivalence_mk'_counitInv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">Equivalence_mk'_counitInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">functor</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inverse</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">unit_iso</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">inverse</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">counit_iso</span> : <span class="fn"><span class="fn"><span class="fn">inverse</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">functor</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> :
  <span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>),
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">unit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>       <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">functor</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">{</a> <span class="fn">functor</span> := <span class="fn">functor</span>, <span class="fn">inverse</span> := <span class="fn">inverse</span>, <span class="fn">unitIso</span> := <span class="fn">unit_iso</span>, <span class="fn">counitIso</span> := <span class="fn">counit_iso</span>,
      <span class="fn">functor_unitIso_comp</span> := <span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">}</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">counit_iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counit_naturality"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L202-L205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_naturality</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counit_naturality_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L202-L202">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_naturality_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_naturality"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L207-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_naturality</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_naturality_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L207-L207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_naturality_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_naturality"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L212-L215">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_naturality</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_naturality_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L212-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_naturality_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv_naturality"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L217-L220">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv_naturality"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_naturality</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv_naturality_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L217-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv_naturality_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_naturality_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_unit_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L222-L225">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unit_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.functor_unit_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L222-L222">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor_unit_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">functor_unit_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_functor_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L227-L231">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_functor_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L227-L227">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_functor_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_functor_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counitInv_app_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L233-L238">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counitInv_app_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.counit_app_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L240-L242">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit_app_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">counit_app_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_inverse_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L244-L278">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span></div></div><p>The other triangle equality. The proof follows the following proof in Globular:
<a href="http://globular.science/1905.001">http://globular.science/1905.001</a></p></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_inverse_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L246-L246">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_inverse_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_inverse_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_counitInv_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L280-L284">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_counitInv_comp"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L280-L280">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse_counitInv_comp_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inverse_counitInv_comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unit_app_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L286-L288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unit_app_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.unitInv_app_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L290-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv_app_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">unitInv_app_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fun_inv_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L295-L298">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fun_inv_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L295-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fun_inv_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fun_inv_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inv_fun_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L300-L303">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inv_fun_map_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L300-L300">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inv_fun_map_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inv_fun_map_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span> <span class="fn">h</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointifyη"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L310-L321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointifyη</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span></div></div><p>If <code>η : 𝟭 C ≅ F ⋙ G</code> is part of a (not necessarily half-adjoint) equivalence, we can upgrade it
to a refined natural isomorphism <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">adjointifyη</a> η : 𝟭 C ≅ F ⋙ G</code> which exhibits the properties
required for a half-adjoint equivalence. See <code><a href="../.././Init/Core.html#Equivalence.mk">Equivalence.mk</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.adjointifyη" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointify_η_ε"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L323-L332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointify_η_ε"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">ε</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.adjointify_η_ε_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L323-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointify_η_ε_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">adjointify_η_ε_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">ε</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">h</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L336-L340">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>Every equivalence of categories consisting of functors <code>F</code> and <code>G</code> such that <code>F ⋙ G</code> and
<code>G ⋙ F</code> are naturally isomorphic to identity functors can be transformed into a half-adjoint
equivalence without changing <code>F</code> or <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk">CategoryTheory.Equivalence.mk</a> <span class="fn">F</span> <span class="fn">G</span> <span class="fn">η</span> <span class="fn">ε</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">{</a> <span class="fn">functor</span> := <span class="fn">F</span>, <span class="fn">inverse</span> := <span class="fn">G</span>, <span class="fn">unitIso</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.adjointifyη">CategoryTheory.Equivalence.adjointifyη</a> <span class="fn">η</span> <span class="fn">ε</span></span>, <span class="fn">counitIso</span> := <span class="fn">ε</span>,
    <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">}</a></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.refl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L342-L345">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></div></div><p>Equivalence of categories is reflexive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.refl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L343-L343">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L343-L343">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L343-L343">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.refl_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L343-L343">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">refl_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L347-L348">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instInhabited"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instInhabited">CategoryTheory.Equivalence.instInhabited</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">CategoryTheory.Equivalence.refl</a> <a href="../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.symm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L350-L353">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></div></div><p>Equivalence of categories is symmetric.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">{</a> <span class="fn">functor</span> := <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>, <span class="fn">inverse</span> := <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>, <span class="fn">unitIso</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>, <span class="fn">counitIso</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>,
    <span class="fn">functor_unitIso_comp</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mk'">}</a></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.symm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L351-L351">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L351-L351">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L351-L351">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.symm_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L351-L351">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">symm_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.mkHom_id_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L355-L356">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom_id_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">mkHom_id_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryStruct.id</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L360-L377">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span></div></div><p>Equivalence of categories is transitive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.trans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L361-L361">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a>
        (<span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>)
        <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L361-L361">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L361-L361">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">Functor.isoWhiskerRight</a>
        (<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>           <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>)
        <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.trans_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L361-L361">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">trans_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">f</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">f</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L379-L382">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></div></div><p>Composing a functor with both functors of an equivalence yields a naturally isomorphic
functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">CategoryTheory.Functor.isoWhiskerRight</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.funInvIdAssoc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L384-L388">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L390-L394">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">funInvIdAssoc_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L396-L399">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span></div></div><p>Composing a functor with both functors of an equivalence yields a naturally isomorphic
functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">CategoryTheory.Functor.isoWhiskerRight</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.invFunIdAssoc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L401-L405">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L407-L411">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">invFunIdAssoc_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L413-L424">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span></div></div><p>If <code>C</code> is equivalent to <code>D</code>, then <code>C ⥤ E</code> is equivalent to <code>D ⥤ E</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.congrLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L414-L414">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.funInvIdAssoc">funInvIdAssoc</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L414-L414">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a> <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.invFunIdAssoc">invFunIdAssoc</a></span> <span class="fn">F</span></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L414-L414">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskeringLeft">Functor.whiskeringLeft</a> <span class="fn">D</span> <span class="fn">C</span> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrLeft_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L414-L414">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrLeft_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrLeft">congrLeft</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskeringLeft">Functor.whiskeringLeft</a> <span class="fn">C</span> <span class="fn">D</span> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L426-L434">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">D</span></span></div></div><p>If <code>C</code> is equivalent to <code>D</code>, then <code>E ⥤ C</code> is equivalent to <code>E ⥤ D</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.congrRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L427-L427">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskeringRight">Functor.whiskeringRight</a> <span class="fn">E</span> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L427-L427">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L427-L427">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">NatIso.ofComponents</a>
    <span class="fn">(fun (<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRight_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L427-L427">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRight_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskeringRight">Functor.whiskeringRight</a> <span class="fn">E</span> <span class="fn">D</span> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRightFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L437-L441">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRightFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRightFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>) (<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>)</span></div></div><p>Promoting <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">Equivalence.congrRight</a></code> to a functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.congrRightFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRightFunctor_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L438-L438">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRightFunctor_obj"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRightFunctor_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRightFunctor">congrRightFunctor</a> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRight">congrRight</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.congrRightFunctor_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L438-L438">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRightFunctor_map"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">congrRightFunctor_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e </span><span class="fn">f</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <span class="fn">e</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">f</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.congrRightFunctor">congrRightFunctor</a> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.mkHom">mkHom</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskeringRight">Functor.whiskeringRight</a> <span class="fn">E</span> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.asNatTrans">asNatTrans</a> <span class="fn">α</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L452-L454">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unitInv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L456-L458">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unitInv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counit_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L460-L462">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counit_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counit_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">Y</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L464-L466">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f'</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L468-L471">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L473-L476">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right_assoc"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_unit_right_assoc'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L478-L482">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_unit_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_unit_right_assoc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y </span><span class="fn">Y' </span><span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn">Y'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">h'</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L484-L488">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.cancel_counitInv_right_assoc'"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">cancel_counitInv_right_assoc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W </span><span class="fn">X </span><span class="fn">X' </span><span class="fn">Y </span><span class="fn">Y' </span><span class="fn">Z</span> : <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">W</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g'</span> : <span class="fn">X'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn">Y'</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h'</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Z</span>)</span>)</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">h'</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.powNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L497-L501">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">powNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Nat">ℕ</a> → (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></div></div><p>Natural number powers of an auto-equivalence.  Use <code>(^)</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">CategoryTheory.Equivalence.refl</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn">1</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn"><span class="fn"><span class="fn">n</span>.<a href="../.././Init/Prelude.html#Nat.succ">succ</a></span>.<a href="../.././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.trans">trans</a></span> <span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> (<span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>))</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.powNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.pow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L503-L506">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> → (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></div></div><p>Powers of an auto-equivalence.  Use <code>(^)</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow">pow</a></span> <span class="fn">(<a href="../.././Init/Data/Int/Basic.html#Int.ofNat">Int.ofNat</a> <span class="fn">n</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> <span class="fn">n</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow">pow</a></span> <span class="fn">(<a href="../.././Init/Data/Int/Basic.html#Int.negSucc">Int.negSucc</a> <span class="fn">n</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.powNat">powNat</a></span> (<span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.pow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.instPowInt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L508-L509">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instPowInt"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">instPowInt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Pow">Pow</a> (<span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>) <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.instPowInt">CategoryTheory.Equivalence.instPowInt</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Pow.mk">{</a> <span class="fn">pow</span> := <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow">CategoryTheory.Equivalence.pow</a> <a href="../.././Init/Prelude.html#Pow.mk">}</a></li></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L511-L513">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_zero"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">0</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.refl">refl</a></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L515-L517">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.pow_neg_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L519-L521">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.pow_neg_one"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">pow_neg_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">e</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">(-<span class="fn">1</span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.symm">symm</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurj_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L528-L531">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurj_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div><p>The functor of an equivalence of categories is essentially surjective.</p></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurj_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L533-L534">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurj_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurj_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fullyFaithfulFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L536-L538">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The functor of an equivalence of categories is fully faithful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.fullyFaithfulFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.fullyFaithfulInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L540-L542">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.FullyFaithful">FullyFaithful</a></span></div></div><p>The inverse of an equivalence of categories is fully faithful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.fullyFaithfulInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.faithful_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L544-L547">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.faithful_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div><p>The functor of an equivalence of categories is faithful.</p></div></div><div class="decl" id="CategoryTheory.Equivalence.faithful_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L549-L550">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.faithful_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">faithful_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.full_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L552-L555">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.full_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div><p>The functor of an equivalence of categories is full.</p></div></div><div class="decl" id="CategoryTheory.Equivalence.full_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L557-L558">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.full_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">full_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L560-L567">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>If <code>e : C ≌ D</code> is an equivalence of categories, and <code>iso : e.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G</code> is
an isomorphism, then there is an equivalence of categories whose functor is <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.changeFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_counitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L562-L562">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L562-L562">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L562-L562">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_unitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L562-L562">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L562-L562">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">G</span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_counitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L562-L562">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_counitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L569-L570">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_refl"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></code> with identity isomorphisms of functors</p></div></div><div class="decl" id="CategoryTheory.Equivalence.changeFunctor_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L572-L574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor_trans"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeFunctor_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso₁</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iso₂</span> : <span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso₁</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> <span class="fn">iso₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></span> (<span class="fn">iso₁</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn">iso₂</span>)</span></div></div><p>Compatibility of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeFunctor">changeFunctor</a></code> with the composition of isomorphisms of functors</p></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L576-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>If <code>e : C ≌ D</code> is an equivalence of categories, and <code>iso : e.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G</code> is
an isomorphism, then there is an equivalence of categories whose inverse is <code>G</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.changeInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L578-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_counitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L578-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_counitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_unitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L578-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_unitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_unitIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L578-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_unitIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_unitIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_counitIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L578-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_counitIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_counitIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">iso</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.changeInverse_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L578-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">changeInverse_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iso</span> : <span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">e</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.changeInverse">changeInverse</a></span> <span class="fn">iso</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">G</span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsEquivalence"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L590-L595">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>A functor is an equivalence of categories if it is faithful, full and
essentially surjective.</p><ul class="structure_fields" id="CategoryTheory.Functor.IsEquivalence.mk"><li id="CategoryTheory.Functor.IsEquivalence.faithful" class="structure_field"><div class="structure_field_info">faithful : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span></div></li><li id="CategoryTheory.Functor.IsEquivalence.full" class="structure_field"><div class="structure_field_info">full : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span></div></li><li id="CategoryTheory.Functor.IsEquivalence.essSurj" class="structure_field"><div class="structure_field_info">essSurj : <span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Functor.IsEquivalence" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.isEquivalence_functor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L597-L597">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.isEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.isEquivalence_inverse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L599-L600">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.isEquivalence_inverse"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">isEquivalence_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.IsEquivalence.mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L608-L612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence.mk'"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">IsEquivalence</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">η</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ε</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div><p>To see that a functor is an equivalence, it suffices to provide an inverse functor <code>G</code> such that
<code>F ⋙ G</code> and <code>G ⋙ F</code> are naturally isomorphic to identity functors.</p></div></div><div class="decl" id="CategoryTheory.Functor.inv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L616-L622">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span></div></div><p>A quasi-inverse <code>D ⥤ C</code> to a functor that <code>F : C ⥤ D</code> that is an equivalence,
i.e. faithful, full, and essentially surjective.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.inv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L624-L632">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></div></div><p>Interpret a functor that is an equivalence as an equivalence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.asEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.asEquivalence_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L625-L625">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence_functor"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">asEquivalence_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">F</span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_refl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L634-L635">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_refl"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn">C</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_inv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L637-L638">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_inv"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_inv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_trans"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L642-L643">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_trans"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceObjWhiskeringLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L645-L646">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringLeft"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskeringLeft">whiskeringLeft</a> <span class="fn">C</span> <span class="fn">D</span> <span class="fn">E</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.instIsEquivalenceObjWhiskeringRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L648-L649">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.instIsEquivalenceObjWhiskeringRight"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">instIsEquivalenceObjWhiskeringRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.whiskeringRight">whiskeringRight</a> <span class="fn">E</span> <span class="fn">C</span> <span class="fn">D</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">F</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.fun_inv_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L656-L659">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.fun_inv_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">fun_inv_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counit">counit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitInv">counitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.inv_fun_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L661-L664">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv_fun_map"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">inv_fun_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">f</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitInv">unitInv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">asEquivalence</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unit">unit</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">Y</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L666-L667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_iff_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L669-L671">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_iff_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_iff_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F </span><span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_of_comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L673-L677">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_of_comp_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div><p>If <code>G</code> and <code>F ⋙ G</code> are equivalence of categories, then <code>F</code> is also an equivalence.</p></div></div><div class="decl" id="CategoryTheory.Functor.isEquivalence_of_comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L679-L684">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.isEquivalence_of_comp_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">isEquivalence_of_comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{u_2, u_1}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">G</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div><p>If <code>F</code> and <code>F ⋙ G</code> are equivalence of categories, then <code>G</code> is also an equivalence.</p></div></div><div class="decl" id="CategoryTheory.Equivalence.essSurjInducedFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L690-L691">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.essSurjInducedFunctor"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">essSurjInducedFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C'</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C'</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.inducedFunctor">inducedFunctor</a> <span class="fn">⇑<span class="fn">e</span></span>)</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.EssSurj">EssSurj</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.inducedFunctorOfEquiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L693-L694">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inducedFunctorOfEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">inducedFunctorOfEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C'</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">C'</span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/InducedCategory.html#CategoryTheory.inducedFunctor">inducedFunctor</a> <span class="fn">⇑<span class="fn">e</span></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.fullyFaithfulToEssImage"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L696-L697">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.fullyFaithfulToEssImage"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">fullyFaithfulToEssImage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Full">Full</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Functor.Faithful">Faithful</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.Functor.toEssImage">toEssImage</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.IsEquivalence">IsEquivalence</a></span></div></div></div></div><div class="decl" id="CategoryTheory.ObjectProperty.fullSubcategoryCongr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L701-L709">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">P'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/Basic.html#CategoryTheory.ObjectProperty">ObjectProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">P'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span>.<a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory">FullSubcategory</a></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><span class="fn">P'</span>.<a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory">FullSubcategory</a></span></div></div><p>An equality of properties of objects of a category <code>C</code> induces an equivalence of the
respective induced full subcategories of <code>C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ObjectProperty.fullSubcategoryCongr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ObjectProperty.fullSubcategoryCongr_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L703-L703">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr_functor"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">P'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/Basic.html#CategoryTheory.ObjectProperty">ObjectProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">P'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr">fullSubcategoryCongr</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ιOfLE">ιOfLE</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ObjectProperty.fullSubcategoryCongr_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L703-L703">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr_unitIso"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">P'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/Basic.html#CategoryTheory.ObjectProperty">ObjectProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">P'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr">fullSubcategoryCongr</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">Functor.id</a> <span class="fn"><span class="fn">P</span>.<a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory">FullSubcategory</a></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ObjectProperty.fullSubcategoryCongr_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L703-L703">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr_counitIso"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">P'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/Basic.html#CategoryTheory.ObjectProperty">ObjectProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">P'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr">fullSubcategoryCongr</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">Iso.refl</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ιOfLE">ιOfLE</a> <span class="fn">⋯</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ιOfLE">ιOfLE</a> <span class="fn">⋯</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ObjectProperty.fullSubcategoryCongr_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L703-L703">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr_inverse"><span class="name">CategoryTheory</span>.<span class="name">ObjectProperty</span>.<span class="name">fullSubcategoryCongr_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">P'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/Basic.html#CategoryTheory.ObjectProperty">ObjectProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">P'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr">fullSubcategoryCongr</a> <span class="fn">h</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ιOfLE">ιOfLE</a> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Equivalence.ofFullSubcategory"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L711-L712">source</a></div><div class="attributes">@[deprecated CategoryTheory.ObjectProperty.fullSubcategoryCongr (since := &quot;2025-03-04&quot;)]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">ofFullSubcategory</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P </span><span class="fn">P'</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/ObjectProperty/Basic.html#CategoryTheory.ObjectProperty">ObjectProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">P</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">P'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">P</span>.<a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory">FullSubcategory</a></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><span class="fn">P'</span>.<a href="../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory">FullSubcategory</a></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr">CategoryTheory.ObjectProperty.fullSubcategoryCongr</a></code>.</p><hr></hr><p>An equality of properties of objects of a category <code>C</code> induces an equivalence of the
respective induced full subcategories of <code>C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullSubcategory">CategoryTheory.Equivalence.ofFullSubcategory</a> <a href="../.././Init/Prelude.html#Eq">=</a> @<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.ObjectProperty.fullSubcategoryCongr">CategoryTheory.ObjectProperty.fullSubcategoryCongr</a></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.ofFullSubcategory" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L718-L722">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">G</span></div></div><p>Construct an isomorphism <code>F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ≅ G</code> from an isomorphism <code>F ≅ G ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">compInverseIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">CategoryTheory.Functor.isoWhiskerRight</a> <span class="fn">i</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.compInverseIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L719-L719">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">compInverseIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.compInverseIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L719-L719">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">compInverseIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.compInverseIso">compInverseIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L724-L728">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">G</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn">F</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></div></div><p>Construct an isomorphism <code>G ≅ F ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> from an isomorphism <code>G ⋙ H.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.rightUnitor">rightUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">CategoryTheory.Functor.isoWhiskerRight</a> <span class="fn">i</span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoCompInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L725-L725">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoCompInverse_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L725-L725">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoCompInverse_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn">D</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">E</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L730-L734">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">H</span></div></div><p>Construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ F ≅ H</code> from an isomorphism <code>F ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">inverseCompIso</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn">i</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">H</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">CategoryTheory.Functor.isoWhiskerRight</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.inverseCompIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L731-L731">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">inverseCompIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.inverseCompIso_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L731-L731">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">inverseCompIso_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn">F</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.inverseCompIso">inverseCompIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L736-L740">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">H</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">F</span></span></div></div><p>Construct an isomorphism <code>H ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ⋙ F</code> from an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ⋙ H ≅ F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">isoInverseComp</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>     <span class="fn"><a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerRight">CategoryTheory.Functor.isoWhiskerRight</a> <span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a>       <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.associator">associator</a></span> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn">i</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoInverseComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L737-L737">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">isoInverseComp</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseComp_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L737-L737">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseComp_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₃, u₃}</a> <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">H</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseComp">isoInverseComp</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">H</span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L742-L746">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span></div></div><p>As a special case, given two equivalences <code>G</code> and <code>G'</code> between the same categories,
construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code> from an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Whiskering.html#CategoryTheory.Functor.isoWhiskerLeft">isoWhiskerLeft</a></span> <span class="fn">i</span>)</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.symm">symm</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>).<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoCompInverse">isoCompInverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.trans">≪≫</a> <span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Category.html#CategoryTheory.Functor.leftUnitor">leftUnitor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoInverseOfIsoFunctor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L744-L744">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L744-L744">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L748-L752">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span></div></div><p>As a special case, given two equivalences <code>G</code> and <code>G'</code> between the same categories,
construct an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></code> from an isomorphism <code>G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a> ≅ G.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.Iso.isoFunctorOfIsoInverse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse_hom_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L750-L750">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse_hom_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_hom_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse_inv_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L750-L750">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse_inv_app"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_inv_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.unitIso">unitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">X</span>)</span>)</span>
    <span class="fn">(<a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.counitIso">counitIso</a></span>.<a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.hom">hom</a></span>.<a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app">app</a></span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>.<a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">X</span>)</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Iso.isoFunctorOfIsoInverse_isoInverseOfIsoFunctor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L754-L759">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse_isoInverseOfIsoFunctor"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoFunctorOfIsoInverse_isoInverseOfIsoFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.functor">functor</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></div></div><p>Sanity check: <code><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a> (isoInverseOfIsoFunctor i)</code> is just <code>i</code>.</p></div></div><div class="decl" id="CategoryTheory.Iso.isoInverseOfIsoFunctor_isoFunctorOfIsoInverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Equivalence.lean#L761-L764">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor_isoFunctorOfIsoInverse"><span class="name">CategoryTheory</span>.<span class="name">Iso</span>.<span class="name">isoInverseOfIsoFunctor_isoFunctorOfIsoInverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">G </span><span class="fn">G'</span> : <span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><span class="fn">G</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">G'</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.inverse">inverse</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">i</span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoFunctorOfIsoInverse">isoFunctorOfIsoInverse</a></span>.<a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Iso.isoInverseOfIsoFunctor">isoInverseOfIsoFunctor</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Filtered.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Filtered.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Filtered</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html">Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Filtered.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_hasFiniteColimits"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasFiniteColimits</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_hasTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.iff_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnit</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">bowtie</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasFiniteLimits</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_hasInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.iff_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULift</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredForall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyProd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredProd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyProd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredProd</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Filtered-categories">Filtered categories <a class="hover-link" href="#Filtered-categories">#</a></h1><p>A category is filtered if every finite diagram admits a cocone.
We give a simple characterisation of this condition as</p><ol>
<li>for every pair of objects there exists another object &quot;to the right&quot;,</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>Filtered colimits are often better behaved than arbitrary colimits.
See <code>CategoryTheory/Limits/Types</code> for some details.</p><p>Filtered categories are nice because colimits indexed by filtered categories tend to be
easier to describe than general colimits (and more often preserved by functors).</p><p>In this file we show that any functor from a finite category to a filtered category admits a cocone:</p><ul>
<li><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a> [FinCategory J] [IsFiltered C] (F : J ⥤ C) : <a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> (Cocone F)</code>
More generally,
for any finite collection of objects and morphisms between them in a filtered category
(even if not closed under composition) there exists some object <code>Z</code> receiving maps from all of them,
so that all the triangles (one edge from the finite set, two from morphisms to <code>Z</code>) commute.
This formulation is often more useful in practice and is available via <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists">sup_exists</a></code>,
which takes a finset of objects, and an indexed family (indexed by source and target)
of finsets of morphisms.</li>
</ul><p>We also prove the converse of <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a></code> as <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_cocone_nonempty">of_cocone_nonempty</a></code>.</p><p>Furthermore, we give special support for two diagram categories: The <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>.
This is because these shapes show up in the proofs that forgetful functors of algebraic categories
(e.g. <code>MonCat</code>, <code>CommRingCat</code>, ...) preserve filtered colimits.</p><p>All of the above API, except for the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>, is also provided for cofiltered
categories.</p><h2 class="markdown-heading" id="See-also">See also <a class="hover-link" href="#See-also">#</a></h2><p>In <code>CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit</code> we show that filtered colimits
commute with finite limits.</p><p>There is another characterization of filtered categories, namely that whenever <code>F : J ⥤ C</code> is a
functor from a finite category, there is <code>X : C</code> such that <code><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> (limit (F.op ⋙ yoneda.obj X))</code>.
This is shown in <code>CategoryTheory.Limits.Filtered</code>.</p></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L65-L75">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the right&quot;, and</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsFilteredOrEmpty.mk"><li id="CategoryTheory.IsFilteredOrEmpty.cocone_objs" class="structure_field"><div class="structure_field_info">cocone_objs<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>) (<span class="fn">x</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>), <a href="../../.././Init/Prelude.html#True">True</a></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object &quot;to the right&quot;</p></div></li><li id="CategoryTheory.IsFilteredOrEmpty.cocone_maps" class="structure_field"><div class="structure_field_info">cocone_maps<span class="impl_arg"><span class="decl_args">
<span class="fn">⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the right
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L77-L86">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the right&quot;,</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsFiltered.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.cocone_objs">cocone_objs</a><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>) (<span class="fn">x</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>), <a href="../../.././Init/Prelude.html#True">True</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.cocone_maps">cocone_maps</a><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">Z</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></div></li><li id="CategoryTheory.IsFiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a filtered category must be non-empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L88-L91">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L93-L94">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_directed_le"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L96-L101">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isFiltered_of_directed_le_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L103-L104">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredDiscretePUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L111-L113">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Discrete/Basic.html#CategoryTheory.Discrete">Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L122-L126">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code> is an arbitrary choice of object to the right of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.max" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.leftToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L128-L132">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> <span class="fn">j</span> <span class="fn">j'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax">leftToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax">CategoryTheory.IsFiltered.leftToMax</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.leftToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.rightToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L134-L138">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> <span class="fn">j</span> <span class="fn">j'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">rightToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j'</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.rightToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L140-L146">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L148-L154">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L156-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code>f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L159-L159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L174-L183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L185-L188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">R</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L190-L192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being filtered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L205-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>), <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span></span></span></div></div><p>Any finite collection of objects in a filtered category has an object &quot;to the right&quot;.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L221-L254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>) (<span class="fn">T</span> : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} → <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span> → (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span>)</span></span>),
  <span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) (<span class="fn">mY</span> : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) {<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>}, <span class="fn"><a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">X</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">Y</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mX</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mY</span>, <span class="fn">f</span><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn">T</span> <span class="fn">mY</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">mX</span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : X ⟶ S</code> from each <code>X</code>,
such that the triangles commute: <code>f ≫ T Y = T X</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L256-L261">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object &quot;to the right&quot;
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">CategoryTheory.IsFiltered.sup</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.sup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L263-L266">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> <span class="fn">O</span> <span class="fn">H</span></span></div></div><p>The morphisms to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.toSup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L268-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mX</span> : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mY</span> : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mf</span> : <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">X</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">Y</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mX</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mY</span>, <span class="fn">f</span><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span></div></div><p>The triangles of consisting of a morphism in <code>H</code> and the maps to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L277-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cocone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L297-L300">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cocone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone">CategoryTheory.IsFiltered.cocone</a> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Mathlib/Logic/Nonempty.html#Nonempty.some">some</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.cocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L304-L308">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L310-L312">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">R</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L314-L316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span></div></div><p>Being filtered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L324-L342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_cocone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div><p>If every finite diagram in <code>C</code> admits a cocone, then <code>C</code> is filtered. It is sufficient to verify
this for diagrams whose shape lives in any one fixed universe.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_hasFiniteColimits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L344-L345">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_hasFiniteColimits"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasFiniteColimits</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html#CategoryTheory.Limits.HasFiniteColimits">Limits.HasFiniteColimits</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isTerminal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L347-L348">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_isTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isTerminal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsTerminal">Limits.IsTerminal</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_hasTerminal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L350-L351">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_hasTerminal"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_hasTerminal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.HasTerminal">Limits.HasTerminal</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.iff_cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L353-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.iff_cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">iff_cocone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">Limits.Cocone</a> <span class="fn">F</span>)</span></span></span></div></div><p>For every universe <code>w</code>, <code>C</code> is filtered if and only if every finite diagram in <code>C</code> with shape
in <code>w</code> admits a cocone.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.max₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L366-L370">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j₁ </span><span class="fn">j₂ </span><span class="fn">j₃</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code> is an arbitrary choice of object to the right of <code>j₁</code>, <code>j₂</code> and <code>j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span>)</span> <span class="fn">j₃</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.max₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.firstToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L372-L376">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j₁ </span><span class="fn">j₂ </span><span class="fn">j₃</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax₃">firstToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₁</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.firstToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.secondToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L378-L382">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j₁ </span><span class="fn">j₂ </span><span class="fn">j₃</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax₃">secondToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₂</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.secondToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.thirdToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L384-L388">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j₁ </span><span class="fn">j₂ </span><span class="fn">j₃</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃">thirdToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₃</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃">CategoryTheory.IsFiltered.thirdToMax₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span>)</span> <span class="fn">j₃</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.thirdToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L390-L397">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h : j₂ ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code> are satisfied.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃Hom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L399-L407">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of morphism
<code>j₂ ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code>
are satisfied. Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq₃Hom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L409-L411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L413-L419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L421-L422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g </span><span class="fn">h</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.span"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L424-L430">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">g</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k</span>) (<span class="fn">g'</span> : <span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></span></div></div><p>For every span <code>j ⟵ i ⟶ j'</code>, there exists a cocone <code>j ⟶ k ⟵ j'</code> such that the square
commutes.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.bowtie"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L432-L450">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂ </span><span class="fn">k₁ </span><span class="fn">k₂</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f₁</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₁</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₂</span> : <span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₂</span> : <span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">α</span> : <span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span>) (<span class="fn">β</span> : <span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span>),
  <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f₁</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f₂</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">β</span></span></span></div></div><p>Given a &quot;bowtie&quot; of morphisms</p><pre><code> j₁   j₂
 |\  /|
 | \/ |
 | /\ |
 |/  \∣
 vv  vv
 k₁  k₂
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and two morphisms from <code>k₁</code> and <code>k₂</code> to <code>s</code>,
making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.tulip"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L452-L476">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂ </span><span class="fn">j₃ </span><span class="fn">k₁ </span><span class="fn">k₂ </span><span class="fn">l</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f₁</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₂</span> : <span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₃</span> : <span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₄</span> : <span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₁</span> : <span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₂</span> : <span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">α</span> : <span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span>) (<span class="fn">β</span> : <span class="fn">l</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span>) (<span class="fn">γ</span> : <span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span>),
  <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f₁</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f₂</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f₃</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f₄</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">β</span></span></span></div></div><p>Given a &quot;tulip&quot; of morphisms</p><pre><code> j₁    j₂    j₃
 |\   / \   / |
 | \ /   \ /  |
 |  vv    vv  |
 \  k₁    k₂ /
  \         /
   \       /
    \     /
     \   /
      v v
       l
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and three morphisms from <code>k₁</code>, <code>k₂</code> and <code>l</code>
to <code>s</code>, making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L482-L493">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the left&quot;, and</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsCofilteredOrEmpty.mk"><li id="CategoryTheory.IsCofilteredOrEmpty.cone_objs" class="structure_field"><div class="structure_field_info">cone_objs<span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <a href="../../.././Init/Prelude.html#True">True</a></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object &quot;to the left&quot;</p></div></li><li id="CategoryTheory.IsCofilteredOrEmpty.cone_maps" class="structure_field"><div class="structure_field_info">cone_maps<span class="impl_arg"><span class="decl_args">
<span class="fn">⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the left
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L495-L504">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object &quot;to the left&quot;,</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsCofiltered.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.cone_objs">cone_objs</a><span class="decl_args">
<span class="fn">(<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>) (<span class="fn">x</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <a href="../../.././Init/Prelude.html#True">True</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.cone_maps">cone_maps</a><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">W</span> : <span class="fn">C</span>) (<span class="fn">h</span> : <span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></div></li><li id="CategoryTheory.IsCofiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a cofiltered category must be non-empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L506-L511">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L513-L514">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L516-L523">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_directed_ge_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L525-L526">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredDiscretePUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L533-L537">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredDiscretePUnit"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Discrete/Basic.html#CategoryTheory.Discrete">Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.min"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L546-L550">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> is an arbitrary choice of object to the left of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.min" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L552-L556">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft">minToLeft</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft">CategoryTheory.IsCofiltered.minToLeft</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.minToLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L558-L562">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight">minToRight</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight">CategoryTheory.IsCofiltered.minToRight</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.minToRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L564-L570">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">CategoryTheory.IsCofiltered.eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L572-L578">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.eqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L580-L585">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">f'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L583-L583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> <span class="fn">f</span> <span class="fn">f'</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cospan"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L587-L593">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j </span><span class="fn">j'</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f'</span> : <span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">k</span> : <span class="fn">C</span>) (<span class="fn">g</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span>) (<span class="fn">g'</span> : <span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">f'</span></span></span></div></div><p>For every cospan <code>j ⟶ i ⟵ j'</code>,
there exists a cone <code>j ⟵ k ⟶ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.Functor.ranges_directed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L595-L598">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <a href="../../.././foundational_types.html">(Type</a> u_1)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#Superset">⊇</a> <span class="fn">x2</span>)</span> <span class="fn">fun (<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">C</span>) ×' (<span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span>)</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn"><span class="fn">f</span>.<a href="../../.././Init/Core.html#PSigma.snd">snd</a></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.bowtie"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L600-L618">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">bowtie</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j₁ </span><span class="fn">j₂ </span><span class="fn">k₁ </span><span class="fn">k₂</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f₁</span> : <span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₁</span> : <span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₂</span> : <span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₂</span> : <span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">s</span> : <span class="fn">C</span>) (<span class="fn">α</span> : <span class="fn">s</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span>) (<span class="fn">β</span> : <span class="fn">s</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span>),
  <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">f₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">β</span> <span class="fn">g₁</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">α</span> <span class="fn">f₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">β</span> <span class="fn">g₂</span></span></span></div></div><p>Given a &quot;bowtie&quot; of morphisms</p><pre><code> k₁   k₂
 |\  /|
 | \/ |
 | /\ |
 |/  \∣
 vv  vv
 j₁  j₂
</code></pre><p>in a cofiltered category, we can construct an object <code>s</code> and two morphisms
from <code>s</code> to <code>k₁</code> and <code>k₂</code>, making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L631-L640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L642-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">L</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsLeftAdjoint">IsLeftAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is
cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L647-L649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being cofiltered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L662-L674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>), <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span></span></span></div></div><p>Any finite collection of objects in a cofiltered category has an object &quot;to the left&quot;.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L678-L711">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">S</span> : <span class="fn">C</span>) (<span class="fn">T</span> : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} → <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span> → (<span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span>)</span></span>),
  <span class="fn">∀ {<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) (<span class="fn">mY</span> : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) {<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>}, <span class="fn"><a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">X</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">Y</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mX</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mY</span>, <span class="fn">f</span><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn">T</span> <span class="fn">mX</span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">mY</span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : S ⟶ X</code> from each <code>X</code>,
such that the triangles commute: <code>T X ≫ f = T Y</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L713-L718">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object &quot;to the left&quot;
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">CategoryTheory.IsCofiltered.inf</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.inf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L720-L723">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></div></div><p>The morphisms from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">⋯</span>.<a href="../../.././Init/Classical.html#Exists.choose">choose</a></span> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.infTo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L725-L730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">O</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">((<span class="fn">X</span> : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn">Y</span> : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' <span class="fn">(_ : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>) ×' (<span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mX</span> : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mY</span> : <span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mf</span> : <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">X</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">Y</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mX</span>, <a href="../../.././Init/Core.html#PSigma.mk">⟨</a><span class="fn">mY</span>, <span class="fn">f</span><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a><a href="../../.././Init/Core.html#PSigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span></div></div><p>The triangles consisting of a morphism in <code>H</code> and the maps from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L734-L753">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L755-L758">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone">CategoryTheory.IsCofiltered.cone</a> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Mathlib/Logic/Nonempty.html#Nonempty.some">some</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.cone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L762-L767">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L769-L771">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">L</span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsLeftAdjoint">IsLeftAdjoint</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L773-L775">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span></div></div><p>Being cofiltered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L784-L802">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_cone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If every finite diagram in <code>C</code> admits a cone, then <code>C</code> is cofiltered. It is sufficient to
verify this for diagrams whose shape lives in any one fixed universe.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_hasFiniteLimits"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L804-L805">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_hasFiniteLimits"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasFiniteLimits</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.html#CategoryTheory.Limits.HasFiniteLimits">Limits.HasFiniteLimits</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isInitial"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L807-L808">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_isInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isInitial</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/IsTerminal.html#CategoryTheory.Limits.IsInitial">Limits.IsInitial</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_hasInitial"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L810-L811">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_hasInitial"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_hasInitial</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.HasInitial">Limits.HasInitial</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.iff_cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L813-L817">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.iff_cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">iff_cone_nonempty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> w} [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">SmallCategory</a> <span class="fn">J</span></span>] [<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory/Basic.html#CategoryTheory.FinCategory">FinCategory</a> <span class="fn">J</span></span>] (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>), <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">Limits.Cone</a> <span class="fn">F</span>)</span></span></span></div></div><p>For every universe <code>w</code>, <code>C</code> is filtered if and only if every finite diagram in <code>C</code> with shape
in <code>w</code> admits a cocone.</p></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L827-L836">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofiltered_op_of_isFiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L838-L839">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L841-L850">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isFiltered_op_of_isCofiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L852-L853">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></div></div></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L855-L857">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered or empty, then C is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L859-L861">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered or empty, then C is filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_isFiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L863-L865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered, then C is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.isFiltered_of_isCofiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L867-L869">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered, then C is filtered.</p></div></div><div class="decl" id="CategoryTheory.instIsFilteredULift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L875-L876">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L878-L879">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULift"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredULiftHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L881-L882">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">ULiftHom</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULiftHom"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L884-L885">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULiftHom"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">ULiftHom</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L887-L888">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">AsSmall</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L890-L891">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">AsSmall</a> <span class="fn">C</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredOrEmptyForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L900-L904">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> u₁</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">i</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L907-L907">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> u₁</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">i</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredOrEmptyForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L910-L914">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredOrEmptyForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> u₁</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">i</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredForall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L917-L917">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredForall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredForall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Type</a> u₁</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">i</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">(<span class="fn">I</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">I</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredOrEmptyProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L926-L930">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredOrEmptyProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a> (<span class="fn">C</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">D</span>)</span></div></div></div></div><div class="decl" id="CategoryTheory.instIsFilteredProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L933-L933">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> (<span class="fn">C</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">D</span>)</span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredOrEmptyProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L936-L940">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredOrEmptyProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredOrEmptyProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a> (<span class="fn">C</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">D</span>)</span></div></div></div></div><div class="decl" id="CategoryTheory.instIsCofilteredProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/CategoryTheory/Filtered/Basic.lean#L943-L943">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredProd"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₁, u₁}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">D</span> : <a href="../../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v₂, u₂}</a> <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> (<span class="fn">C</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">D</span>)</span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
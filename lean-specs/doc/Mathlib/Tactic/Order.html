<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Order</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Order";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/ByContra.html">Mathlib.Tactic.ByContra</a></li><li><a href="../.././Mathlib/Util/ElabWithoutMVars.html">Mathlib.Util.ElabWithoutMVars</a></li><li><a href="../.././Mathlib/Tactic/Order/CollectFacts.html">Mathlib.Tactic.Order.CollectFacts</a></li><li><a href="../.././Mathlib/Tactic/Order/Preprocessing.html">Mathlib.Tactic.Order.Preprocessing</a></li><li><a href="../.././Mathlib/Tactic/Order/Graph/Basic.html">Mathlib.Tactic.Order.Graph.Basic</a></li><li><a href="../.././Mathlib/Tactic/Order/Graph/Tarjan.html">Mathlib.Tactic.Order.Graph.Tarjan</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Order" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.findContradictionWithNe"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">findContradictionWithNe</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.findContradictionWithNle"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">findContradictionWithNle</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.updateGraphWithNltInfSup"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">updateGraphWithNltInfSup</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.OrderType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">OrderType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.instBEqOrderType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instBEqOrderType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.instBEqOrderType.beq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instBEqOrderType</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.instToStringOrderType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instToStringOrderType</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.findBestOrderInstance"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">findBestOrderInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instOrdProdNatExpr_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.orderCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">orderCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.orderArgs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">orderArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.order_core"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">order_core</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Order.tacticOrder_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">tacticOrder_</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="order-tactic"><code>order</code> tactic <a class="hover-link" href="#order-tactic">#</a></h1><p>This module defines the <code>order</code> tactic, a decision procedure for the theories of <code><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a></code>,
<code><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a></code>, <code><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a></code>, and <code><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a></code>. It also supports <code>⊤</code> and <code>⊥</code>.</p><h2 class="markdown-heading" id="Implementation-Details">Implementation Details <a class="hover-link" href="#Implementation-Details">#</a></h2><p>Below, we describe the algorithm for each type of order. All algorithms begin with two steps:</p><ol>
<li>Negate the goal so that our goal now is to derive <code><a href="../.././Init/Prelude.html#False">False</a></code>.</li>
<li>Collect the set of <em>facts</em>, i.e., atomic expressions in one of six forms: <code>x = y</code>, <code>x ≠ y</code>,
<code>x ≤ y</code>, <code>¬(x ≤ y)</code>, <code>x &lt; y</code>, and <code>¬(x &lt; y)</code>. We then attempt to derive a contradiction from this
set of facts.</li>
</ol><h3 class="markdown-heading" id="Preorder">Preorder <a class="hover-link" href="#Preorder">#</a></h3><ol start="3">
<li><strong>Preprocessing</strong>.
We replace some facts as follows:</li>
</ol><ul>
<li>Replace <code>x &lt; y</code> with two equivalent facts: <code>x ≤ y</code> and <code>¬(y ≤ x)</code>.</li>
<li>Replace <code>x = y</code> with <code>x ≤ y</code> and <code>y ≤ x</code>.</li>
<li>Remove <code>x ≠ y</code>.
Note that the last two operations weaken the set of facts.</li>
</ul><ol start="4">
<li><strong>Building the <code>≤</code>-graph</strong>.
We construct a graph where vertices correspond to atoms, and an edge <code>(x, y)</code> exists if the fact
<code>x ≤ y</code> is present in our set of facts. We call this graph a <code>≤</code>-graph.</li>
<li><strong>Growing the <code>≤</code>-graph with <code>≮</code>-facts</strong>.
In preorders, <code>¬(x &lt; y)</code> is equivalent to <code>(x ≤ y) → (y ≤ x)</code>. Thus, if <code>y</code> is reachable from <code>x</code>
in the <code>≤</code>-graph, we can derive the new fact <code>y ≤ x</code>. At this step, we add such edges to the graph
while possible.</li>
<li><strong>Finding contradictions using <code>≰</code>-facts</strong>.
For each fact <code>¬(x ≤ y)</code>, we check if <code>y</code> is reachable from <code>x</code> in the <code>≤</code>-graph. If so, we derive
the desired contradiction.</li>
</ol><h4 class="markdown-heading" id="Why-is-this-a-decision-procedure">Why is this a decision procedure? <a class="hover-link" href="#Why-is-this-a-decision-procedure">#</a></h4><p>Technically, it is not, because it cannot prove <code>(x = y) → (y ≠ z) → (x ≠ z)</code>. Goals involving
only <code>=</code> and <code>≠</code> can be handled by the <code>cc</code> tactic. Assume, then, that a set <code>T</code> of facts is
contradictory, but there is no chain <code>x₁ = x₂ = ... = xₖ</code> in <code>T</code> along with the fact <code>x₁ ≠ xₖ</code>. Then
we claim that the described algorithm is able to deduce a contradiction from <code>T</code>. Let <code>T'</code> be the
set of facts after preprocessing. Then <code>T'</code> remains contradictory.</p><p>Indeed, suppose that <code>T'</code> is satisfiable, i.e., there exists a model <code>M</code> that satisfies <code>T'</code>.
Consider a quotient <code>M'</code> of <code>M</code> by the equivalence relation <code>~</code>, where <code>a ~ b</code> holds for <code>a ≠ b</code> iff
both <code>a</code> and <code>b</code> are values of some variables <code>x</code> and <code>y</code> from <code>T</code>, and there is
a chain <code>x = ... = y</code> in <code>T</code>. Define the relation <code>R'</code> on <code>M'</code> as <code>α R' β</code> if and only if <code>a R b</code>
in <code>M</code> for some <code>a ∈ α</code> and <code>b ∈ β</code>. Then <code>M'</code> is a model satisfying <code>T</code>:</p><ul>
<li>For any fact <code>x = y</code> in <code>T</code>, we have <code>M'(x) = M'(y)</code> in <code>M'</code>.</li>
<li>For any fact <code>x ≠ y</code> in <code>T</code>, we have <code>M'(x) ≠ M'(y)</code>, since otherwise, there would exist
a chain <code>x = ... = y</code> in <code>T</code>.</li>
<li>For any fact <code>x ≤ y</code> in <code>T</code>, and thus in <code>T'</code>, we have <code>M(x) R M(y)</code>, so <code>M'(x) R' M'(y)</code>.</li>
<li>For any fact <code>¬(x ≤ y)</code> in <code>T</code>, and thus in <code>T'</code>, we have <code>¬M(x) R M(y)</code>. Then, for any <code>x' ~ x</code>
and <code>y' ~ y</code>, we can deduce <code>x ≤ x'</code> and <code>y' ≤ y</code> from <code>T'</code>. If <code>M(x') R M(y')</code>, then
<code>M(x) R M(x') R M(y') R M(y)</code>, which contradicts the assumption that <code>M</code> is a model of <code>T'</code>.
This contradiction implies that <code>¬M'(x) R' M'(y)</code>, as required.</li>
</ul><p>If, at step 6, no contradictory <code>≰</code>-facts were found, we must show that a model satisfies <code>T'</code>.
A suitable model can be constructed using the connected components of the <code>=</code>-graph (defined
similarly to the <code>≤</code>-graph),
with the relation <code>R</code> defined as <code>C₁ R C₂</code> iff <code>C₂</code> is reachable from <code>C₁</code> in the <code>≤</code>-graph. Each
variable <code>x</code> is interpreted as its component <code>[x]</code>. This forms a preorder, and we verify that each
fact in <code>T'</code> is satisfied:</p><ul>
<li><code>x = y</code> is satisfied because <code>x</code> and <code>y</code> must be in the same component in the <code>=</code>-graph.</li>
<li><code>x ≤ y</code> is satisfied by the construction of the <code>≤</code>-graph.</li>
<li><code>x ≠ y</code> is satisfied because otherwise, <code>x</code> and <code>y</code> would belong to the same component in
the <code>=</code>-graph, contradicting our initial assumption.</li>
<li><code>¬(x &lt; y)</code> is satisfied because otherwise <code>¬[y] R [x]</code>, meaning there is a path from <code>x</code> to <code>y</code>,
which would have caused an edge <code>(y, x)</code> to be added at step 5, leading to a contradiction.</li>
</ul><h3 class="markdown-heading" id="Partial-Order">Partial Order <a class="hover-link" href="#Partial-Order">#</a></h3><ol start="3">
<li><strong>Preprocessing</strong>.
We replace some facts as follows:</li>
</ol><ul>
<li>Replace <code>x &lt; y</code> with <code>x ≤ y</code> and <code>x ≠ y</code>.</li>
<li>Replace <code>x = y</code> with <code>x ≤ y</code> and <code>y ≤ x</code>.</li>
<li>Replace <code>¬(x ≤ y)</code> with <code>x ≠ y</code> and <code>¬(x &lt; y)</code>.</li>
</ul><ol start="4">
<li><strong>Building the <code>≤</code>-graph</strong>: Same as for preorders.</li>
<li><strong>Growing the <code>≤</code>-graph with <code>≮</code>-facts</strong>: Same as for preorders.</li>
<li><strong>Finding contradictions using <code>≠</code>-facts</strong>.
We identify strongly connected components in the <code>≤</code>-graph using a standard algorithm. For each
fact <code>x ≠ y</code>, we check whether <code>x</code> and <code>y</code> belong to the same component. If they do, then <code>x = y</code> is
provable, contradicting <code>x ≠ y</code>.</li>
</ol><h4 class="markdown-heading" id="Why-is-this-a-decision-procedure">Why is this a decision procedure? <a class="hover-link" href="#Why-is-this-a-decision-procedure">#</a></h4><p>Assume that a set <code>T</code> of facts is contradictory. We must show that the described algorithm can
derive a contradiction. Let <code>T'</code> be the set of facts after preprocessing. By construction, <code>T'</code> is
also contradictory (they are equisatisfiable). If, at step 6, no contradictory <code>≠</code>-facts were found,
we must show that a model satisfies <code>T'</code>. A suitable model consists of the strongly connected
components of the <code>≤</code>-graph, with the relation <code>R</code> defined as <code>C₁ R C₂</code> iff <code>C₂</code> is reachable
from <code>C₁</code>. Each variable <code>x</code> is interpreted as its component <code>[x]</code>. This forms a partial order, and
we verify that each fact in <code>T'</code> is satisfied:</p><ul>
<li><code>x ≤ y</code> is satisfied because it directly implies <code>[x] R [y]</code>.</li>
<li><code>x ≠ y</code> is satisfied because otherwise, <code>x</code> and <code>y</code> would belong to the same component, leading to
a contradiction at step 6.</li>
<li><code>¬(x &lt; y)</code> is satisfied because otherwise <code>[x] ≠ [y]</code> and there is a path from <code>x</code> to <code>y</code>, which
would have merged them into the same component at step 5.</li>
</ul><h3 class="markdown-heading" id="Linear-Order">Linear Order <a class="hover-link" href="#Linear-Order">#</a></h3><ol start="3">
<li><strong>Preprocessing</strong>.
We replace some facts as follows:</li>
</ol><ul>
<li>Replace <code>x &lt; y</code> with <code>x ≤ y</code> and <code>x ≠ y</code>.</li>
<li>Replace <code>x = y</code> with <code>x ≤ y</code> and <code>y ≤ x</code>.</li>
<li>Replace <code>¬(x ≤ y)</code> with <code>x ≠ y</code> and <code>y ≤ x</code>.</li>
<li>Replace <code>¬(x &lt; y)</code> with <code>y ≤ x</code>.</li>
</ul><ol start="4">
<li><strong>Building the <code>≤</code>-graph</strong>: Same as for preorders.</li>
<li><strong>Finding contradictions using <code>≠</code>-facts</strong>: Same as for partial orders.</li>
</ol><p>Note that the algorithm for linear orders is simply the algorithm for partial orders with an
additional preprocessing step. It also skips the growing step because there is no <code>≮</code>-facts.</p><h4 class="markdown-heading" id="Why-is-this-a-decision-procedure">Why is this a decision procedure? <a class="hover-link" href="#Why-is-this-a-decision-procedure">#</a></h4><p>We need to slightly modify the proof for partial orders. In this case, <code>T</code> and <code>T'</code> are again
equisatisfiable. Suppose the algorithm cannot find a contradiction, and construct the model of <code>T'</code>.
The carrier of the model is once again the set of strongly connected components in the <code>≤</code>-graph,
with variables interpreted as their respective components. Note that the reachability relation
(used before) on components is acyclic. Therefore, it can be
<a href="https://en.wikipedia.org/wiki/Topological_sorting">topologically ordered</a>, meaning it forms a
linear order where <code>C₁ R C₂</code> whenever <code>C₂</code> is reachable from <code>C₁</code>. It is easy to see that all facts
in <code>T'</code> are satisfied by the model.</p><h3 class="markdown-heading" id="Lattice">Lattice <a class="hover-link" href="#Lattice">#</a></h3><p>The algorithm for lattices is similar to that for partial orders, with two differences:</p><ol>
<li>During the preprocessing step, we add the facts <code>x ≤ x ⊔ y</code> and <code>y ≤ x ⊔ y</code> if <code>x ⊔ y</code> is present
in the context, and similarly for <code>⊓</code>.</li>
<li>In step 5, we expand the <code>≤</code>-graph using the following procedure: if a vertex <code>v</code> is reachable
from both <code>x</code> and <code>y</code>, and <code>x ⊔ y</code> is present in the set of atoms, we add the edge <code>(x ⊔ y, v)</code>
using <code><a href="../.././Mathlib/Order/Lattice.html#sup_le">sup_le</a></code>, and similarly for <code>⊓</code>.</li>
</ol><p>One can show that this algorithm also serves as a decision procedure for the theory of lattices.</p><h3 class="markdown-heading" id="⊤-and-⊥"><code>⊤</code> and <code>⊥</code> <a class="hover-link" href="#⊤-and-⊥">#</a></h3><p>For <code>⊤</code> and <code>⊥</code>, we add the edges <code>(x, ⊤)</code> and <code>(⊥, x)</code> for all vertices <code>x</code>, using <code><a href="../.././Mathlib/Order/BoundedOrder/Basic.html#le_top">le_top</a></code>
and <code><a href="../.././Mathlib/Order/BoundedOrder/Basic.html#bot_le">bot_le</a></code>, respectively.</p></div><div class="decl" id="Mathlib.Tactic.Order.findContradictionWithNe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L150-L165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNe"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">findContradictionWithNe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">graph</span> : <a href="../.././Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph">Graph</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">idxToAtom</span> : <span class="fn"><a href="../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">facts</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact">AtomicFact</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Finds a contradictory <code>≠</code>-fact whose <code>.lhs</code> and <code>.rhs</code> belong to the same strongly connected
component in the <code>≤</code>-graph, implying they must be equal, and then uses it to derive <code><a href="../.././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.findContradictionWithNe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.findContradictionWithNle"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L167-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNle"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">findContradictionWithNle</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../.././Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph">Graph</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">idxToAtom</span> : <span class="fn"><a href="../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">facts</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact">AtomicFact</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Using the <code>≤</code>-graph <code>g</code>, find a contradiction with some <code>≰</code>-fact.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.findContradictionWithNle" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.updateGraphWithNltInfSup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L176-L217">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.updateGraphWithNltInfSup"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">updateGraphWithNltInfSup</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../.././Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph">Graph</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">idxToAtom</span> : <span class="fn"><a href="../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">facts</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact">AtomicFact</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph">Graph</a></span></div></div><p>Adds edges to the <code>≤</code>-graph using two types of facts:</p><ol>
<li>Each fact <code>¬ (x &lt; y)</code> allows to add the edge <code>(x, y)</code> when <code>y</code> is reachable from <code>x</code> in the
graph.</li>
<li>Each fact <code>x ⊔ y = z</code> allows to add the edge <code>(z, s)</code> when <code>s</code> is reachable from both <code>x</code>
and <code>y</code>.</li>
</ol><p>We repeat the process until no more edges can be added.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.updateGraphWithNltInfSup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.OrderType"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L219-L222">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">OrderType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Supported order types: linear, partial, and preorder.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Order.OrderType.lin">lin : <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a></li><li class="constructor" id="Mathlib.Tactic.Order.OrderType.part">part : <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a></li><li class="constructor" id="Mathlib.Tactic.Order.OrderType.pre">pre : <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a></li></ul><details id="instances-for-list-Mathlib.Tactic.Order.OrderType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.instBEqOrderType"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L222-L222">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instBEqOrderType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType">Mathlib.Tactic.Order.instBEqOrderType</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType.beq">Mathlib.Tactic.Order.instBEqOrderType.beq</a> <a href="../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.instBEqOrderType.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L222-L222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType.beq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instBEqOrderType</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a> → <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a> → <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType.beq">Mathlib.Tactic.Order.instBEqOrderType.beq</a> <span class="fn">x✝</span> <span class="fn">y✝</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">x✝</span>.<a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.ctorIdx">ctorIdx</a></span> <a href="../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">y✝</span>.<a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.ctorIdx">ctorIdx</a></span>)</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.instBEqOrderType.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.instToStringOrderType"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L224-L228">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instToStringOrderType"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instToStringOrderType</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Data/ToString/Basic.html#ToString">ToString</a> <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.findBestOrderInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L230-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findBestOrderInstance"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">findBestOrderInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">type</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType">OrderType</a>)</span></span></div></div><p>Find the &quot;best&quot; instance of an order on a given type. A linear order is preferred over a partial
order, and a partial order is preferred over a preorder.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.findBestOrderInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L241-L243">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">instOrdProdNatExpr_mathlib</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Data/Ord/Basic.html#Ord">Ord</a> (<a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div></div><p>Necessary for tracing below.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib">Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Data/Ord/Basic.html#Ord.mk">{</a> <span class="fn">compare</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) =&gt; <span class="fn"><a href="../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a> <span class="fn"><span class="fn">x</span>.<a href="../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">y</span>.<a href="../.././Init/Prelude.html#Prod.fst">fst</a></span></span></span> <a href="../.././Init/Data/Ord/Basic.html#Ord.mk">}</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.orderCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L245-L274">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">orderCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">only?</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">negGoal</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Core of the <code>order</code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.orderCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.orderArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L276-L277">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.orderArgs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">orderArgs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Args for the <code>order</code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.orderArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.order_core"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L279-L280">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">order_core</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core">order_core</a></code> is the part of the <code>order</code> tactic that tries to find a contradiction.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.order_core" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Order.tacticOrder_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Order.lean#L291-L295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Order</span>.<span class="name">tacticOrder_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A finishing tactic for solving goals in arbitrary <code><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a></code>, <code><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a></code>,
or <code><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a></code>. Supports <code>⊤</code>, <code>⊥</code>, and lattice operations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Order.tacticOrder_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
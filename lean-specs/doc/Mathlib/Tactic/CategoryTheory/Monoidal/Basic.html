<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.CategoryTheory.Monoidal.Basic</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.CategoryTheory.Monoidal.Basic";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">CategoryTheory</span>.<span class="name">Monoidal</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/CategoryTheory/Monoidal/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init.html">Init</a></li><li><a href="../../../.././Mathlib/Tactic/CategoryTheory/Coherence/Basic.html">Mathlib.Tactic.CategoryTheory.Coherence.Basic</a></li><li><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Normalize.html">Mathlib.Tactic.CategoryTheory.Monoidal.Normalize</a></li><li><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/PureCoherence.html">Mathlib.Tactic.CategoryTheory.Monoidal.PureCoherence</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.CategoryTheory.Monoidal.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Monoidal.monoidalNf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">monoidalNf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Monoidal.tacticMonoidal_nf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">tacticMonoidal_nf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Monoidal.monoidal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">monoidal</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Monoidal.tacticMonoidal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">tacticMonoidal</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="monoidal-tactic"><code><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal">monoidal</a></code> tactic <a class="hover-link" href="#monoidal-tactic">#</a></h1><p>This file provides <code><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal">monoidal</a></code> tactic, which solves equations in a monoidal category, where
the two sides only differ by replacing strings of monoidal structural morphisms (that is,
associators, unitors, and identities) with different strings of structural morphisms with the same
source and target. In other words, <code><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal">monoidal</a></code> solves equalities where both sides have the same
string diagrams.</p><p>The core function for the <code><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal">monoidal</a></code> tactic is provided in
<code><a href="../../../.././Mathlib/Tactic/CategoryTheory/Coherence/Basic.html">Mathlib/Tactic/CategoryTheory/Coherence/Basic.lean</a></code>. See this file for more details about the
implementation.</p></div><div class="decl" id="Mathlib.Tactic.Monoidal.monoidalNf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/CategoryTheory/Monoidal/Basic.lean#L30-L32">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidalNf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">monoidalNf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span></div></div><p>Normalize the both sides of an equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidalNf">Mathlib.Tactic.Monoidal.monoidalNf</a> <span class="fn">mvarId</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/Tactic/CategoryTheory/Coherence/Basic.html#Mathlib.Tactic.BicategoryLike.normalForm">Mathlib.Tactic.BicategoryLike.normalForm</a> <a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Datatypes.html#Mathlib.Tactic.Monoidal.Context">Mathlib.Tactic.Monoidal.Context</a> <span class="fn">`monoidal</span> <span class="fn">mvarId</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Monoidal.monoidalNf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Monoidal.tacticMonoidal_nf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/CategoryTheory/Monoidal/Basic.lean#L34-L36">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.tacticMonoidal_nf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">tacticMonoidal_nf</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Normalize the both sides of an equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.tacticMonoidal_nf">Mathlib.Tactic.Monoidal.tacticMonoidal_nf</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Monoidal.tacticMonoidal_nf</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;monoidal_nf&quot;</span> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Monoidal.tacticMonoidal_nf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Monoidal.monoidal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/CategoryTheory/Monoidal/Basic.lean#L38-L49">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">monoidal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span></div></div><p>Use the coherence theorem for monoidal categories to solve equations in a monoidal category,
where the two sides only differ by replacing strings of monoidal structural morphisms
(that is, associators, unitors, and identities)
with different strings of structural morphisms with the same source and target.</p><p>That is, <code><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal">monoidal</a></code> can handle goals of the form
<code>a ≫ f ≫ b ≫ g ≫ c = a' ≫ f ≫ b' ≫ g ≫ c'</code>
where <code>a = a'</code>, <code>b = b'</code>, and <code>c = c'</code> can be proved using <code>monoidal_coherence</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal">Mathlib.Tactic.Monoidal.monoidal</a> <span class="fn">mvarId</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/Tactic/CategoryTheory/Coherence/Basic.html#Mathlib.Tactic.BicategoryLike.main">Mathlib.Tactic.BicategoryLike.main</a> <a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Datatypes.html#Mathlib.Tactic.Monoidal.Context">Mathlib.Tactic.Monoidal.Context</a> <span class="fn">`monoidal</span> <span class="fn">mvarId</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Monoidal.monoidal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Monoidal.tacticMonoidal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/CategoryTheory/Monoidal/Basic.lean#L51-L53">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.tacticMonoidal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Monoidal</span>.<span class="name">tacticMonoidal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Use the coherence theorem for monoidal categories to solve equations in a monoidal category,
where the two sides only differ by replacing strings of monoidal structural morphisms
(that is, associators, unitors, and identities)
with different strings of structural morphisms with the same source and target.</p><p>That is, <code><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.monoidal">monoidal</a></code> can handle goals of the form
<code>a ≫ f ≫ b ≫ g ≫ c = a' ≫ f ≫ b' ≫ g ≫ c'</code>
where <code>a = a'</code>, <code>b = b'</code>, and <code>c = c'</code> can be proved using <code>monoidal_coherence</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/CategoryTheory/Monoidal/Basic.html#Mathlib.Tactic.Monoidal.tacticMonoidal">Mathlib.Tactic.Monoidal.tacticMonoidal</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Monoidal.tacticMonoidal</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;monoidal&quot;</span> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Monoidal.tacticMonoidal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
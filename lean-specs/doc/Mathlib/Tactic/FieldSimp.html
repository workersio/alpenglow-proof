<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.FieldSimp</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.FieldSimp";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Data/Ineq.html">Mathlib.Data.Ineq</a></li><li><a href="../.././Mathlib/Util/AtLocation.html">Mathlib.Util.AtLocation</a></li><li><a href="../.././Mathlib/Util/SynthesizeUsing.html">Mathlib.Util.SynthesizeUsing</a></li><li><a href="../.././Mathlib/Tactic/FieldSimp/Attr.html">Mathlib.Tactic.FieldSimp.Attr</a></li><li><a href="../.././Mathlib/Tactic/FieldSimp/Discharger.html">Mathlib.Tactic.FieldSimp.Discharger</a></li><li><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html">Mathlib.Tactic.FieldSimp.Lemmas</a></li><li><a href="../.././Mathlib/Util/AtomM/Recurse.html">Mathlib.Util.AtomM.Recurse</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.FieldSimp" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.onExponent"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">onExponent</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPrettyMonomial</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.tryClearZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">tryClearZero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.removeZeros"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">removeZeros</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.split"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">split</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.evalPretty"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPretty</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.mkMulProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkMulProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.div"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">div</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.mkDivProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkDivProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.DenomCondition"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.DenomCondition.proof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proofZero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.qNF.gcd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">gcd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.normalize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">normalize</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceExprQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExprQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceEqQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceEqQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceLeQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLeQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceLtQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLtQ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.reduceProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceProp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.parseDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">parseDischarger</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.fieldSimp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">fieldSimp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.convField_simp__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">convField_simp__</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.FieldSimp.proc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">proc</span></a></div><div class="nav_link"><a class="break_within" href="#fieldEq"><span class="name">fieldEq</span></a></div><div class="nav_link"><a class="break_within" href="#fieldLe"><span class="name">fieldLe</span></a></div><div class="nav_link"><a class="break_within" href="#fieldLt"><span class="name">fieldLt</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="field-simp-tactic"><code>field_simp</code> tactic <a class="hover-link" href="#field-simp-tactic">#</a></h1><p>Tactic to clear denominators in algebraic expressions.</p></div><div class="mod_doc"><h3 class="markdown-heading" id="Lists-of-expressions-representing-exponents-and-atoms-and-operations-on-such-lists">Lists of expressions representing exponents and atoms, and operations on such lists <a class="hover-link" href="#Lists-of-expressions-representing-exponents-and-atoms-and-operations-on-such-lists">#</a></h3></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L30-L43">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Basic meta-code &quot;normal form&quot; object of the <code>field_simp</code> tactic: a type synonym
for a list of ordered triples comprising an expression representing a term of a type <code>M</code> (where
typically <code>M</code> is a field), together with an integer &quot;power&quot; and a natural number &quot;index&quot;.</p><p>The natural number represents the index of the <code>M</code> term in the <code>AtomM</code> monad: this is not enforced,
but is sometimes assumed in operations.  Thus when items <code>((a₁, x₁), k)</code> and <code>((a₂, x₂), k)</code>
appear in two different <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">FieldSimp.qNF</a></code> objects (i.e. with the same <code>ℕ</code>-index <code>k</code>), it is expected
that the expressions <code>x₁</code> and <code>x₂</code> are the same.  It is also expected that the items in a
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">FieldSimp.qNF</a></code> list are in strictly decreasing order by natural-number index.</p><p>By forgetting the natural number indices, an expression representing a <code><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF">Mathlib.Tactic.FieldSimp.NF</a></code>
object can be built from a <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">FieldSimp.qNF</a></code> object; this construction is provided as
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">Mathlib.Tactic.FieldSimp.qNF.toNF</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">Mathlib.Tactic.FieldSimp.qNF</a> <span class="fn">M</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> ((<a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">Q(<span class="fn">«$M»</span>)</span>) <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.toNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L47-L54">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">«$M»</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF">NF</a> <span class="fn">«$M»</span></span>)</span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. a list of <code>(ℤ × Q($M)) × ℕ</code>s (two <code>Expr</code>s and a natural
number), build an <code>Expr</code> representing an object of type <code>NF M</code> (i.e. <code><a href="../.././Init/Prelude.html#List">List</a> (ℤ × M)</code>) in the
in the obvious way: by forgetting the natural numbers and gluing together the integers and <code>Expr</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.toNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.onExponent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L56-L60">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">onExponent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> → <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. a list of <code>(ℤ × Q($M)) × ℕ</code>s (two <code>Expr</code>s and a natural
number), apply an expression representing a function with domain <code>ℤ</code> to each of the <code>ℤ</code>
components.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent">onExponent</a></span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Data/List/Basic.html#List.map">List.map</a>
    <span class="fn">(fun (<span class="fn">x</span> : (<a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">Q(<span class="fn">«$M»</span>)</span>) <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">a</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">k</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">k</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span>)</span>
    <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.onExponent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L62-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPrettyMonomial</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.zpow'">zpow'</a> <span class="fn">«$x»</span> <span class="fn">«$r»</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$e»</span>)</span>)</span></span></div></div><p>Build a transparent expression for the product of powers represented by <code>l : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial">Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial</a> <span class="fn">iM</span> <span class="fn">0</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">q(<span class="fn">«$x»</span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">«$x»</span>)</span>, <span class="fn">q(<span class="fn">⋯</span>)</span><a href="../.././Init/Core.html#Sigma.mk">⟩</a></span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial">Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial</a> <span class="fn">iM</span> <span class="fn">1</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">x</span>, <span class="fn">q(<span class="fn">⋯</span>)</span><a href="../.././Init/Core.html#Sigma.mk">⟩</a></span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial">Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial</a> <span class="fn">iM</span> <span class="fn">(<a href="../.././Init/Data/Int/Basic.html#Int.ofNat">Int.ofNat</a> <span class="fn">r_2</span>)</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">pf</span> ← <span class="fn"><a href="../.././Mathlib/Util/Qq.html#Qq.mkDecideProofQ">Qq.mkDecideProofQ</a> <span class="fn">q(<span class="fn">«$r_2»</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">q(<span class="fn">«$x»</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$r_2»</span>)</span>, <span class="fn">q(<span class="fn">⋯</span>)</span><a href="../.././Init/Core.html#Sigma.mk">⟩</a></span></span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial">Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial</a> <span class="fn">iM</span> <span class="fn">r</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">pf</span> ← <span class="fn"><a href="../.././Mathlib/Util/Qq.html#Qq.mkDecideProofQ">Qq.mkDecideProofQ</a> <span class="fn">q(<span class="fn">«$r»</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">q(<span class="fn">«$x»</span> <a href="../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$r»</span>)</span>, <span class="fn">q(<span class="fn">⋯</span>)</span><a href="../.././Init/Core.html#Sigma.mk">⟩</a></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.tryClearZero"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L76-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.tryClearZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">tryClearZero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>
  <span class="fn">((<span class="fn">l'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a> (<a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">i</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span>;
    <span class="fn">Q(<span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span>)</span></span></div></div><p>Try to drop an expression <code>zpow' x r</code> from the beginning of a product. If <code>r ≠ 0</code> this of course
can't be done. If <code>r = 0</code>, then <code>zpow' x r</code> is equal to <code>x / x</code>, so it can be simplified to 1 (hence
dropped from the beginning of the product) if we can find a proof that <code>x ≠ 0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.tryClearZero" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.removeZeros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L92-L107">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">removeZeros</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>
  <span class="fn">((<span class="fn">l'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span>)</span></span></div></div><p>Given <code>l : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, obtain <code>l' : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code> by removing all <code>l</code>'s exponent-zero entries where the
corresponding atom can be proved nonzero, and construct a proof that their associated expressions
are equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros">Mathlib.Tactic.FieldSimp.qNF.removeZeros</a> <span class="fn">disch</span> <span class="fn">iM</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Core.html#Sigma.mk">⟨</a><a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a>, <span class="fn">q(<span class="fn">⋯</span>)</span><a href="../.././Init/Core.html#Sigma.mk">⟩</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.removeZeros" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L109-L124">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">split</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>
  <span class="fn">((<span class="fn">l_n</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
    <span class="fn">(<span class="fn">l_d</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
      <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l_d</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
      <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l_n</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
      <span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
      <span class="fn">Q(<span class="fn"><span class="fn">«$a_2»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span></span></span>)</span></span></div></div><p>Given a product of powers, split as a quotient: the positive powers divided by (the negations
of) the negative powers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split">Mathlib.Tactic.FieldSimp.qNF.split</a> <span class="fn">iM</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Core.html#Sigma.mk">⟨</a><a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a>, <a href="../.././Init/Core.html#Sigma.mk">⟨</a><a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a>, <span class="fn">q(<span class="fn">⋯</span>)</span><a href="../.././Init/Core.html#Sigma.mk">⟩</a><a href="../.././Init/Core.html#Sigma.mk">⟩</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.split" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.evalPretty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L140-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPretty"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">evalPretty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>
  <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) ×
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$e»</span>)</span></span>)</span></span></div></div><p>Build a transparent expression for the product of powers represented by <code>l : <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.evalPretty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.mul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L155-L178">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">«$M»</span>)</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">«$M»</span>)</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">q(<span class="fn">«$M»</span>)</span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(ℤ × Q($M)) × ℕ</code>s (an integer, an
<code>Expr</code> and a natural number), construct another such term <code>l</code>, which will have the property that in
the field <code>$M</code>, the product of the &quot;multiplicative linear combinations&quot; represented by <code>l₁</code> and
<code>l₂</code> is the multiplicative linear combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>l₁</code> and <code>l₂</code> are in strictly decreasing order
by <code>ℕ</code>-component, and that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code> appear in <code>l₁</code>, <code>l₂</code> respectively with
the same <code>ℕ</code>-component <code>k</code>, then the expressions <code>x₁</code> and <code>x₂</code> are equal.</p><p>The construction is as follows: merge the two lists, except that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code>
appear in <code>l₁</code>, <code>l₂</code> respectively with the same <code>ℕ</code>-component <code>k</code>, then contribute a term
<code>(a₁ + a₂, x₁)</code> to the output list with <code>ℕ</code>-component <code>k</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul">Mathlib.Tactic.FieldSimp.qNF.mul</a> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">x✝</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul">mul</a></span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.mul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.mkMulProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L180-L198">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkMulProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul">mul</a></span> <span class="fn">l₂</span>)</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn">«$a_2»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(ℤ × Q($M)) × ℕ</code>s (an integer, an
<code>Expr</code> and a natural number), recursively construct a proof that in the field <code>$M</code>, the product of
the &quot;multiplicative linear combinations&quot; represented by <code>l₁</code> and <code>l₂</code> is the multiplicative linear
combination represented by <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul">FieldSimp.qNF.mul</a> l₁ l₁</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof">Mathlib.Tactic.FieldSimp.qNF.mkMulProof</a> <span class="fn">iM</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof">Mathlib.Tactic.FieldSimp.qNF.mkMulProof</a> <span class="fn">iM</span> <span class="fn">l₁</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.mkMulProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.div"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L200-L222">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">div</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(ℤ × Q($M)) × ℕ</code>s (an integer, an
<code>Expr</code> and a natural number), construct another such term <code>l</code>, which will have the property that in
the field <code>$M</code>, the quotient of the &quot;multiplicative linear combinations&quot; represented by <code>l₁</code> and
<code>l₂</code> is the multiplicative linear combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>l₁</code> and <code>l₂</code> are in strictly decreasing order
by <code>ℕ</code>-component, and that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code> appear in <code>l₁</code>, <code>l₂</code> respectively with
the same <code>ℕ</code>-component <code>k</code>, then the expressions <code>x₁</code> and <code>x₂</code> are equal.</p><p>The construction is as follows: merge the first list and the negation of the second list, except
that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code> appear in <code>l₁</code>, <code>l₂</code> respectively with the same
<code>ℕ</code>-component <code>k</code>, then contribute a term <code>(a₁ - a₂, x₁)</code> to the output list with <code>ℕ</code>-component <code>k</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div">Mathlib.Tactic.FieldSimp.qNF.div</a> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">x✝</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent">onExponent</a></span> <a href="../.././Init/Prelude.html#Neg.neg">Neg.neg</a></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div">div</a></span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.div" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.mkDivProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L224-L242">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">mkDivProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div">div</a></span> <span class="fn">l₂</span>)</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn">«$a_2»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> M</code>, i.e. lists of <code>(ℤ × Q($M)) × ℕ</code>s (an integer, an
<code>Expr</code> and a natural number), recursively construct a proof that in the field <code>$M</code>, the quotient
of the &quot;multiplicative linear combinations&quot; represented by <code>l₁</code> and <code>l₂</code> is the multiplicative
linear combination represented by <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div">FieldSimp.qNF.div</a> l₁ l₁</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof">Mathlib.Tactic.FieldSimp.qNF.mkDivProof</a> <span class="fn">iM</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof">Mathlib.Tactic.FieldSimp.qNF.mkDivProof</a> <span class="fn">iM</span> <span class="fn">l₁</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.qNF.mkDivProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.DenomCondition"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L246-L252">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Constraints on denominators which may need to be considered in <code>field_simp</code>: no condition,
nonzeroness, or strict positivity.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.FieldSimp.DenomCondition.none">none<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span></li><li class="constructor" id="Mathlib.Tactic.FieldSimp.DenomCondition.nonzero">nonzero<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span></li><li class="constructor" id="Mathlib.Tactic.FieldSimp.DenomCondition.positive">positive<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM'</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono">PosMulStrictMono</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT">PosMulReflectLT</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass">ZeroLEOneClass</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span></li></ul><details id="instances-for-list-Mathlib.Tactic.FieldSimp.DenomCondition" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.DenomCondition.proof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L256-L261">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero">GroupWithZero</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">iM</span></span> → <a href="../.././foundational_types.html">Type</a></span></div></div><p>Given a field-simp-normal-form expression <code>L</code> (a product of powers of atoms), a proof (according
to the value of <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>) of that expression's nonzeroness, strict positivity, etc.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">Mathlib.Tactic.FieldSimp.DenomCondition.proof</a> <span class="fn">L</span> <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.none">Mathlib.Tactic.FieldSimp.DenomCondition.none</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">Mathlib.Tactic.FieldSimp.DenomCondition.proof</a> <span class="fn">L</span> <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.nonzero">Mathlib.Tactic.FieldSimp.DenomCondition.nonzero</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">Mathlib.Tactic.FieldSimp.NF.eval</a> <span class="fn">unknown_1</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">Mathlib.Tactic.FieldSimp.DenomCondition.proof</a> <span class="fn">L</span>
    <span class="fn">(<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.positive">Mathlib.Tactic.FieldSimp.DenomCondition.positive</a> <span class="fn">iM'</span> <span class="fn">iM''</span> <span class="fn">iM'''</span> <span class="fn">iM''''</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">Q(<span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">Mathlib.Tactic.FieldSimp.NF.eval</a> <span class="fn">unknown_1</span></span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.DenomCondition.proof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.DenomCondition.proofZero"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L263-L270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">DenomCondition</span>.<span class="name">proofZero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<a href="../.././Init/Prelude.html#inferInstance">inferInstance</a>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">proof</a> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">cond</span></span></div></div><p>The empty field-simp-normal-form expression <code>[]</code> (representing <code>1</code> as an empty product of powers
of atoms) can be proved to be nonzero, strict positivity, etc., as needed, as specified by the
value of <code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.none">Mathlib.Tactic.FieldSimp.DenomCondition.none</a>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero">proofZero</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.nonzero">Mathlib.Tactic.FieldSimp.DenomCondition.nonzero</a>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero">proofZero</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.positive">Mathlib.Tactic.FieldSimp.DenomCondition.positive</a> <span class="fn">iM'</span> <span class="fn">iM''</span> <span class="fn">iM'''</span> <span class="fn">iM''''</span>)</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero">proofZero</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.DenomCondition.proofZero" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L274-L294">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<a href="../.././Init/Prelude.html#inferInstance">inferInstance</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hL</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">L</span> <span class="fn">cond</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<span class="fn">Q(<span class="fn">«$e»</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> (<a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">e</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">i</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">L</span>) <span class="fn">cond</span></span>)</span></div></div><p>Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>) of a field-simp-normal-form expression <code>L</code> (a product of powers of atoms),
construct a corresponding proof for <code>((r, e), i) :: L</code>.</p><p>In this version we also expose the proof of nonzeroness of <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc">Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc</a> <span class="fn">disch</span> <span class="fn">hL_2</span> <span class="fn">e</span> <span class="fn">r</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn">disch</span> <span class="fn">q(<span class="fn">«$e»</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">__do_lift</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a><a href="../.././Init/Prelude.html#Prod.mk">)</a></span></span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc">Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc</a> <span class="fn">disch</span> <span class="fn">hL_2</span> <span class="fn">e</span> <span class="fn">r</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">pf</span> ← <span class="fn"><span class="fn">disch</span> <span class="fn">q(<span class="fn">«$e»</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
  have pf₀ :
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">L</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span> :=
    <span class="fn">hL_2</span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">pf</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">q(<span class="fn">⋯</span>)</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L296-L313">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">mkDenomConditionProofSucc'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<a href="../.././Init/Prelude.html#inferInstance">inferInstance</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hL</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">L</span> <span class="fn">cond</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> (<a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">e</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">i</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">L</span>) <span class="fn">cond</span>)</span></span></div></div><p>Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of
<code><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a></code>) of a field-simp-normal-form expression <code>L</code> (a product of powers of atoms),
construct a corresponding proof for <code>((r, e), i) :: L</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'">Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'</a> <span class="fn">disch</span> <span class="fn">hL_2</span> <span class="fn">e</span> <span class="fn">r</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Unit.unit">(</a><a href="../.././Init/Prelude.html#Unit.unit">)</a></span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'">Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'</a> <span class="fn">disch</span> <span class="fn">hL_2</span> <span class="fn">e</span> <span class="fn">r</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">pf</span> ← <span class="fn"><span class="fn">disch</span> <span class="fn">q(<span class="fn">«$e»</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
  have pf₀ :
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">L</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span> :=
    <span class="fn">hL_2</span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">q(<span class="fn">⋯</span>)</span></span></span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'">Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'</a> <span class="fn">disch</span> <span class="fn">hL_2</span> <span class="fn">e</span> <span class="fn">r</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">pf</span> ← <span class="fn"><span class="fn">disch</span> <span class="fn">q(<span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$e»</span>)</span></span>
  have pf₀ :
    <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">L</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span> :=
    <span class="fn">hL_2</span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">q(<span class="fn">⋯</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.qNF.gcd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L317-L404">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.gcd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">qNF</span>.<span class="name">gcd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cond</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition">DenomCondition</a> <span class="fn">q(<a href="../.././Init/Prelude.html#inferInstance">inferInstance</a>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>
  <span class="fn">((<span class="fn">L</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
    <span class="fn">(<span class="fn">l₁'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
      <span class="fn">(<span class="fn">l₂'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
        <span class="fn">(have <span class="fn">a</span> := <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
          <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
          <span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">L</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
          <span class="fn">Q(<span class="fn"><span class="fn">«$a_2»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a>           <span class="fn">(have <span class="fn">a</span> := <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
            <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
            <span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">L</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
            <span class="fn">Q(<span class="fn"><span class="fn">«$a_2»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a>             <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof">DenomCondition.proof</a> <span class="fn">L</span> <span class="fn">cond</span></span></span></span>)</span></span></div></div><p>Extract a common factor <code>L</code> of two products-of-powers <code>l₁</code> and <code>l₂</code> in <code>M</code>, in the sense that
both <code>l₁</code> and <code>l₂</code> are quotients by <code>L</code> of products of <em>positive</em> powers.</p><p>The variable <code><a href="../.././Init/Prelude.html#cond">cond</a></code> specifies whether we extract a <em>certified nonzero[/positive]</em> (and therefore
potentially smaller) common factor. If so, the metaprogram returns a &quot;proof&quot; that this common factor
is nonzero/positive, i.e. an expression <code>Q(NF.eval $(L.toNF) ≠ 0)</code> / <code>Q(0 &lt; NF.eval $(L.toNF))</code>.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Core-of-the-field-simp-tactic">Core of the <code>field_simp</code> tactic <a class="hover-link" href="#Core-of-the-field-simp-tactic">#</a></h3></div><div class="decl" id="Mathlib.Tactic.FieldSimp.normalize"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L410-L527">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.normalize"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">normalize</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a>
  <span class="fn">((<span class="fn">y</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) ×
    <span class="fn">((<span class="fn">g</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign">Sign</a> <span class="fn">M</span></span>) ×
        <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign.expr">expr</a></span> <span class="fn">y</span></span>;
        <span class="fn">Q(<span class="fn">«$x»</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$a»</span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a>       <span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF">qNF</a> <span class="fn">M</span></span>) ×
        <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF">toNF</a></span>;
        <span class="fn">Q(<span class="fn">«$y»</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval">eval</a></span>)</span></span></span>)</span></span></div></div><p>The main algorithm behind the <code>field_simp</code> tactic: partially-normalizing an
expression in a field <code>M</code> into the form x1 ^ c1 * x2 ^ c2 * ... x_k ^ c_k,
where x1, x2, ... are distinct atoms in <code>M</code>, and c1, c2, ... are integers.</p></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceExprQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L529-L537">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExprQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExprQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">x'</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">Q(<span class="fn">«$x»</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$x'»</span>)</span>)</span></span></div></div><p>Given <code>x</code> in a commutative group-with-zero, construct a new expression in the standard form
*** / *** (all denominators at the end) which is equal to <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceExprQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceEqQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L539-L552">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceEqQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceEqQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">f₁</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">(<span class="fn">f₂</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">Q((<span class="fn">«$e₁»</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$e₂»</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">«$f₁»</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$f₂»</span>))</span></span>)</span></span></div></div><p>Given <code>e₁</code> and <code>e₂</code>, cancel nonzero factors to construct a new equality which is logically
equivalent to <code>e₁ = e₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceEqQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceLeQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L554-L570">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLeQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLeQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono">PosMulStrictMono</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLE">PosMulReflectLE</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass">ZeroLEOneClass</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">f₁</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">(<span class="fn">f₂</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">Q((<span class="fn">«$e₁»</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">«$e₂»</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">«$f₁»</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">«$f₂»</span>))</span></span>)</span></span></div></div><p>Given <code>e₁</code> and <code>e₂</code>, cancel positive factors to construct a new inequality which is logically
equivalent to <code>e₁ ≤ e₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceLeQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceLtQ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L572-L588">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLtQ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceLtQ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero">CommGroupWithZero</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono">PosMulStrictMono</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM'''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT">PosMulReflectLT</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM''''</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass">ZeroLEOneClass</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">((<span class="fn">f₁</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">(<span class="fn">f₂</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>) × <span class="fn">Q((<span class="fn">«$e₁»</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$e₂»</span>) <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">«$f₁»</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$f₂»</span>))</span></span>)</span></span></div></div><p>Given <code>e₁</code> and <code>e₂</code>, cancel positive factors to construct a new inequality which is logically
equivalent to <code>e₁ &lt; e₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceLtQ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L590-L607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></div></div><p>Given <code>x</code> in a commutative group-with-zero, construct a new expression in the standard form
*** / *** (all denominators at the end) which is equal to <code>x</code>.</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.reduceProp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L609-L641">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceProp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">reduceProp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">disch</span> : <span class="fn">{<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></div></div><p>Given an (in)equality <code>a = b</code> (respectively, <code>a ≤ b</code>, <code>a &lt; b</code>), cancel nonzero (resp. positive)
factors to construct a new (in)equality which is logically equivalent to <code>a = b</code> (respectively,
<code>a ≤ b</code>, <code>a &lt; b</code>).</p><details id="instances-for-list-Mathlib.Tactic.FieldSimp.reduceProp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Frontend">Frontend <a class="hover-link" href="#Frontend">#</a></h3></div><div class="decl" id="Mathlib.Tactic.FieldSimp.parseDischarger"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L647-L664">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.parseDischarger"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">parseDischarger</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> (<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Tactic.discharger</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> (<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Tactic.simpArgs</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <span class="fn">({<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>} → <span class="fn">(<span class="fn">type</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Sort</a> u)</span>) → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">Q(<span class="fn">«$type»</span>)</span></span></span>)</span></span></div></div><p>If the user provided a discharger, elaborate it. If not, we will use the <code>field_simp</code> default
discharger, which (among other things) includes a simp-run for the specified argument list, so we
elaborate those arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.parseDischarger" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.fieldSimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L666-L706">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">fieldSimp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The goal of <code>field_simp</code> is to bring expressions in (semi-)fields over a common denominator, i.e. to
reduce them to expressions of the form <code>n / d</code> where neither <code>n</code> nor <code>d</code> contains any division
symbol. For example, <code>x / (1 - y) / (1 + y / (1 - y))</code> is reduced to <code>x / (1 - y + y)</code>:</p><pre><code>example (x y z : ℚ) (hy : 1 - y ≠ 0) :
    ⌊x / (1 - y) / (1 + y / (1 - y))⌋ &lt; 3 := by
  field_simp
  -- new goal: `⊢ ⌊x / (1 - y + y)⌋ &lt; 3`
</code></pre><p>The <code>field_simp</code> tactic will also clear denominators in field <em>(in)equalities</em>, by
cross-multiplying. For example, <code>field_simp</code> will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  field_simp
  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>A very common pattern is <code>field_simp; ring</code> (clear denominators, then the resulting goal is
solvable by the axioms of a commutative ring). The finishing tactic <code>field</code> is a shorthand for this
pattern.</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field_simp</code> tactic attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
(e.g. <code>field_simp [hx]</code>). If your expression is not completely reduced by <code>field_simp</code>, check the
denominators of the resulting expression and provide proofs that they are nonzero/positive to enable
further progress.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.fieldSimp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.convField_simp__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L708-L739">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.convField_simp__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">convField_simp__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The goal of the <code>field_simp</code> conv tactic is to bring an expression in a (semi-)field over a common
denominator, i.e. to reduce it to an expression of the form <code>n / d</code> where neither <code>n</code> nor <code>d</code>
contains any division symbol. For example, <code>x / (1 - y) / (1 + y / (1 - y))</code> is reduced to
<code>x / (1 - y + y)</code>:</p><pre><code>example (x y z : ℚ) (hy : 1 - y ≠ 0) :
    ⌊x / (1 - y) / (1 + y / (1 - y))⌋ &lt; 3 := by
  conv =&gt; enter [1, 1]; field_simp
  -- new goal: `⊢ ⌊x / (1 - y + y)⌋ &lt; 3`
</code></pre><p>As in this example, cancelling and combining denominators will generally require checking
&quot;nonzeroness&quot; side conditions. The <code>field_simp</code> tactic attempts to discharge these, and will omit
such steps if it cannot discharge the corresponding side conditions. The discharger will try, among
other things, <code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness proofs included
explicitly (e.g. <code>field_simp [hx]</code>). If your expression is not completely reduced by <code>field_simp</code>,
check the denominators of the resulting expression and provide proofs that they are nonzero to
enable further progress.</p><p>The <code>field_simp</code> conv tactic is a variant of the main (i.e., not conv) <code>field_simp</code> tactic. The
latter operates recursively on subexpressions, bringing <em>every</em> field-expression encountered to the
form <code>n / d</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.convField_simp__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.FieldSimp.proc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L741-L775">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">FieldSimp</span>.<span class="name">proc</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc">Lean.Meta.Simp.Simproc</a></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.FieldSimp.proc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="fieldEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L781-L781">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#fieldEq"><span class="name">fieldEq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc">Lean.Meta.Simp.Simproc</a></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/FieldSimp.html#fieldEq">fieldEq</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc">Mathlib.Tactic.FieldSimp.proc</a></li></ul></details><details id="instances-for-list-fieldEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="fieldLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L782-L782">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#fieldLe"><span class="name">fieldLe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc">Lean.Meta.Simp.Simproc</a></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/FieldSimp.html#fieldLe">fieldLe</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc">Mathlib.Tactic.FieldSimp.proc</a></li></ul></details><details id="instances-for-list-fieldLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="fieldLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/FieldSimp.lean#L783-L783">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/FieldSimp.html#fieldLt"><span class="name">fieldLt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc">Lean.Meta.Simp.Simproc</a></div></div><p>The goal of the simprocs grouped under the <code>field</code> attribute is to clear denominators in
(semi-)field (in)equalities, by bringing LHS and RHS each over a common denominator and then
cross-multiplying. For example, the <code>field</code> simproc will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x ≠ 0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  simp only [field]
  -- new goal: `⊢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>The <code>field</code> simproc-set's functionality is a variant of the more general <code>field_simp</code> tactic, which
not only clears denominators in field (in)equalities but also brings isolated field expressions into
the normal form <code>n / d</code> (where neither <code>n</code> nor <code>d</code> contains any division symbol). (For confluence
reasons, the <code>field</code> simprocs also have a slightly different normal form from <code>field_simp</code>'s.)</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field</code> simproc-set attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="../.././Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
in the simp call (e.g. <code>simp [field, hx]</code>). If your (in)equality is not completely reduced by the
<code>field</code> simproc-set, check the denominators of the resulting (in)equality and provide proofs that
they are nonzero/positive to enable further progress.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/FieldSimp.html#fieldLt">fieldLt</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc">Mathlib.Tactic.FieldSimp.proc</a></li></ul></details><details id="instances-for-list-fieldLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We register <code>field_simp</code> with the <code>hint</code> tactic.</p></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Bound</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Bound";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Aesop.html">Aesop</a></li><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/Lemma.html">Mathlib.Tactic.Lemma</a></li><li><a href="../.././Mathlib/Tactic/Bound/Attribute.html">Mathlib.Tactic.Bound.Attribute</a></li><li><a href="../.././Mathlib/Tactic/Linarith/Frontend.html">Mathlib.Tactic.Linarith.Frontend</a></li><li><a href="../.././Mathlib/Tactic/NormNum/Core.html">Mathlib.Tactic.NormNum.Core</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Bound" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.Nat.cast_pos_of_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">Nat</span>.<span class="name">cast_pos_of_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.Nat.one_le_cast_of_le"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">Nat</span>.<span class="name">one_le_cast_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.le_max_of_le_left_or_le_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">le_max_of_le_left_or_le_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.lt_max_of_lt_left_or_lt_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">lt_max_of_lt_left_or_lt_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.min_le_of_left_le_or_right_le"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">min_le_of_left_le_or_right_le</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.min_lt_of_left_lt_or_right_lt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">min_lt_of_left_lt_or_right_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.boundNormNum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">boundNormNum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.boundLinarith"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">boundLinarith</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Bound.boundConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">boundConfig</span></a></div><div class="nav_link"><a class="break_within" href="#«tacticBound[_]»"><span class="name">«tacticBound[_]»</span></a></div></nav><main>
<div class="mod_doc"><h2 class="markdown-heading" id="The-bound-tactic">The <code>bound</code> tactic <a class="hover-link" href="#The-bound-tactic">#</a></h2><p><code>bound</code> is an <code>aesop</code> wrapper that proves inequalities by straightforward recursion on structure,
assuming that intermediate terms are nonnegative or positive as needed.  It also has some support
for guessing where it is unclear where to recurse, such as which side of a <code>min</code> or <code>max</code> to use
as the bound or whether to assume a power is less than or greater than one.</p><p>The functionality of <code>bound</code> overlaps with <code>positivity</code> and <code>gcongr</code>, but can jump back and forth
between <code>0 ≤ x</code> and <code>x ≤ y</code>-type inequalities.  For example, <code>bound</code> proves
<code>0 ≤ c → b ≤ a → 0 ≤ a * c - b * c</code>
by turning the goal into <code>b * c ≤ a * c</code>, then using <code><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_right">mul_le_mul_of_nonneg_right</a></code>.  <code>bound</code> also
uses specialized lemmas for goals of the form <code>1 ≤ x, 1 &lt; x, x ≤ 1, x &lt; 1</code>.</p><p>Additional hypotheses can be passed as <code>bound [h0, h1 n, ...]</code>.  This is equivalent to declaring
them via <code>have</code> before calling <code>bound</code>.</p><p>See <code><a href="../.././MathlibTest/Bound/bound.html">MathlibTest/Bound/bound.lean</a></code> for tests.</p><h3 class="markdown-heading" id="Calc-usage">Calc usage <a class="hover-link" href="#Calc-usage">#</a></h3><p>Since <code>bound</code> requires the inequality proof to exactly match the structure of the expression, it is
often useful to iterate between <code>bound</code> and <code>rw / simp</code> using <code>calc</code>.  Here is an example:</p><pre><code>-- Calc example: A weak lower bound for `z ↦ z^2 + c`
<a href="../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> le_sqr_add {c z : ℂ} (cz : <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> c ≤ <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> z) (z3 : 3 ≤ <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> z) :
    2 * <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> z ≤ <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> (z^2 + c) := by
  calc <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> (z^2 + c)
    _ ≥ <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> (z^2) - <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> c := by bound
    _ ≥ <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> (z^2) - <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> z := by bound
    _ ≥ (abs z - 1) * <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> z := by rw [mul_comm, mul_sub_one, ← pow_two, ← abs.map_pow]
    _ ≥ 2 * <a href="../.././Mathlib/Algebra/Order/Group/Unbundled/Abs.html#abs">abs</a> z := by bound
</code></pre><h3 class="markdown-heading" id="Aesop-rules">Aesop rules <a class="hover-link" href="#Aesop-rules">#</a></h3><p><code>bound</code> uses threes types of aesop rules: <code>apply</code>, <code>forward</code>, and closing <code>tactic</code>s.  To register a
lemma as an <code>apply</code> rule, tag it with <code>@[bound]</code>.  It will be automatically converted into either a
<code>norm apply</code> or <code>safe apply</code> rule depending on the number and type of its hypotheses:</p><ol>
<li>Nonnegativity/positivity/nonpositivity/negativity hypotheses get score 1 (those involving <code>0</code>).</li>
<li>Other inequalities get score 10.</li>
<li>Disjunctions <code>a ∨ b</code> get score 100, plus the score of <code>a</code> and <code>b</code>.</li>
</ol><p>Score <code>0</code> lemmas turn into <code>norm apply</code> rules, and score <code>0 &lt; s</code> lemmas turn into <code>safe apply s</code>
rules.  The score is roughly lexicographic ordering on the counts of the three type (guessing,
general, involving-zero), and tries to minimize the complexity of hypotheses we have to prove.
See <code><a href="../.././Mathlib/Tactic/Bound/Attribute.html">Mathlib/Tactic/Bound/Attribute.lean</a></code> for the full algorithm.</p><p>To register a lemma as a <code>forward</code> rule, tag it with <code>@[bound_forward]</code>.  The most important
builtin forward rule is <code><a href="../.././Mathlib/Order/Defs/PartialOrder.html#le_of_lt">le_of_lt</a></code>, so that strict inequalities can be used to prove weak
inequalities.  Another example is <code>HasFPowerSeriesOnBall.r_pos</code>, so that <code>bound</code> knows that any
power series present in the context have positive radius of convergence.  Custom <code>@[bound_forward]</code>
rules that similarly expose inequalities inside structures are often useful.</p><h3 class="markdown-heading" id="Guessing-apply-rules">Guessing apply rules <a class="hover-link" href="#Guessing-apply-rules">#</a></h3><p>There are several cases where there are two standard ways to recurse down an inequality, and it is
not obvious which is correct without more information.  For example, <code>a ≤ min b c</code> is registered as
a <code>safe apply 4</code> rule, since we always need to prove <code>a ≤ b ∧ a ≤ c</code>.  But if we see <code>min a b ≤ c</code>,
either <code>a ≤ c</code> or <code>b ≤ c</code> suffices, and we don't know which.</p><p>In these cases we declare a new lemma with an <code>∨</code> hypotheses that covers the two cases.  Tagging
it as <code>@[bound]</code> will add a +100 penalty to the score, so that it will be used only if necessary.
Aesop will then try both ways by splitting on the resulting <code>∨</code> hypothesis.</p><p>Currently the two types of guessing rules are</p><ol>
<li><code>min</code> and <code>max</code> rules, for both <code>≤</code> and <code>&lt;</code></li>
<li><code>pow</code> and <code>rpow</code> monotonicity rules which branch on <code>1 ≤ a</code> or <code>a ≤ 1</code>.</li>
</ol><h3 class="markdown-heading" id="Closing-tactics">Closing tactics <a class="hover-link" href="#Closing-tactics">#</a></h3><p>We close numerical goals with <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> and <code>linarith</code>.</p></div><div class="mod_doc"><h3 class="markdown-heading" id="mpr-lemmas-of-iff-statements-for-use-as-Aesop-apply-rules"><code>.mpr</code> lemmas of iff statements for use as Aesop apply rules <a class="hover-link" href="#mpr-lemmas-of-iff-statements-for-use-as-Aesop-apply-rules">#</a></h3><p>Once Aesop can do general terms directly, we can remove these:</p><p><a href="https://github.com/leanprover-community/aesop/issues/107">https://github.com/leanprover-community/aesop/issues/107</a></p></div><div class="decl" id="Mathlib.Tactic.Bound.Nat.cast_pos_of_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L102-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.Nat.cast_pos_of_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">Nat</span>.<span class="name">cast_pos_of_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Order/Ring/Defs.html#IsOrderedRing">IsOrderedRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">n</span> → <span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">↑<span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Bound.Nat.one_le_cast_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L106-L109">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.Nat.one_le_cast_of_le"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">Nat</span>.<span class="name">one_le_cast_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Nat/Cast/Defs.html#AddCommMonoidWithOne">AddCommMonoidWithOne</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Order/Monoid/Unbundled/Defs.html#AddLeftMono">AddLeftMono</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass">ZeroLEOneClass</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span> → <span class="fn">1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">↑<span class="fn">n</span></span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Apply-rules-for-bound">Apply rules for <code>bound</code> <a class="hover-link" href="#Apply-rules-for-bound">#</a></h3><p>Most <code>bound</code> lemmas are registered in-place where the lemma is declared. These are only the lemmas
that do not require additional imports within this file.</p></div><div class="mod_doc"><h3 class="markdown-heading" id="Forward-rules-for-bound">Forward rules for <code>bound</code> <a class="hover-link" href="#Forward-rules-for-bound">#</a></h3></div><div class="mod_doc"><h3 class="markdown-heading" id="Guessing-rules-when-we-don-t-know-how-to-recurse">Guessing rules: when we don't know how to recurse <a class="hover-link" href="#Guessing-rules-when-we-don-t-know-how-to-recurse">#</a></h3></div><div class="decl" id="Mathlib.Tactic.Bound.le_max_of_le_left_or_le_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L160-L160">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.le_max_of_le_left_or_le_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">le_max_of_le_left_or_le_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Init/Prelude.html#Max.max">max</a> <span class="fn">b</span> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Bound.lt_max_of_lt_left_or_lt_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L161-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.lt_max_of_lt_left_or_lt_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">lt_max_of_lt_left_or_lt_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><a href="../.././Init/Prelude.html#Max.max">max</a> <span class="fn">b</span> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Bound.min_le_of_left_le_or_right_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L162-L162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.min_le_of_left_le_or_right_le"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">min_le_of_left_le_or_right_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> → <span class="fn"><a href="../.././Init/Prelude.html#Min.min">min</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Bound.min_lt_of_left_lt_or_right_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L163-L163">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.min_lt_of_left_lt_or_right_lt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">min_lt_of_left_lt_or_right_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span> → <span class="fn"><a href="../.././Init/Prelude.html#Min.min">min</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Closing-tactics">Closing tactics <a class="hover-link" href="#Closing-tactics">#</a></h3><p>TODO: Kim Morrison noted that we could check for <code>ℕ</code> or <code>ℤ</code> and try <code>omega</code> as well.</p></div><div class="decl" id="Mathlib.Tactic.Bound.boundNormNum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L182-L188">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundNormNum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">boundNormNum</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Aesop/RuleTac/Basic.html#Aesop.RuleTac">Aesop.RuleTac</a></div></div><p>Close numerical goals with <code><a href="../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Bound.boundNormNum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Bound.boundLinarith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L191-L195">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundLinarith"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">boundLinarith</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Aesop/RuleTac/Basic.html#Aesop.RuleTac">Aesop.RuleTac</a></div></div><p>Close numerical and other goals with <code>linarith</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Bound.boundLinarith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="bound-tactic-implementation"><code>bound</code> tactic implementation <a class="hover-link" href="#bound-tactic-implementation">#</a></h3></div><div class="decl" id="Mathlib.Tactic.Bound.boundConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L202-L205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Bound</span>.<span class="name">boundConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Aesop/Options/Public.html#Aesop.Options">Aesop.Options</a></div></div><p>Aesop configuration for <code>bound</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Bound.html#Mathlib.Tactic.Bound.boundConfig">Mathlib.Tactic.Bound.boundConfig</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Aesop/Options/Public.html#Aesop.Options.mk">{</a> <span class="fn">enableSimp</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> <a href="../.././Aesop/Options/Public.html#Aesop.Options.mk">}</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Bound.boundConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«tacticBound[_]»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Bound.lean#L209-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Bound.html#«tacticBound[_]»"><span class="name">«tacticBound[_]»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>bound</code> tactic for proving inequalities via straightforward recursion on expression structure.</p><p>An example use case is</p><pre><code>-- Calc example: A weak lower bound for `z ↦ z^2 + c`
<a href="../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> le_sqr_add (c z : ℝ) (cz : ‖c‖ ≤ ‖z‖) (z3 : 3 ≤ ‖z‖) :
    2 * ‖z‖ ≤ ‖z^2 + c‖ := by
  calc ‖z^2 + c‖
    _ ≥ ‖z^2‖ - ‖c‖ := by bound
    _ ≥ ‖z^2‖ - ‖z‖ := by  bound
    _ ≥ (‖z‖ - 1) * ‖z‖ := by
      rw [mul_comm, mul_sub_one, ← pow_two, ← norm_pow]
    _ ≥ 2 * ‖z‖ := by bound
</code></pre><p><code>bound</code> is built on top of <code>aesop</code>, and uses</p><ol>
<li>Apply lemmas registered via the <code>@[bound]</code> attribute</li>
<li>Forward lemmas registered via the <code>@[bound_forward]</code> attribute</li>
<li>Local hypotheses from the context</li>
<li>Optionally: additional hypotheses provided as <code>bound [h₀, h₁]</code> or similar. These are added to the
context as if by <code>have := hᵢ</code>.</li>
</ol><p>The functionality of <code>bound</code> overlaps with <code>positivity</code> and <code>gcongr</code>, but can jump back and forth
between <code>0 ≤ x</code> and <code>x ≤ y</code>-type inequalities.  For example, <code>bound</code> proves
<code>0 ≤ c → b ≤ a → 0 ≤ a * c - b * c</code>
by turning the goal into <code>b * c ≤ a * c</code>, then using <code><a href="../.././Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_right">mul_le_mul_of_nonneg_right</a></code>.  <code>bound</code> also
contains lemmas for goals of the form <code>1 ≤ x, 1 &lt; x, x ≤ 1, x &lt; 1</code>.  Conversely, <code>gcongr</code> can prove
inequalities for more types of relations, supports all <code>positivity</code> functionality, and is likely
faster since it is more specialized (not built atop <code>aesop</code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-«tacticBound[_]»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We register <code>bound</code> with the <code>hint</code> tactic.</p></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
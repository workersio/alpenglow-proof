<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Module</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Module";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/Ring.html">Mathlib.Tactic.Ring</a></li><li><a href="../.././Mathlib/Util/AtomM.html">Mathlib.Util.AtomM</a></li><li><a href="../.././Mathlib/Algebra/Algebra/Tower.html">Mathlib.Algebra.Algebra.Tower</a></li><li><a href="../.././Mathlib/Algebra/BigOperators/GroupWithZero/Action.html">Mathlib.Algebra.BigOperators.GroupWithZero.Action</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Module" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.«term_::ᵣ_»"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">«term_::ᵣ_»</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.atom_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">atom_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.zero_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval₁</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval₂"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval₂</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval₃"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval₃</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.add_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval₁</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval₂"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval₂</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval₃"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval₃</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.instNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instNeg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.zero_sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_sub_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.neg_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">neg_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.instSMulOfMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instSMulOfMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.smul_apply"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.smul_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_cons_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_cons_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_const</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_const_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_const_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_of_eval_eq_eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">algebraMap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.NF.eval_algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_algebraMap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.onScalar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">onScalar</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.mkAddProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkAddProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">sub</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.mkSubProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkSubProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.qNF.matchRings"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">matchRings</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.parse"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">parse</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.reduceCoefficientwise"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">reduceCoefficientwise</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.matchScalarsAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalarsAux</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.algebraMapThms"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">algebraMapThms</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.postprocess"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">postprocess</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.matchScalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalars</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.tacticMatch_scalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticMatch_scalars</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Module.tacticModule"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticModule</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="A-tactic-for-normalization-over-modules">A tactic for normalization over modules <a class="hover-link" href="#A-tactic-for-normalization-over-modules">#</a></h1><p>This file provides the two tactics <code>match_scalars</code> and <code>module</code>.  Given a goal which is an equality
in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), the <code>match_scalars</code> tactic parses the LHS and RHS of
the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduces the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.  The <code>module</code> tactic does this and
then runs the <code>ring</code> tactic on each of these coefficient-wise equalities, failing if this does not
resolve them.</p><p>The scalar type <code>R</code> is not pre-determined: instead it starts as <code>ℕ</code> (when each atom is initially
given a scalar <code>(1:ℕ)</code>) and gets bumped up into bigger semirings when such semirings are
encountered.  However, to permit this, it is assumed that there is a &quot;linear order&quot; on all the
semirings which appear in the expression: for any two semirings <code>R</code> and <code>S</code> which occur, we have
either <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>).</p></div><div class="mod_doc"><h3 class="markdown-heading" id="Theory-of-lists-of-pairs-scalar-vector">Theory of lists of pairs (scalar, vector) <a class="hover-link" href="#Theory-of-lists-of-pairs-scalar-vector">#</a></h3><p>This section contains the lemmas which are orchestrated by the <code>match_scalars</code> and <code>module</code> tactics
to prove goals in modules.  The basic object which these lemmas concern is <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> R M</code>, a type synonym
for a list of ordered pairs in <code>R × M</code>, where typically <code>M</code> is an <code>R</code>-module.</p></div><div class="decl" id="Mathlib.Tactic.Module.NF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L39-L45">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u_2 u_1)</div></div><p>Basic theoretical &quot;normal form&quot; object of the <code>match_scalars</code> and <code>module</code> tactics: a type
synonym for a list of ordered pairs in <code>R × M</code>, where typically <code>M</code> is an <code>R</code>-module.  This is the
form to which the tactics reduce module expressions.</p><p>(It is not a full &quot;normal form&quot; because the scalars, i.e. <code>R</code> components, are not themselves
ring-normalized. But this partial normal form is more convenient for our purposes.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Mathlib.Tactic.Module.NF</a> <span class="fn">R</span> <span class="fn">M</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> (<span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.NF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.cons"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L50-L53">source</a></div><div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span></div></div><p>Augment a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> R M</code> object <code>l</code>, i.e. a list of pairs in <code>R × M</code>, by prepending another
pair <code>p : R × M</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">p</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">p</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.NF.cons" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.«term_::ᵣ_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L55-L55">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.«term_::ᵣ_»"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">«term_::ᵣ_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Augment a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> R M</code> object <code>l</code>, i.e. a list of pairs in <code>R × M</code>, by prepending another
pair <code>p : R × M</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.NF.«term_::ᵣ_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L57-L60">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Zero">Zero</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#SMul">SMul</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">M</span></div></div><p>Evaluate a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> R M</code> object <code>l</code>, i.e. a list of pairs in <code>R × M</code>, to an element of <code>M</code>, by
forming the &quot;linear combination&quot; it specifies: scalar-multiply each <code>R</code> term to the corresponding
<code>M</code> term, then add them all up.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../.././Init/Data/List/Basic.html#List.map">List.map</a>
      <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>) =&gt;
        <span class="fn">match <span class="fn">x</span> with
        | <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <span class="fn">r</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span></span>)</span>
      <span class="fn">l</span>)</span>.<a href="../.././Init/Data/List/Basic.html#List.sum">sum</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.NF.eval" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L62-L64">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#SMul">SMul</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">p</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">p</span>.1</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn"><span class="fn">p</span>.2</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.atom_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L66-L66">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.atom_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">atom_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a> <a href="../.././Init/Prelude.html#List.cons">[</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">1</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#List.cons">]</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.zero_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L69-L69">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_eq_eval</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L71-L74">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#SMul">SMul</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">a₂</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">a₂</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L76-L83">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₂"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r₁ </span><span class="fn">r₂</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₁</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₂</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">r₂</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L85-L92">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval₃"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">(<span class="fn">a₂</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a₂</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.add_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L94-L99">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.add_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">add_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₁</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₂</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R₁</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R₁</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R₂</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R₂</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R₁</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₂'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R₂</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x₁ </span><span class="fn">x₂</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx₁</span> : <span class="fn">x₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx₂</span> : <span class="fn">x₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">x₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L101-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#SMul">SMul</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddGroup">AddGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">(<span class="fn">a₂</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">(<span class="fn">a₂</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L106-L113">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₂"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r₁ </span><span class="fn">r₂</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₁</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₂</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₁</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">r₂</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L115-L120">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval₃"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a₁</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">(<span class="fn">a₂</span> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn"><span class="fn">a₂</span>.1</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">a₂</span>.2</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.sub_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L122-L129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">sub_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₁</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₂</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S₁</span> : <a href="../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S₂</span> : <a href="../.././foundational_types.html">Type</a> u_7}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R₁</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R₁</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R₂</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R₂</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S₁</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S₁</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S₂</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S₂</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂ </span><span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R₁</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₂'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R₂</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁''</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S₁</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₂''</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S₂</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x₁ </span><span class="fn">x₂</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx₁</span> : <span class="fn">x₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₁''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx₂</span> : <span class="fn">x₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁'</span> : <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₁''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂'</span> : <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂''</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x₁</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">x₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.instNeg"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L131-L132">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instNeg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Neg">Neg</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Neg">Neg</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L134-L138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.zero_sub_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L140-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.zero_sub_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">zero_sub_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.neg_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L144-L147">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.neg_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">neg_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₀</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₀</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₀</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.instSMulOfMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L149-L150">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.instSMulOfMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">instSMulOfMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#SMul">SMul</a> <span class="fn">R</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.smul_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L152-L153">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_apply"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">r</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Data/List/Basic.html#List.map">List.map</a>
    <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">R</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">a</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span>)</span>
    <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L155-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">r</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.smul_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L163-L168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.smul_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">smul_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₀</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R₀</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R₀</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">S</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₀</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R₀</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">S</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₀</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₀</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">r</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">r</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_cons_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L170-L173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#SMul">SMul</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r₁ </span><span class="fn">r₂</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn">r₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₁</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">m</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₁</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r₂</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">m</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l₂</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_cons_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L175-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_cons_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_cons_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">m</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_const_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L180-L183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_const_cons"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_const_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn">M</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn">M</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <span class="fn">0</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn">n</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">r</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">m</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.cons">::ᵣ</a> <span class="fn">l</span>).<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L185-L190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eq_of_eval_eq_eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eq_of_eval_eq_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₁</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₂</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R₁</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R₁</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R₂</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R₂</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R₁</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₂'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R₂</span> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x₁ </span><span class="fn">x₂</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx₁</span> : <span class="fn">x₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx₂</span> : <span class="fn">x₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x₂</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.algebraMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L194-L198">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">algebraMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> <span class="fn">S</span> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">R</span> <span class="fn">M</span></span></div></div><p>Operate on a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Module.NF</a> S M</code> object <code>l</code>, i.e. a list of pairs in <code>S × M</code>, where <code>S</code> is some
commutative semiring, by applying to each <code>S</code>-component the algebra-map from <code>S</code> into a specified
<code>S</code>-algebra <code>R</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap">Mathlib.Tactic.Module.NF.algebraMap</a> <span class="fn">R</span> <span class="fn">l</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Data/List/Basic.html#List.map">List.map</a>
    <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">S</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">M</span>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">s</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">(<a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a> <span class="fn">S</span> <span class="fn">R</span>)</span> <span class="fn">s</span></span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span>)</span>
    <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.NF.algebraMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.NF.eval_algebraMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L200-L206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval_algebraMap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">NF</span>.<span class="name">eval_algebraMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> <span class="fn">S</span> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#SMul">SMul</a> <span class="fn">S</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Action/Defs.html#MulAction">MulAction</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a> <span class="fn">S</span> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">S</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.algebraMap">algebraMap</a> <span class="fn">R</span> <span class="fn">l</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Lists-of-expressions-representing-scalars-and-vectors-and-operations-on-such-lists">Lists of expressions representing scalars and vectors, and operations on such lists <a class="hover-link" href="#Lists-of-expressions-representing-scalars-and-vectors-and-operations-on-such-lists">#</a></h3></div><div class="decl" id="Mathlib.Tactic.Module.qNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L214-L227">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Basic meta-code &quot;normal form&quot; object of the <code>match_scalars</code> and <code>module</code> tactics: a type synonym
for a list of ordered triples comprising expressions representing terms of two types <code>R</code> and <code>M</code>
(where typically <code>M</code> is an <code>R</code>-module), together with a natural number &quot;index&quot;.</p><p>The natural number represents the index of the <code>M</code> term in the <code>AtomM</code> monad: this is not enforced,
but is sometimes assumed in operations.  Thus when items <code>((a₁, x₁), k)</code> and <code>((a₂, x₂), k)</code>
appear in two different <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">Module.qNF</a></code> objects (i.e. with the same <code>ℕ</code>-index <code>k</code>), it is expected that
the expressions <code>x₁</code> and <code>x₂</code> are the same.  It is also expected that the items in a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">Module.qNF</a></code>
list are in strictly increasing order by natural-number index.</p><p>By forgetting the natural number indices, an expression representing a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">Mathlib.Tactic.Module.NF</a></code>
object can be built from a <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">Module.qNF</a></code> object; this construction is provided as
<code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">Mathlib.Tactic.Module.qNF.toNF</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">Mathlib.Tactic.Module.qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> ((<span class="fn">Q(<span class="fn">«$R»</span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">Q(<span class="fn">«$M»</span>)</span>) <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.toNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L233-L239">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">toNF</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> <span class="fn">«$R»</span> <span class="fn">«$M»</span></span>)</span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. a list of <code>(Q($R) × Q($M)) × ℕ</code>s (two <code>Expr</code>s and a natural
number), build an <code>Expr</code> representing an object of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF">NF</a> R M</code> (i.e. <code><a href="../.././Init/Prelude.html#List">List</a> (R × M)</code>) in the
in the obvious way: by forgetting the natural numbers and gluing together the <code>Expr</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF.toNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.onScalar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L241-L246">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">onScalar</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u₁ </span><span class="fn">u₂</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₁</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u₁)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₂</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u₂)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R₁</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">Q(<span class="fn"><span class="fn">«$R₁»</span> → <span class="fn">«$R₂»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R₂</span> <span class="fn">M</span></span></div></div><p>Given <code>l</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R₁ M</code>, i.e. a list of <code>(Q($R₁) × Q($M)) × ℕ</code>s (two <code>Expr</code>s and a natural
number), apply an expression representing a function with domain <code>R₁</code> to each of the <code>Q($R₁)</code>
components.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar">onScalar</a></span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Data/List/Basic.html#List.map">List.map</a>
    <span class="fn">(fun (<span class="fn">x</span> : (<span class="fn">Q(<span class="fn">«$R₁»</span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">Q(<span class="fn">«$M»</span>)</span>) <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Nat">ℕ</a>) =&gt;
      <span class="fn">match <span class="fn">x</span> with
      | <a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">a</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">k</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <a href="../.././Init/Prelude.html#Prod.mk">(</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">q(<span class="fn"><span class="fn">«$f»</span> <span class="fn">«$a»</span></span>)</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">)</a><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">k</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span>)</span>
    <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF.onScalar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.add"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L248-L269">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">«$R»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) × Q($M)) × ℕ</code>s (two <code>Expr</code>s
and a natural number), construct another such term <code>l</code>, which will have the property that in the
<code>$R</code>-module <code>$M</code>, the sum of the &quot;linear combinations&quot; represented by <code>l₁</code> and <code>l₂</code> is the linear
combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>l₁</code> and <code>l₂</code> are in strictly increasing order
by <code>ℕ</code>-component, and that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code> appear in <code>l₁</code>, <code>l₂</code> respectively with
the same <code>ℕ</code>-component <code>k</code>, then the expressions <code>x₁</code> and <code>x₂</code> are equal.</p><p>The construction is as follows: merge the two lists, except that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code>
appear in <code>l₁</code>, <code>l₂</code> respectively with the same <code>ℕ</code>-component <code>k</code>, then contribute a term
<code>(a₁ + a₂, x₁)</code> to the output list with <code>ℕ</code>-component <code>k</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add">Mathlib.Tactic.Module.qNF.add</a> <span class="fn">iR</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">x✝</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add">Mathlib.Tactic.Module.qNF.add</a> <span class="fn">iR</span> <span class="fn">x✝</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF.add" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.mkAddProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L271-L290">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkAddProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">«$R»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iRM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">«$R»</span> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add">add</a> <span class="fn">iR</span> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn">«$a_2»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) × Q($M)) × ℕ</code>s (two <code>Expr</code>s
and a natural number), recursively construct a proof that in the <code>$R</code>-module <code>$M</code>, the sum of the
&quot;linear combinations&quot; represented by <code>l₁</code> and <code>l₂</code> is the linear combination represented by
<code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.add">Module.qNF.add</a> iR l₁ l₁</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof">Mathlib.Tactic.Module.qNF.mkAddProof</a> <span class="fn">iRM</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkAddProof">Mathlib.Tactic.Module.qNF.mkAddProof</a> <span class="fn">iRM</span> <span class="fn">l₁</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF.mkAddProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.sub"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L292-L314">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$R»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span> → <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) × Q($M)) × ℕ</code>s (two <code>Expr</code>s
and a natural number), construct another such term <code>l</code>, which will have the property that in the
<code>$R</code>-module <code>$M</code>, the difference of the &quot;linear combinations&quot; represented by <code>l₁</code> and <code>l₂</code> is the
linear combination represented by <code>l</code>.</p><p>The construction assumes, to be valid, that the lists <code>l₁</code> and <code>l₂</code> are in strictly increasing order
by <code>ℕ</code>-component, and that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code> appear in <code>l₁</code>, <code>l₂</code> respectively with
the same <code>ℕ</code>-component <code>k</code>, then the expressions <code>x₁</code> and <code>x₂</code> are equal.</p><p>The construction is as follows: merge the first list and the negation of the second list, except
that if pairs <code>(a₁, x₁)</code> and <code>(a₂, x₂)</code> appear in <code>l₁</code>, <code>l₂</code> respectively with the same
<code>ℕ</code>-component <code>k</code>, then contribute a term <code>(a₁ - a₂, x₁)</code> to the output list with <code>ℕ</code>-component <code>k</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub">Mathlib.Tactic.Module.qNF.sub</a> <span class="fn">iR</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">x✝</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">x✝</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.onScalar">onScalar</a></span> <span class="fn">q(<a href="../.././Init/Prelude.html#Neg.neg">Neg.neg</a>)</span></span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub">Mathlib.Tactic.Module.qNF.sub</a> <span class="fn">iR</span> <span class="fn">x✝</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF.sub" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.mkSubProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L316-L335">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">mkSubProof</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$R»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iRM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">«$R»</span> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub">sub</a> <span class="fn">iR</span> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">have <span class="fn">a_2</span> := <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
<span class="fn">Q(<span class="fn"><span class="fn">«$a_2»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span></span></span></div></div><p>Given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) × Q($M)) × ℕ</code>s (two <code>Expr</code>s
and a natural number), recursively construct a proof that in the <code>$R</code>-module <code>$M</code>, the difference
of the &quot;linear combinations&quot; represented by <code>l₁</code> and <code>l₂</code> is the linear combination represented by
<code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.sub">Module.qNF.sub</a> iR l₁ l₁</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof">Mathlib.Tactic.Module.qNF.mkSubProof</a> <span class="fn">iR</span> <span class="fn">iM</span> <span class="fn">iRM</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.mkSubProof">Mathlib.Tactic.Module.qNF.mkSubProof</a> <span class="fn">iR</span> <span class="fn">iM</span> <span class="fn">iRM</span> <span class="fn">l₁</span> <a href="../.././Init/Prelude.html#List.nil">[</a><a href="../.././Init/Prelude.html#List.nil">]</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<span class="fn">⋯</span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF.mkSubProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.qNF.matchRings"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L341-L380">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.matchRings"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">qNF</span>.<span class="name">matchRings</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u₁</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₁</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u₁)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">iR₁</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">«$R₁»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iRM₁</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">«$R₁»</span> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u₂</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R₂</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u₂)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iR₂</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">«$R₂»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">iRM₂</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">«$R₂»</span> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R₁</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R₂</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">Q(<span class="fn">«$R₂»</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>
  <span class="fn">((<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>) ×
    <span class="fn">(<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>) ×
      <span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">«$R»</span></span>)</span>) ×
        <span class="fn">(<span class="fn">x_1</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">«$R»</span> <span class="fn">«$M»</span></span>)</span>) ×
          <span class="fn">((<span class="fn">l₁'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>) ×
              <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
              <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₁'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
              <span class="fn">Q(<span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span></span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a>             <span class="fn">((<span class="fn">l₂'</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>) ×
                <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
                <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₂'</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
                <span class="fn">Q(<span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span></span>)</span> <a href="../.././Init/Prelude.html#Prod">×</a>               <span class="fn">(<span class="fn">r'</span> : <span class="fn">Q(<span class="fn">«$R»</span>)</span>) × <span class="fn">Q(<span class="fn">«$r'»</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">«$x»</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$r»</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">«$x»</span>)</span></span></span></span></span>)</span></span></div></div><p>Given an expression <code>M</code> representing a type which is an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code> and a module over <em>two</em>
semirings <code>R₁</code> and <code>R₂</code>, find the &quot;bigger&quot; of the two semirings.  That is, we assume that it will
turn out to be the case that either (1) <code>R₁</code> is an <code>R₂</code>-algebra and the <code>R₂</code> scalar action on <code>M</code> is
induced from <code>R₁</code>'s scalar action on <code>M</code>, or (2) vice versa; we return the semiring <code>R₁</code> in the
first case and <code>R₂</code> in the second case.</p><p>Moreover, given expressions representing particular scalar multiplications of <code>R₁</code> and/or <code>R₂</code> on
<code>M</code> (a <code><a href="../.././Init/Prelude.html#List">List</a> (R₁ × M)</code>, a <code><a href="../.././Init/Prelude.html#List">List</a> (R₂ × M)</code>, a pair <code>(r, x) : R₂ × M</code>), bump these up to the &quot;big&quot;
ring by applying the algebra-map where needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.qNF.matchRings" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Core-of-the-module-tactic">Core of the <code>module</code> tactic <a class="hover-link" href="#Core-of-the-module-tactic">#</a></h3></div><div class="decl" id="Mathlib.Tactic.Module.parse"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L388-L464">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.parse"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">parse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$M»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a>
  <span class="fn">((<span class="fn">u</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>) ×
    <span class="fn">(<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>) ×
      <span class="fn">(<span class="fn">iR</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">«$R»</span></span>)</span>) ×
        <span class="fn">(<span class="fn">x_1</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">«$R»</span> <span class="fn">«$M»</span></span>)</span>) ×
          <span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>) ×
            <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
            <span class="fn">Q(<span class="fn">«$x»</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span></span></span></span></span>)</span></span></div></div><p>The main algorithm behind the <code>match_scalars</code> and <code>module</code> tactics: partially-normalizing an
expression in an additive commutative monoid <code>M</code> into the form c1 • x1 + c2 • x2 + ... c_k • x_k,
where x1, x2, ... are distinct atoms in <code>M</code>, and c1, c2, ... are scalars. The scalar type of the
expression is not pre-determined: instead it starts as <code>ℕ</code> (when each atom is initially given a
scalar <code>(1:ℕ)</code>) and gets bumped up into bigger semirings when such semirings are encountered.</p><p>It is assumed that there is a &quot;linear order&quot; on all the semirings which appear in the expression:
for any two semirings <code>R</code> and <code>S</code> which occur, we have either <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>).</p><p>TODO: implement a variant in which a semiring <code>R</code> is provided by the user, and the assumption is
instead that for any semiring <code>S</code> which occurs, we have <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>. The PR <a href="https://github.com/leanprover-community/mathlib4/pull/16984">https://github.com/leanprover-community/mathlib4/pull/16984</a> provides a
proof-of-concept implementation of this variant, but it would need some polishing before joining
Mathlib.</p><p>Possible TODO, if poor performance on large problems is witnessed: switch the implementation from
<code>AtomM</code> to <code>CanonM</code>, per the discussion
<a href="https://github.com/leanprover-community/mathlib4/pull/16593/files#r1749623191">https://github.com/leanprover-community/mathlib4/pull/16593/files#r1749623191</a></p></div></div><div class="decl" id="Mathlib.Tactic.Module.reduceCoefficientwise"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L466-L506">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.reduceCoefficientwise"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">reduceCoefficientwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u </span><span class="fn">v</span> : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <span class="fn">Q(<a href="../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x✝</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">«$M»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x✝¹</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">«$R»</span></span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">iRM</span> : <span class="fn">Q(<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">«$R»</span> <span class="fn">«$M»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> <span class="fn">R</span> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>
  (<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span> <a href="../.././Init/Prelude.html#Prod">×</a>     <span class="fn">have <span class="fn">a</span> := <span class="fn"><span class="fn">l₂</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
    <span class="fn">have <span class="fn">a_1</span> := <span class="fn"><span class="fn">l₁</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF.toNF">toNF</a></span>;
    <span class="fn">Q(<span class="fn"><span class="fn">«$a_1»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">«$a»</span>.<a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.NF.eval">eval</a></span>)</span></span></span>)</span></div></div><p>Given expressions <code>R</code> and <code>M</code> representing types such that <code>M</code>'s is a module over <code>R</code>'s, and
given two terms <code>l₁</code>, <code>l₂</code> of type <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.qNF">qNF</a> R M</code>, i.e. lists of <code>(Q($R) × Q($M)) × ℕ</code>s (two <code>Expr</code>s
and a natural number), construct a list of new goals: that the <code>R</code>-coefficient of an <code>M</code>-atom which
appears in only one list is zero, and that the <code>R</code>-coefficients of an <code>M</code>-atom which appears in both
lists are equal.  Also construct (dependent on these new goals) a proof that the &quot;linear
combinations&quot; represented by <code>l₁</code> and <code>l₂</code> are equal in <code>M</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.Module.matchScalarsAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L508-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalarsAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalarsAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><p>This is an auxiliary function which produces slightly awkward goals in <code>R</code>; they are later cleaned
up by the function <code><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess">Mathlib.Tactic.Module.postprocess</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.matchScalarsAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.algebraMapThms"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L553-L556">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.algebraMapThms"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">algebraMapThms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Lemmas used to post-process the result of the <code>match_scalars</code> and <code>module</code> tactics by converting
the <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code> operations which (which proliferate in the constructed scalar goals) to more
familiar forms: <code>ℕ</code>, <code>ℤ</code> and <code>ℚ</code> casts.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.algebraMapThms">Mathlib.Tactic.Module.algebraMapThms</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#List.toArray">#[</a><span class="fn">`eq_natCast</span><a href="../.././Init/Prelude.html#List.cons">,</a> <span class="fn">`eq_intCast</span><a href="../.././Init/Prelude.html#List.cons">,</a> <span class="fn">`eq_ratCast</span><a href="../.././Init/Prelude.html#List.toArray">]</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.algebraMapThms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.postprocess"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L558-L574">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.postprocess"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">postprocess</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span></div></div><p>Postprocessing for the scalar goals constructed in the <code>match_scalars</code> and <code>module</code> tactics.
These goals feature a proliferation of <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code> operations (because the scalars start in <code>ℕ</code> and
get successively bumped up by <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code>s as new semirings are encountered), so we reinterpret the
most commonly occurring <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code>s (those out of <code>ℕ</code>, <code>ℤ</code> and <code>ℚ</code>) into their standard forms
(<code>ℕ</code>, <code>ℤ</code> and <code>ℚ</code> casts) and then try to disperse the casts using the various <code>push_cast</code> lemmas.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.postprocess" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.matchScalars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L576-L581">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.matchScalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">matchScalars</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.matchScalars" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.tacticMatch_scalars"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L583-L615">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticMatch_scalars</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><p>For example, this produces the goal <code>⊢ a * 1 + b * 1 = (b + a) * 1</code>:</p><pre><code>example [AddCommMonoid M] [Semiring R] [Module R M] (a b : R) (x : M) :
    a • x + b • x = (b + a) • x := by
  match_scalars
</code></pre><p>This produces the two goals <code>⊢ a * (a * 1) + b * (b * 1) = 1</code> (from the <code>x</code> atom) and
<code>⊢ a * -(b * 1) + b * (a * 1) = 0</code> (from the <code>y</code> atom):</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a b : R) (x : M) :
    a • (a • x - b • y) + (b • a • y + b • b • x) = x := by
  match_scalars
</code></pre><p>This produces the goal <code>⊢ -2 * (a * 1) = a * (-2 * 1)</code>:</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a : R) (x : M) :
    -(2:R) • a • x = a • (-2:ℤ) • x  := by
  match_scalars
</code></pre><p>The scalar type for the goals produced by the <code>match_scalars</code> tactic is the largest scalar type
encountered; for example, if <code>ℕ</code>, <code>ℚ</code> and a characteristic-zero field <code>K</code> all occur as scalars, then
the goals produced are equalities in <code>K</code>.  A variant of <code>push_cast</code> is used internally in
<code>match_scalars</code> to interpret scalars from the other types in this largest type.</p><p>If the set of scalar types encountered is not totally ordered (in the sense that for all rings <code>R</code>,
<code>S</code> encountered, it holds that either <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="../.././Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>), then the <code>match_scalars</code>
tactic fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars">Mathlib.Tactic.Module.tacticMatch_scalars</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Module.tacticMatch_scalars</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;match_scalars&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.tacticMatch_scalars" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Module.tacticModule"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Module.lean#L617-L647">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Module</span>.<span class="name">tacticModule</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some commutative semiring <code>R</code>, and prove
the goal by checking that the LHS- and RHS-coefficients of each atom are the same up to
ring-normalization in <code>R</code>.</p><p>(If the proofs of coefficient-wise equality will require more reasoning than just
ring-normalization, use the tactic <code>match_scalars</code> instead, and then prove coefficient-wise equality
by hand.)</p><p>Example uses of the <code>module</code> tactic:</p><pre><code>example [AddCommMonoid M] [CommSemiring R] [Module R M] (a b : R) (x : M) :
    a • x + b • x = (b + a) • x := by
  module

example [AddCommMonoid M] [Field K] [CharZero K] [Module K M] (x : M) :
    (2:K)⁻¹ • x + (3:K)⁻¹ • x + (6:K)⁻¹ • x = x := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a : R) (v w : M) :
    (1 + a ^ 2) • (v + w) - a • (a • v - w) = v + (1 + a + a ^ 2) • w := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a b μ ν : R) (x y : M) :
    (μ - ν) • a • x = (a • μ • x + b • ν • y) - ν • (a • x + b • y) := by
  module
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule">Mathlib.Tactic.Module.tacticModule</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Module.tacticModule</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;module&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Module.tacticModule" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
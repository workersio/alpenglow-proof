<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Abel</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Abel";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Tactic/TryThis.html">Mathlib.Tactic.TryThis</a></li><li><a href="../.././Mathlib/Util/AtLocation.html">Mathlib.Util.AtLocation</a></li><li><a href="../.././Mathlib/Tactic/NormNum/Basic.html">Mathlib.Tactic.NormNum.Basic</a></li><li><a href="../.././Mathlib/Util/AtomM/Recurse.html">Mathlib.Util.AtomM.Recurse</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Abel" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.mkContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkContext</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context.app"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">app</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.Context.mkApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">mkApp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.addG"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">addG</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.iapp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">iapp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.mkTerm"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.intToExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">intToExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instInhabitedNormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.e"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">e</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.instCoeNormalExprExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instCoeNormalExprExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.term'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">term'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.zero'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">zero'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.const_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.const_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_const</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_constg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_constg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_term</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_termg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAdd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalNeg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.zero_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atomg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atomg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_atom_pfg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pfg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_sub</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.unfold_zsmul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_zsmul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smulg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_smul_upcast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul_upcast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_addg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_addg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.subst_into_negg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_negg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalSMul'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">isAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abel1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1!</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.term_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.termg_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.NormalExpr.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">isAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.AbelMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelMode</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.AbelNF.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelNF</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.elabAbelNFConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.cleanup"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">cleanup</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.evalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNF</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.tacticAbel_nf!__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel_nf!__</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.elabAbelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.convAbel_nf!_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel_nf!_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.tacticAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel!</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.abelConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelConv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Abel.convAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel!</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-abel-tactic">The <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic <a class="hover-link" href="#The-abel-tactic">#</a></h1><p>Evaluate expressions in the language of additive, commutative monoids and groups.</p></div><div class="decl" id="Mathlib.Tactic.Abel.abel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L27-L58">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L60-L75">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a></code> for a call to <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><p>Stores a few options for this call, and caches some common subexpressions
such as typeclass instances and <code>0 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Abel.Context.mk"><li id="Mathlib.Tactic.Abel.Context.α" class="structure_field"><div class="structure_field_info">α : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The type of the ambient additive commutative group or monoid.</p></div></li><li id="Mathlib.Tactic.Abel.Context.univ" class="structure_field"><div class="structure_field_info">univ : <a href="../.././Lean/Level.html#Lean.Level">Lean.Level</a></div><div class="structure_field_doc"><p>The universe level for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code>.</p></div></li><li id="Mathlib.Tactic.Abel.Context.α0" class="structure_field"><div class="structure_field_info">α0 : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The expression representing <code>0 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code>.</p></div></li><li id="Mathlib.Tactic.Abel.Context.isGroup" class="structure_field"><div class="structure_field_info">isGroup : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Specify whether we are in an additive commutative group or an additive commutative monoid.</p></div></li><li id="Mathlib.Tactic.Abel.Context.inst" class="structure_field"><div class="structure_field_info">inst : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code> or <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></code> expression.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.mkContext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L77-L87">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkContext"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkContext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a></span></div></div><p>Populate a <code>context</code> object for evaluating <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.mkContext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L89-L92">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The monad for <code>Abel</code> contains, in addition to the <code>AtomM</code> state,
some information about the current type we are working over, so that we can consistently
use group lemmas or monoid lemmas as appropriate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">Mathlib.Tactic.Abel.M</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Mathlib.Tactic.Abel.Context</a> <a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">Mathlib.Tactic.AtomM</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.M" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context.app"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L94-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">app</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inst</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Apply the function <code>n : ∀ {α} [inst : AddWhatever α], _</code> to the
implicit parameters in the context, and the given list of arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app">app</a></span> <span class="fn">n</span> <span class="fn">inst</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Expr.html#Lean.mkAppN">Lean.mkAppN</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr.const">Lean.Expr.const</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#List.cons">[</a><span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ">univ</a></span><a href="../.././Init/Prelude.html#List.cons">]</a>)</span>.<a href="../.././Lean/Expr.html#Lean.Expr.app">app</a></span> <span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></span>)</span>.<a href="../.././Lean/Expr.html#Lean.Expr.app">app</a></span> <span class="fn">inst</span>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.Context.app" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.Context.mkApp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L99-L106">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">Context</span>.<span class="name">mkApp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context">Context</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">inst</span> : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Apply the function <code>n : ∀ {α} [inst α], _</code> to the implicit parameters in the
context, and the given list of arguments.</p><p>Compared to <code>context.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app">app</a></code>, this takes the name of the typeclass, rather than an
inferred typeclass instance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.mkApp">mkApp</a></span> <span class="fn">n</span> <span class="fn">inst</span> <span class="fn">l</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../.././Lean/Meta/SynthInstance.html#Lean.Meta.synthInstance">Lean.Meta.synthInstance</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Lean/Expr.html#Lean.Expr.const">Lean.Expr.const</a> <span class="fn">inst</span> <a href="../.././Init/Prelude.html#List.cons">[</a><span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.univ">univ</a></span><a href="../.././Init/Prelude.html#List.cons">]</a>)</span>.<a href="../.././Lean/Expr.html#Lean.Expr.app">app</a></span> <span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α">α</a></span>)</span></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app">app</a></span> <span class="fn">n</span> <span class="fn">__do_lift</span> <span class="fn">l</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.Context.mkApp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.addG"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L108-L115">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">addG</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Add the letter &quot;g&quot; to the end of the name, e.g. turning <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a></code> into <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a></code>.</p><p>This is used to choose between declarations taking <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code> and those
taking <code><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a></code> instances.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG">Mathlib.Tactic.Abel.addG</a> <span class="fn">(<span class="fn"><span class="fn">p</span>.<a href="../.././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../.././Init/Prelude.html#Lean.Name.str">str</a></span> (<span class="fn">s</span> <a href="../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">&quot;g&quot;</span>)</span></li><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG">Mathlib.Tactic.Abel.addG</a> <span class="fn">x✝</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.addG" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.iapp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L117-L123">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">iapp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Apply the function <code>n : ∀ {α} [AddComm{Monoid,Group} α]</code> to the given list of arguments.</p><p>Will use the <code>AddComm{Monoid,Group}</code> instance that has been cached in the context.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp">Mathlib.Tactic.Abel.iapp</a> <span class="fn">n</span> <span class="fn">xs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">c</span> ← <a href="../.././Init/Prelude.html#MonadReader.read">read</a>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.app">app</a></span> (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup">isGroup</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.addG">Mathlib.Tactic.Abel.addG</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">n</span>) <span class="fn"><span class="fn">c</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.inst">inst</a></span> <span class="fn">xs</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.iapp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L125-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n • x + a</code> in an additive commutative monoid.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">Mathlib.Tactic.Abel.term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.term" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.termg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L127-L128">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n • x + a</code> in an additive commutative group.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">Mathlib.Tactic.Abel.termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.termg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.mkTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L130-L131">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">mkTerm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n </span><span class="fn">x </span><span class="fn">a</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Evaluate a term with coefficient <code>n</code>, atom <code>x</code> and successor terms <code>a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm">Mathlib.Tactic.Abel.mkTerm</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.iapp">Mathlib.Tactic.Abel.iapp</a> <span class="fn">`Mathlib.Tactic.Abel.term</span> <a href="../.././Init/Prelude.html#List.toArray">#[</a><span class="fn">n</span><a href="../.././Init/Prelude.html#List.cons">,</a> <span class="fn">x</span><a href="../.././Init/Prelude.html#List.cons">,</a> <span class="fn">a</span><a href="../.././Init/Prelude.html#List.toArray">]</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.mkTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.intToExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L133-L135">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">intToExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Interpret an integer as a coefficient to a term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.intToExpr">Mathlib.Tactic.Abel.intToExpr</a> <span class="fn">n</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../.././Init/Prelude.html#MonadReader.read">read</a>
  <span class="fn"><a href="../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> (<a href="../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.isGroup">isGroup</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn">`Int</span> <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn">`Nat</span>))</span>.<a href="../.././Mathlib/Lean/Expr/Basic.html#Lean.Expr.ofInt">ofInt</a></span> <span class="fn">n</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.intToExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L137-L145">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>A normal form for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.
Expressions are represented as a list of terms of the form <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a> = n • x</code>,
where <code>n : ℤ</code> and <code>x</code> is an arbitrary element of the additive commutative monoid or group.
We explicitly track the <code>Expr</code> forms of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> and <code>n</code>, even though they could be reconstructed,
for efficiency.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Abel.NormalExpr.zero">zero<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></li><li class="constructor" id="Mathlib.Tactic.Abel.NormalExpr.nterm">nterm<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a>)</span></span>
 : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.instInhabitedNormalExpr.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L145-L145">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default">Mathlib.Tactic.Abel.instInhabitedNormalExpr.default</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <a href="../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.instInhabitedNormalExpr.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.instInhabitedNormalExpr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L145-L145">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instInhabitedNormalExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr">Mathlib.Tactic.Abel.instInhabitedNormalExpr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instInhabitedNormalExpr.default">Mathlib.Tactic.Abel.instInhabitedNormalExpr.default</a> <a href="../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.e"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L147-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">e</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Extract the expression from a normal form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <span class="fn">e</span>)</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm">Mathlib.Tactic.Abel.NormalExpr.nterm</a> <span class="fn">e</span> <span class="fn">n</span> <span class="fn">x_1</span> <span class="fn">a</span>)</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.e" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.instCoeNormalExprExpr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L152-L152">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">instCoeNormalExprExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.instCoeNormalExprExpr">Mathlib.Tactic.Abel.instCoeNormalExprExpr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Coe.html#Coe.mk">{</a> <span class="fn">coe</span> := <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">Mathlib.Tactic.Abel.NormalExpr.e</a> <a href="../.././Init/Coe.html#Coe.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.term'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L154-L156">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">term'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></span></div></div><p>Construct the normal form representing a single term.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.term'">Mathlib.Tactic.Abel.NormalExpr.term'</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.mkTerm">Mathlib.Tactic.Abel.mkTerm</a> <span class="fn"><span class="fn">n</span>.1</span> <span class="fn"><span class="fn">x</span>.2</span> <span class="fn"><span class="fn">a</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></span></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm">Mathlib.Tactic.Abel.NormalExpr.nterm</a> <span class="fn">__do_lift</span> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.term'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.zero'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L158-L159">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">zero'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a></span></div></div><p>Construct the normal form representing zero.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero'">Mathlib.Tactic.Abel.NormalExpr.zero'</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../.././Init/Prelude.html#MonadReader.read">read</a>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.Context.α0">α0</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.zero'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.const_add_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L163-L165">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.const_add_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L167-L169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.const_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">const_add_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">k</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_const"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L171-L173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_const"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_const</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">k </span><span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_constg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L175-L177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_constg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_constg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a </span><span class="fn">k </span><span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">k</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L179-L181">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n₁</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a₁</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n₂</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">n₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n₁</span> <span class="fn">x</span> <span class="fn">a₁</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n₂</span> <span class="fn">x</span> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_add_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L183-L187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_add_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_add_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n₁</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a₁</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n₂</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">n₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">a₁</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n₁</span> <span class="fn">x</span> <span class="fn">a₁</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n₂</span> <span class="fn">x</span> <span class="fn">a₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_term"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L189-L190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_term"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_term</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">0</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_termg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L192-L193">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_termg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_termg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">0</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalAdd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L195-L221">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAdd</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> → <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> (<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Interpret the sum of two expressions in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L223-L225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">n</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalNeg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L227-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalNeg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> (<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Interpret a negated expression in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalNeg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.smul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L240-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A synonym for <code>•</code>, used internally in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">Mathlib.Tactic.Abel.smul</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.smul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.smulg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L242-L243">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A synonym for <code>•</code>, used internally in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">Mathlib.Tactic.Abel.smulg</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.smulg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L245-L246">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">c</span> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.zero_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L248-L249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.zero_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">zero_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">c</span> <span class="fn">0</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L251-L254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">c</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">c</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">c</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L256-L259">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n'</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">c</span> <a href="../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n'</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">c</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">c</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n'</span> <span class="fn">x</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalSMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L261-L270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> (<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div></div><p>Auxiliary function for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'">evalSMul'</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalSMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L272-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">1</span> <span class="fn">x</span> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atomg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L273-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atomg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atomg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">1</span> <span class="fn">x</span> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L274-L275">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">1</span> <span class="fn">x'</span> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_atom_pfg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L276-L277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_atom_pfg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_atom_pfg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">1</span> <span class="fn">x'</span> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L279-L286">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalAtom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> (<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div></div><p>Interpret an expression as an atom for <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code>'s normal form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_sub"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L288-L289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_sub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_sub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#SubtractionMonoid">SubtractionMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L291-L292">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L294-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">(<a href="../.././Init/Data/Int/Basic.html#Int.ofNat">Int.ofNat</a> <span class="fn">n</span>)</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">↑<span class="fn">n</span></span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.unfold_zsmul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L297-L298">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.unfold_zsmul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">unfold_zsmul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">n</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L300-L302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tl</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tr </span><span class="fn">t</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">tl</span> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">l</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smulg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L304-L306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smulg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tl</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tr </span><span class="fn">t</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">tl</span> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">l</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_smul_upcast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L308-L311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_smul_upcast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tl</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">zl</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">tr </span><span class="fn">t</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl₁</span> : <span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl₂</span> : <span class="fn">↑<span class="fn">tl</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">zl</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> <span class="fn">zl</span> <span class="fn">tr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> <span class="fn">l</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L313-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l </span><span class="fn">r </span><span class="fn">tl </span><span class="fn">tr </span><span class="fn">t</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn">tl</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">tr</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_addg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L317-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_addg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_addg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l </span><span class="fn">r </span><span class="fn">tl </span><span class="fn">tr </span><span class="fn">t</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prl</span> : <span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tl</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prr</span> : <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">tr</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <span class="fn">tl</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">tr</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">r</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.subst_into_negg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L321-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_negg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">subst_into_negg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">ta </span><span class="fn">t</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pra</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">ta</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">prt</span> : <a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">ta</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalSMul'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L325-L353">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalSMul'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalSMul'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">eval</span> : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> (<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">is_smulg</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">orig </span><span class="fn">e₁ </span><span class="fn">e₂</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> (<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div></div><p>Normalize a term <code>orig</code> of the form <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> e₁ e₂</code> or <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> e₁ e₂</code>.
Normalized terms use <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a></code> for monoids and <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> for groups,
so there are actually four cases to handle:</p><ul>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a></code> in a monoid just simplifies the pieces using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul">subst_into_smul</a></code></li>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> in a group just simplifies the pieces using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smulg">subst_into_smulg</a></code></li>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smul">smul</a> a b</code> in a group requires converting <code>a</code> from a nat to an int and
then simplifying <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a> ↑a b</code> using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.subst_into_smul_upcast">subst_into_smul_upcast</a></code></li>
<li>Using <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> in a monoid is impossible (or at least out of scope),
because you need a group argument to write a <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.smulg">smulg</a></code> term</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalSMul'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.eval"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L355-L399">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">eval</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.M">M</a> (<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div></div><p>Evaluate an expression into its <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form, by recursing into subexpressions.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.isAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L401-L422">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">isAtom</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Determine whether <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> will be handled as an atom by the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic. The <code>match</code> in this
function should be preserved to be parallel in case-matching to that in the
<code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval">Mathlib.Tactic.Abel.eval</a></code> metaprogram.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.isAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L424-L439">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abel1!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L442-L442">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abel1!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">Mathlib.Tactic.Abel.abel1!</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.abel1!</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel1!&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abel1!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.term_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L444-L444">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">term_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.term">term</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Abel.termg_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L445-L446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">termg_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommGroup">AddCommGroup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.termg">termg</a> <span class="fn">n</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a</span></div></div><p>A type synonym used by <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> to represent <code>n • x + a</code> in an additive commutative group.</p></div></div><div class="decl" id="Mathlib.Tactic.Abel.NormalExpr.isAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L448-L451">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">NormalExpr</span>.<span class="name">isAtom</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> → <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>True if this represents an atomic expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.nterm">Mathlib.Tactic.Abel.NormalExpr.nterm</a> <span class="fn">e</span> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">fst</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">1</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <span class="fn">x_1</span> <span class="fn">(<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.zero">Mathlib.Tactic.Abel.NormalExpr.zero</a> <span class="fn">e_1</span>)</span>)</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom">isAtom</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.isAtom">isAtom</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.NormalExpr.isAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.AbelMode"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L453-L458">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelMode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The normalization style for <code>abel_nf</code>.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Abel.AbelMode.term">term : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">AbelMode</a><div class="inductive_ctor_doc"><p>The default form</p></div></li><li class="constructor" id="Mathlib.Tactic.Abel.AbelMode.raw">raw : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">AbelMode</a><div class="inductive_ctor_doc"><p>Raw form: the representation <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> uses internally.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.AbelMode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.AbelNF.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L460-L463">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">AbelNF</span>.<span class="name">Config</span></a></span><span class="decl_extends">extends</span> <a href="../.././Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config">Mathlib.Tactic.AtomM.Recurse.Config</a><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Configuration for <code>abel_nf</code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Abel.AbelNF.Config.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config.red">red</a> : <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">Lean.Meta.TransparencyMode</a></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Util/AtomM/Recurse.html#Mathlib.Tactic.AtomM.Recurse.Config.zetaDelta">zetaDelta</a> : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Mathlib.Tactic.Abel.AbelNF.Config.mode" class="structure_field"><div class="structure_field_info">mode : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelMode">AbelMode</a></div><div class="structure_field_doc"><p>The normalization style.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Abel.AbelNF.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.elabAbelNFConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L465-L466">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConfig"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">AbelNF.Config</a></span></span></div></div><p>Function elaborating <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">AbelNF.Config</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.elabAbelNFConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.cleanup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L468-L479">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.cleanup"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">cleanup</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.AbelNF.Config">AbelNF.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></div></div><p>A cleanup routine, which simplifies expressions in <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form to a more human-friendly
format.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.cleanup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.evalExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L481-L493">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.evalExpr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">evalExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <a href="../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Lean.Meta.Simp.Result</a></span></div></div><p>Evaluate an expression into its <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> normal form.</p><p>This is a variant of <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.eval">Mathlib.Tactic.Abel.eval</a></code>, the main driver of the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic.
It differs in</p><ul>
<li>outputting a <code>Simp.Result</code>, rather than a <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr">NormalExpr</a> × Expr</code>;</li>
<li>throwing an error if the expression <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.NormalExpr.e">e</a></code> is an atom for the <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> tactic.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.evalExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNF"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L497-L504">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNF"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNF</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelNF" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.tacticAbel_nf!__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L507-L508">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel_nf!__"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel_nf!__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.tacticAbel_nf!__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelNFConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L510-L511">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelNFConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelNFConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.elabAbelNFConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L513-L522">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.elabAbelNFConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">elabAbelNFConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic">Lean.Elab.Tactic.Tactic</a></div></div><p>Elaborator for the <code>abel_nf</code> tactic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.elabAbelNFConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.convAbel_nf!_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L525-L525">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel_nf!_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel_nf!_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.convAbel_nf!_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.tacticAbel!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L532-L532">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">tacticAbel!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.tacticAbel!">Mathlib.Tactic.Abel.tacticAbel!</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.tacticAbel!</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel!&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.tacticAbel!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.abelConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L535-L536">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">abelConv</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abelConv">Mathlib.Tactic.Abel.abelConv</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.abelConv</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.abelConv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Abel.convAbel!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Abel.lean#L538-L539">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Abel</span>.<span class="name">convAbel!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for evaluating equations in the language of
<em>additive</em>, commutative monoids and groups.</p><p><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> and its variants work as both tactics and conv tactics.</p><ul>
<li><code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1">abel1</a></code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li>
<li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul>
<li>In tactic mode, <code>abel_nf at h</code> can be used to rewrite in a hypothesis.</li>
<li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul>
<li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li>
<li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li>
<li><code>recursive</code>: if true, <code>abel_nf</code> will also recurse into atoms</li>
</ul>
</li>
</ul>
</li>
<li><code>abel!</code>, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel1!">abel1!</a></code>, <code>abel_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li>
</ul><p>For example:</p><pre><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by <a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a>
</code></pre><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><ul>
<li>In mathlib 3, <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> accepted additional optional arguments:<pre><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre>
It is undecided whether these features should be restored eventually.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.convAbel!">Mathlib.Tactic.Abel.convAbel!</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Abel.convAbel!</span> <span class="fn">1024</span> <span class="fn">(<a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;abel!&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Abel.convAbel!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>We register <code><a href="../.././Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">abel</a></code> with the <code>hint</code> tactic.</p></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.UniformSpace.UniformConvergenceTopology</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.UniformSpace.UniformConvergenceTopology";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">UniformSpace</span>.<span class="name">UniformConvergenceTopology</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Topology/Coherent.html">Mathlib.Topology.Coherent</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html">Mathlib.Topology.UniformSpace.Equiv</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/Pi.html">Mathlib.Topology.UniformSpace.Pi</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/UniformApproximation.html">Mathlib.Topology.UniformSpace.UniformApproximation</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.UniformSpace.UniformConvergenceTopology" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#UniformFun"><span class="name">UniformFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun"><span class="name">UniformOnFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformConvergence.«term_→ᵤ_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ_»</span></a></div><div class="nav_link"><a class="break_within" href="#UniformConvergence.«term_→ᵤ[_]_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ[_]_»</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyUniformFun"><span class="name">instNonemptyUniformFun</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyUniformOnFun"><span class="name">instNonemptyUniformOnFun</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonUniformFun"><span class="name">instSubsingletonUniformFun</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonUniformOnFun"><span class="name">instSubsingletonUniformOnFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.ofFun"><span class="name">UniformFun</span>.<span class="name">ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.ofFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.toFun"><span class="name">UniformFun</span>.<span class="name">toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.toFun"><span class="name">UniformOnFun</span>.<span class="name">toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.toFun_ofFun"><span class="name">UniformFun</span>.<span class="name">toFun_ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.ofFun_toFun"><span class="name">UniformFun</span>.<span class="name">ofFun_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.toFun_ofFun"><span class="name">UniformOnFun</span>.<span class="name">toFun_ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.ofFun_toFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.gen"><span class="name">UniformFun</span>.<span class="name">gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.isBasis_gen"><span class="name">UniformFun</span>.<span class="name">isBasis_gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.basis"><span class="name">UniformFun</span>.<span class="name">basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.filter"><span class="name">UniformFun</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.phi"><span class="name">UniformFun</span>.<span class="name">phi</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.gc"><span class="name">UniformFun</span>.<span class="name">gc</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformCore"><span class="name">UniformFun</span>.<span class="name">uniformCore</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformSpace"><span class="name">UniformFun</span>.<span class="name">uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.topologicalSpace"><span class="name">UniformFun</span>.<span class="name">topologicalSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_uniformity"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_uniformity_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_nhds_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_nhds"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformContinuous_eval"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_eval</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.mem_gen"><span class="name">UniformFun</span>.<span class="name">mem_gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.mono"><span class="name">UniformFun</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.iInf_eq"><span class="name">UniformFun</span>.<span class="name">iInf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.inf_eq"><span class="name">UniformFun</span>.<span class="name">inf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.postcomp_isUniformInducing"><span class="name">UniformFun</span>.<span class="name">postcomp_isUniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.postcomp_isUniformEmbedding"><span class="name">UniformFun</span>.<span class="name">postcomp_isUniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.comap_eq"><span class="name">UniformFun</span>.<span class="name">comap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.postcomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">postcomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.congrRight"><span class="name">UniformFun</span>.<span class="name">congrRight</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.precomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">precomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.congrLeft"><span class="name">UniformFun</span>.<span class="name">congrLeft</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformContinuous_toFun"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.instT2Space"><span class="name">UniformFun</span>.<span class="name">instT2Space</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.tendsto_iff_tendstoUniformly"><span class="name">UniformFun</span>.<span class="name">tendsto_iff_tendstoUniformly</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformEquivProdArrow"><span class="name">UniformFun</span>.<span class="name">uniformEquivProdArrow</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformEquivPiComm"><span class="name">UniformFun</span>.<span class="name">uniformEquivPiComm</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.isClosed_setOf_continuous"><span class="name">UniformFun</span>.<span class="name">isClosed_setOf_continuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformSpace_eq_inf_precomp_of_cover"><span class="name">UniformFun</span>.<span class="name">uniformSpace_eq_inf_precomp_of_cover</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformSpace_eq_iInf_precomp_of_cover"><span class="name">UniformFun</span>.<span class="name">uniformSpace_eq_iInf_precomp_of_cover</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen"><span class="name">UniformOnFun</span>.<span class="name">gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen_eq_preimage_restrict"><span class="name">UniformOnFun</span>.<span class="name">gen_eq_preimage_restrict</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen_mono"><span class="name">UniformOnFun</span>.<span class="name">gen_mono</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.isBasis_gen"><span class="name">UniformOnFun</span>.<span class="name">isBasis_gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformSpace"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.topologicalSpace"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.topologicalSpace_eq"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity_of_basis_aux₁"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₁</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity_of_basis_aux₂"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₂</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity_of_covering_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_covering_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasAntitoneBasis_uniformity"><span class="name">UniformOnFun</span>.<span class="name">hasAntitoneBasis_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.isCountablyGenerated_uniformity"><span class="name">UniformOnFun</span>.<span class="name">isCountablyGenerated_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_nhds_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_nhds"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_restrict"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_restrict</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformity_eq_of_basis"><span class="name">UniformOnFun</span>.<span class="name">uniformity_eq_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformity_eq"><span class="name">UniformOnFun</span>.<span class="name">uniformity_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen_mem_uniformity"><span class="name">UniformOnFun</span>.<span class="name">gen_mem_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.nhds_eq_of_basis"><span class="name">UniformOnFun</span>.<span class="name">nhds_eq_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.nhds_eq"><span class="name">UniformOnFun</span>.<span class="name">nhds_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen_mem_nhds"><span class="name">UniformOnFun</span>.<span class="name">gen_mem_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_ofUniformFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_ofUniformFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformEquivUniformFun"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivUniformFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_ofFun_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_ofFun_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.mono"><span class="name">UniformOnFun</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_eval_of_mem"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_eval_of_mem_sUnion"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval_of_mem_sUnion</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_eval"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.iInf_eq"><span class="name">UniformOnFun</span>.<span class="name">iInf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.inf_eq"><span class="name">UniformOnFun</span>.<span class="name">inf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.comap_eq"><span class="name">UniformOnFun</span>.<span class="name">comap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.postcomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">postcomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.postcomp_isUniformInducing"><span class="name">UniformOnFun</span>.<span class="name">postcomp_isUniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.postcomp_isUniformEmbedding"><span class="name">UniformOnFun</span>.<span class="name">postcomp_isUniformEmbedding</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.congrRight"><span class="name">UniformOnFun</span>.<span class="name">congrRight</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.precomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">precomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.congrLeft"><span class="name">UniformOnFun</span>.<span class="name">congrLeft</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.t2Space_of_covering"><span class="name">UniformOnFun</span>.<span class="name">t2Space_of_covering</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_restrict_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_restrict_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.isUniformInducing_pi_restrict"><span class="name">UniformOnFun</span>.<span class="name">isUniformInducing_pi_restrict</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.continuousAt_eval₂"><span class="name">UniformOnFun</span>.<span class="name">continuousAt_eval₂</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.continuousOn_eval₂"><span class="name">UniformOnFun</span>.<span class="name">continuousOn_eval₂</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.tendsto_iff_tendstoUniformlyOn"><span class="name">UniformOnFun</span>.<span class="name">tendsto_iff_tendstoUniformlyOn</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.continuous_rng_iff"><span class="name">UniformOnFun</span>.<span class="name">continuous_rng_iff</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.instCompleteSpace"><span class="name">UniformOnFun</span>.<span class="name">instCompleteSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformEquivProdArrow"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivProdArrow</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformEquivPiComm"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivPiComm</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.isClosed_setOf_continuous"><span class="name">UniformOnFun</span>.<span class="name">isClosed_setOf_continuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformSpace_eq_inf_precomp_of_cover"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace_eq_inf_precomp_of_cover</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace_eq_iInf_precomp_of_cover</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.instCompleteSpace"><span class="name">UniformFun</span>.<span class="name">instCompleteSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformContinuousOn.comp_tendstoUniformly"><span class="name">UniformContinuousOn</span>.<span class="name">comp_tendstoUniformly</span></a></div><div class="nav_link"><a class="break_within" href="#UniformContinuousOn.comp_tendstoUniformly_eventually"><span class="name">UniformContinuousOn</span>.<span class="name">comp_tendstoUniformly_eventually</span></a></div><div class="nav_link"><a class="break_within" href="#UniformContinuousOn.comp_tendstoUniformlyOn_eventually"><span class="name">UniformContinuousOn</span>.<span class="name">comp_tendstoUniformlyOn_eventually</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Topology-and-uniform-structure-of-uniform-convergence">Topology and uniform structure of uniform convergence <a class="hover-link" href="#Topology-and-uniform-structure-of-uniform-convergence">#</a></h1><p>This files endows <code>α → β</code> with the topologies / uniform structures of</p><ul>
<li>uniform convergence on <code>α</code></li>
<li>uniform convergence on a specified family <code>𝔖</code> of sets of <code>α</code>, also called <code>𝔖</code>-convergence</li>
</ul><p>Since <code>α → β</code> is already endowed with the topologies and uniform structures of pointwise
convergence, we introduce type aliases <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> α β</code> (denoted <code>α →ᵤ β</code>) and
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> α β 𝔖</code> (denoted <code>α →ᵤ[𝔖] β</code>) and we actually endow <em>these</em> with the structures
of uniform and <code>𝔖</code>-convergence respectively.</p><p>Usual examples of the second construction include :</p><ul>
<li>the topology of compact convergence, when <code>𝔖</code> is the set of compacts of <code>α</code></li>
<li>the strong topology on the dual of a topological vector space (TVS) <code>E</code>, when <code>𝔖</code> is the set of
Von Neumann bounded subsets of <code>E</code></li>
<li>the weak-* topology on the dual of a TVS <code>E</code>, when <code>𝔖</code> is the set of singletons of <code>E</code>.</li>
</ul><p>This file contains a lot of technical facts, so it is heavily commented, proofs included!</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a></code>: basis sets for the uniformity of uniform convergence. These are sets
of the form <code>S(V) := {(f, g) | ∀ x : α, (f x, g x) ∈ V}</code> for some <code>V : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (β × β)</code></li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a></code>: uniform structure of uniform convergence. This is the
<code><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a></code> on <code>α →ᵤ β</code> whose uniformity is generated by the sets <code>S(V)</code> for <code>V ∈ 𝓤 β</code>.
We will denote this uniform space as <code>𝒰(α, β, uβ)</code>, both in the comments and as a local notation
in the Lean code, where <code>uβ</code> is the uniform space structure on <code>β</code>.
This is declared as an instance on <code>α →ᵤ β</code>.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a></code>: uniform structure of <code>𝔖</code>-convergence, where
<code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code>. This is the infimum, for <code>S ∈ 𝔖</code>, of the pullback of <code>𝒰 S β</code> by the map of
restriction to <code>S</code>. We will denote it <code>𝒱(α, β, 𝔖, uβ)</code>, where <code>uβ</code> is the uniform space structure
on <code>β</code>.
This is declared as an instance on <code>α →ᵤ[𝔖] β</code>.</li>
</ul><h2 class="markdown-heading" id="Main-statements">Main statements <a class="hover-link" href="#Main-statements">#</a></h2><h3 class="markdown-heading" id="Basic-properties">Basic properties <a class="hover-link" href="#Basic-properties">#</a></h3><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformContinuous_eval">UniformFun.uniformContinuous_eval</a></code>: evaluation is uniformly continuous on <code>α →ᵤ β</code>.</li>
<li><code>UniformFun.t2Space</code>: the topology of uniform convergence on <code>α →ᵤ β</code> is T₂ if
<code>β</code> is T₂.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.tendsto_iff_tendstoUniformly">UniformFun.tendsto_iff_tendstoUniformly</a></code>: <code>𝒰(α, β, uβ)</code> is
indeed the uniform structure of uniform convergence</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_eval_of_mem">UniformOnFun.uniformContinuous_eval_of_mem</a></code>: evaluation at a point contained in a
set of <code>𝔖</code> is uniformly continuous on <code>α →ᵤ[𝔖] β</code></li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.t2Space_of_covering">UniformOnFun.t2Space_of_covering</a></code>: the topology of <code>𝔖</code>-convergence on <code>α →ᵤ[𝔖] β</code> is T₂ if
<code>β</code> is T₂ and <code>𝔖</code> covers <code>α</code></li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.tendsto_iff_tendstoUniformlyOn">UniformOnFun.tendsto_iff_tendstoUniformlyOn</a></code>:
<code>𝒱(α, β, 𝔖 uβ)</code> is indeed the uniform structure of <code>𝔖</code>-convergence</li>
</ul><h3 class="markdown-heading" id="Functoriality-and-compatibility-with-product-of-uniform-spaces">Functoriality and compatibility with product of uniform spaces <a class="hover-link" href="#Functoriality-and-compatibility-with-product-of-uniform-spaces">#</a></h3><p>In order to avoid the need for filter bases as much as possible when using these definitions,
we develop an extensive API for manipulating these structures abstractly. As usual in the topology
section of mathlib, we first state results about the complete lattices of <code><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a></code>s on
fixed types, and then we use these to deduce categorical-like results about maps between two
uniform spaces.</p><p>We only describe these in the harder case of <code>𝔖</code>-convergence, as the names of the corresponding
results for uniform convergence can easily be guessed.</p><h4 class="markdown-heading" id="Order-statements">Order statements <a class="hover-link" href="#Order-statements">#</a></h4><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.mono">UniformOnFun.mono</a></code>: let <code>u₁</code>, <code>u₂</code> be two uniform structures on <code>γ</code> and
<code>𝔖₁ 𝔖₂ : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code>. If <code>u₁ ≤ u₂</code> and <code>𝔖₂ ⊆ 𝔖₁</code> then <code>𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)</code>.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.iInf_eq">UniformOnFun.iInf_eq</a></code>: if <code>u</code> is a family of uniform structures on <code>γ</code>, then
<code>𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)</code>.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.comap_eq">UniformOnFun.comap_eq</a></code>: if <code>u</code> is a uniform structures on <code>β</code> and <code>f : γ → β</code>, then
<code>𝒱(α, γ, 𝔖, comap f u) = comap (fun g ↦ f ∘ g) 𝒱(α, γ, 𝔖, u₁)</code>.</li>
</ul><p>An interesting note about these statements is that they are proved without ever unfolding the basis
definition of the uniform structure of uniform convergence! Instead, we build a
(not very interesting) Galois connection <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc">UniformFun.gc</a></code> and then rely on the Galois
connection API to do most of the work.</p><h4 class="markdown-heading" id="Morphism-statements-unbundled">Morphism statements (unbundled) <a class="hover-link" href="#Morphism-statements-unbundled">#</a></h4><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformContinuous">UniformOnFun.postcomp_uniformContinuous</a></code>: if <code>f : γ → β</code> is uniformly
continuous, then <code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is uniformly continuous.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_isUniformInducing">UniformOnFun.postcomp_isUniformInducing</a></code>: if <code>f : γ → β</code> is a uniform
inducing, then <code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is a uniform inducing.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.precomp_uniformContinuous">UniformOnFun.precomp_uniformContinuous</a></code>: let <code>f : γ → α</code>, <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code>,
<code>𝔗 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set γ)</code>, and assume that <code>∀ T ∈ 𝔗, f '' T ∈ 𝔖</code>. Then, the function
<code>(fun g ↦ g ∘ f) : (α →ᵤ[𝔖] β) → (γ →ᵤ[𝔗] β)</code> is uniformly continuous.</li>
</ul><h4 class="markdown-heading" id="Isomorphism-statements-bundled">Isomorphism statements (bundled) <a class="hover-link" href="#Isomorphism-statements-bundled">#</a></h4><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrRight">UniformOnFun.congrRight</a></code>: turn a uniform isomorphism <code>γ ≃ᵤ β</code> into a uniform isomorphism
<code>(α →ᵤ[𝔖] γ) ≃ᵤ (α →ᵤ[𝔖] β)</code> by post-composing.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrLeft">UniformOnFun.congrLeft</a></code>: turn a bijection <code>e : γ ≃ α</code> such that we have both
<code>∀ T ∈ 𝔗, e '' T ∈ 𝔖</code> and <code>∀ S ∈ 𝔖, e ⁻¹' S ∈ 𝔗</code> into a uniform isomorphism
<code>(γ →ᵤ[𝔗] β) ≃ᵤ (α →ᵤ[𝔖] β)</code> by pre-composing.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivPiComm">UniformOnFun.uniformEquivPiComm</a></code>: the natural bijection between <code>α → Π i, δ i</code>
and <code>Π i, α → δ i</code>, upgraded to a uniform isomorphism between <code>α →ᵤ[𝔖] (Π i, δ i)</code> and
<code>Π i, α →ᵤ[𝔖] δ i</code>.</li>
</ul><h4 class="markdown-heading" id="Important-use-cases">Important use cases <a class="hover-link" href="#Important-use-cases">#</a></h4><ul>
<li>If <code>G</code> is a uniform group, then <code>α →ᵤ[𝔖] G</code> is a uniform group: since <code>(/) : G × G → G</code> is
uniformly continuous, <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformContinuous">UniformOnFun.postcomp_uniformContinuous</a></code> tells us that
<code>((/) ∘ —) : (α →ᵤ[𝔖] G × G) → (α →ᵤ[𝔖] G)</code> is uniformly continuous. By precomposing with
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivProdArrow">UniformOnFun.uniformEquivProdArrow</a></code>, this gives that
<code>(/) : (α →ᵤ[𝔖] G) × (α →ᵤ[𝔖] G) → (α →ᵤ[𝔖] G)</code> is also uniformly continuous</li>
<li>The transpose of a continuous linear map is continuous for the strong topologies: since
continuous linear maps are uniformly continuous and map bounded sets to bounded sets,
this is just a special case of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.precomp_uniformContinuous">UniformOnFun.precomp_uniformContinuous</a></code>.</li>
</ul><h2 class="markdown-heading" id="TODO">TODO <a class="hover-link" href="#TODO">#</a></h2><ul>
<li>Show that the uniform structure of <code>𝔖</code>-convergence is exactly the structure of <code>𝔖'</code>-convergence,
where <code>𝔖'</code> is the <em><strong>noncovering</strong></em> bornology (i.e <em><strong>not</strong></em> what <code><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology">Bornology</a></code> currently refers
to in mathlib) generated by <code>𝔖</code>.</li>
</ul><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>[N. Bourbaki, <em>General Topology, Chapter X</em>][bourbaki1966]</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>uniform convergence</p></div><div class="decl" id="UniformFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L141-L144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun"><span class="name">UniformFun</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u_1 u_2)</div></div><p>The type of functions from <code>α</code> to <code>β</code> equipped with the uniform structure and topology of
uniform convergence. We denote it <code>α →ᵤ β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></li></ul></details><details id="instances-for-list-UniformFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L146-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun"><span class="name">UniformOnFun</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span> → <a href="../../.././foundational_types.html">Type</a> (max u_1 u_2)</span></div></div><p>The type of functions from <code>α</code> to <code>β</code> equipped with the uniform structure and topology of
uniform convergence on some family <code>𝔖</code> of subsets of <code>α</code>. We denote it <code>α →ᵤ[𝔖] β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></li></ul></details><details id="instances-for-list-UniformOnFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformConvergence.«term_→ᵤ_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L152-L152">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformConvergence.«term_→ᵤ_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The type of functions from <code>α</code> to <code>β</code> equipped with the uniform structure and topology of
uniform convergence. We denote it <code>α →ᵤ β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformConvergence.«term_→ᵤ_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformConvergence.«term_→ᵤ[_]_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L154-L154">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformConvergence.«term_→ᵤ[_]_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ[_]_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>The type of functions from <code>α</code> to <code>β</code> equipped with the uniform structure and topology of
uniform convergence on some family <code>𝔖</code> of subsets of <code>α</code>. We denote it <code>α →ᵤ[𝔖] β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformConvergence.«term_→ᵤ[_]_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instNonemptyUniformFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L160-L160">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#instNonemptyUniformFun"><span class="name">instNonemptyUniformFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="instNonemptyUniformOnFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L162-L162">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#instNonemptyUniformOnFun"><span class="name">instNonemptyUniformOnFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div></div></div><div class="decl" id="instSubsingletonUniformFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L164-L165">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#instSubsingletonUniformFun"><span class="name">instSubsingletonUniformFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="instSubsingletonUniformOnFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#instSubsingletonUniformOnFun"><span class="name">instSubsingletonUniformOnFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div></div></div><div class="decl" id="UniformFun.ofFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L170-L172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun"><span class="name">UniformFun</span>.<span class="name">ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Reinterpret <code>f : α → β</code> as an element of <code>α →ᵤ β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">UniformFun.ofFun</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.mk">{</a> <span class="fn">toFun</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span></span>, <span class="fn">invFun</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt; <span class="fn">x</span></span>, <span class="fn">left_inv</span> := <span class="fn">⋯</span>, <span class="fn">right_inv</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.mk">}</a></li></ul></details><details id="instances-for-list-UniformFun.ofFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.ofFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L174-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></div></div><p>Reinterpret <code>f : α → β</code> as an element of <code>α →ᵤ[𝔖] β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.mk">{</a> <span class="fn">toFun</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span></span>, <span class="fn">invFun</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>) =&gt; <span class="fn">x</span></span>, <span class="fn">left_inv</span> := <span class="fn">⋯</span>, <span class="fn">right_inv</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.mk">}</a></li></ul></details><details id="instances-for-list-UniformOnFun.ofFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.toFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L178-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun"><span class="name">UniformFun</span>.<span class="name">toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></div></div><p>Reinterpret <code>f : α →ᵤ β</code> as an element of <code>α → β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">UniformFun.ofFun</a>.<a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.symm">symm</a></span></li></ul></details><details id="instances-for-list-UniformFun.toFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.toFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L182-L184">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun"><span class="name">UniformOnFun</span>.<span class="name">toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></div></div><p>Reinterpret <code>f : α →ᵤ[𝔖] β</code> as an element of <code>α → β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔖</span>)</span>.<a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.symm">symm</a></span></li></ul></details><details id="instances-for-list-UniformOnFun.toFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.toFun_ofFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L186-L186">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun_ofFun"><span class="name">UniformFun</span>.<span class="name">toFun_ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="UniformFun.ofFun_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L187-L187">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun_toFun"><span class="name">UniformFun</span>.<span class="name">ofFun_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="UniformOnFun.toFun_ofFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L188-L188">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun_ofFun"><span class="name">UniformOnFun</span>.<span class="name">toFun_ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">(<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="UniformOnFun.ofFun_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L189-L189">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun_toFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">(<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="UniformFun.gen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L202-L205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen"><span class="name">UniformFun</span>.<span class="name">gen</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></div></div><p>Basis sets for the uniformity of uniform convergence: <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">gen</a> α β V</code> is the set of pairs <code>(f, g)</code>
of functions <code>α →ᵤ β</code> such that <code>∀ x, (f x, g x) ∈ V</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">uv</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a> <span class="fn"><span class="fn">uv</span>.1</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a> <span class="fn"><span class="fn">uv</span>.2</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></li></ul></details><details id="instances-for-list-UniformFun.gen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.isBasis_gen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L207-L214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.isBasis_gen"><span class="name">UniformFun</span>.<span class="name">isBasis_gen</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">𝓑</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.IsBasis">Filter.IsBasis</a> <span class="fn">(fun (<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝓑</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><p>If <code>𝓕</code> is a filter on <code>β × β</code>, then the set of all <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> α β V</code> for
<code>V ∈ 𝓕</code> is a filter basis on <code>(α →ᵤ β) × (α →ᵤ β)</code>. This will only be applied to <code>𝓕 = 𝓤 β</code> when
<code>β</code> is equipped with a <code><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a></code> structure, but it is useful to define it for any filter in
order to be able to state that it has a lower adjoint (see <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc">UniformFun.gc</a></code>).</p></div></div><div class="decl" id="UniformFun.basis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L216-L222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis"><span class="name">UniformFun</span>.<span class="name">basis</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">𝓕</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#FilterBasis">FilterBasis</a> (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></div></div><p>For <code>𝓕 : <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (β × β)</code>, this is the set of all <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> α β V</code> for
<code>V ∈ 𝓕</code> as a bundled <code><a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#FilterBasis">FilterBasis</a></code> over <code>(α →ᵤ β) × (α →ᵤ β)</code>. This will only be applied to
<code>𝓕 = 𝓤 β</code> when <code>β</code> is equipped with a <code><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a></code> structure, but it is useful to define it for
any filter in order to be able to state that it has a lower adjoint
(see <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc">UniformFun.gc</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis">UniformFun.basis</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">⋯</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.IsBasis.filterBasis">filterBasis</a></span></li></ul></details><details id="instances-for-list-UniformFun.basis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.filter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L224-L228">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter"><span class="name">UniformFun</span>.<span class="name">filter</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">𝓕</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></div></div><p>For <code>𝓕 : <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (β × β)</code>, this is the filter generated by the filter basis
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis">UniformFun.basis</a> α β 𝓕</code>. For <code>𝓕 = 𝓤 β</code>, this will be the uniformity of uniform
convergence on <code>α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter">UniformFun.filter</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis">UniformFun.basis</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#FilterBasis.filter">filter</a></span></li></ul></details><details id="instances-for-list-UniformFun.filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.phi"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L233-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.phi"><span class="name">UniformFun</span>.<span class="name">phi</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_5)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_6)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">uvx</span> : (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>) <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.phi">UniformFun.phi</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">uvx</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn"><span class="fn"><span class="fn">uvx</span>.1</span>.1</span> <span class="fn"><span class="fn">uvx</span>.2</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">uvx</span>.1</span>.2</span> <span class="fn"><span class="fn">uvx</span>.2</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-UniformFun.phi" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.gc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L244-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc"><span class="name">UniformFun</span>.<span class="name">gc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/GaloisConnection/Defs.html#GaloisConnection">GaloisConnection</a> <span class="fn">(fun (<span class="fn">𝓐</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.phi">UniformFun.phi</a> <span class="fn">α</span> <span class="fn">β</span>)</span> (<span class="fn">𝓐</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">×ˢ</a> <a href="../../.././Mathlib/Order/Notation.html#Top.top">⊤</a>)</span>)</span>
  <span class="fn">fun (<span class="fn">𝓕</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter">UniformFun.filter</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span></span></span></span></div></div><p>The function <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter">UniformFun.filter</a> α β : <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (β × β) → <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> ((α →ᵤ β) × (α →ᵤ β))</code>
has a lower adjoint <code>l</code> (in the sense of <code><a href="../../.././Mathlib/Order/GaloisConnection/Defs.html#GaloisConnection">GaloisConnection</a></code>). The exact definition of <code>l</code> is not
interesting; we will only use that it exists (in <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.mono">UniformFun.mono</a></code> and
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.iInf_eq">UniformFun.iInf_eq</a></code>) and that
<code>l (Filter.map (Prod.map f f) 𝓕) = <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> (Prod.map ((∘) f) ((∘) f)) (l 𝓕)</code> for each
<code>𝓕 : <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (γ × γ)</code> and <code>f : γ → α</code> (in <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.comap_eq">UniformFun.comap_eq</a></code>).</p></div></div><div class="decl" id="UniformFun.uniformCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L269-L280">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformCore"><span class="name">UniformFun</span>.<span class="name">uniformCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace.Core">UniformSpace.Core</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><p>Core of the uniform structure of uniform convergence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformCore">UniformFun.uniformCore</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace.Core.mkOfBasis">UniformSpace.Core.mkOfBasis</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis">UniformFun.basis</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>)</span> <span class="fn">⋯</span> <span class="fn">⋯</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-UniformFun.uniformCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.uniformSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L282-L285">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace"><span class="name">UniformFun</span>.<span class="name">uniformSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><p>Uniform structure of uniform convergence, declared as an instance on <code>α →ᵤ β</code>.
We will denote it <code>𝒰(α, β, uβ)</code> in the rest of this file.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace.ofCore">UniformSpace.ofCore</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformCore">UniformFun.uniformCore</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></li></ul></details></div></div><div class="decl" id="UniformFun.topologicalSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L287-L289">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.topologicalSpace"><span class="name">UniformFun</span>.<span class="name">topologicalSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><p>Topology of uniform convergence, declared as an instance on <code>α →ᵤ β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.topologicalSpace">UniformFun.topologicalSpace</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details></div></div><div class="decl" id="UniformFun.hasBasis_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L293-L297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_uniformity"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><p>By definition, the uniformity of <code>α →ᵤ β</code> admits the family <code>{(f, g) | ∀ x, (f x, g x) ∈ V}</code>
for <code>V ∈ 𝓤 β</code> as a filter basis.</p></div></div><div class="decl" id="UniformFun.hasBasis_uniformity_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L299-L308">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_uniformity_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">s</span>)</span></div></div><p>The uniformity of <code>α →ᵤ β</code> admits the family <code>{(f, g) | ∀ x, (f x, g x) ∈ V}</code> for <code>V ∈ 𝓑</code> as
a filter basis, for any basis <code>𝓑</code> of <code>𝓤 β</code> (in the case <code>𝓑 = (𝓤 β).as_basis</code> this is true by
definition).</p></div></div><div class="decl" id="UniformFun.hasBasis_nhds_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L310-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_nhds_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">g</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">f</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">g</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">(<span class="fn">s</span> <span class="fn">i</span>)</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></span></div></div><p>For <code>f : α →ᵤ β</code>, <code>𝓝 f</code> admits the family <code>{g | ∀ x, (f x, g x) ∈ V}</code> for <code>V ∈ 𝓑</code> as a filter
basis, for any basis <code>𝓑</code> of <code>𝓤 β</code>.</p></div></div><div class="decl" id="UniformFun.hasBasis_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L317-L321">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_nhds"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt;
  <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">g</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">f</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">g</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">V</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></span></div></div><p>For <code>f : α →ᵤ β</code>, <code>𝓝 f</code> admits the family <code>{g | ∀ x, (f x, g x) ∈ V}</code> for <code>V ∈ 𝓤 β</code> as a
filter basis.</p></div></div><div class="decl" id="UniformFun.uniformContinuous_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L325-L331">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformContinuous_eval"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span>)</span></div></div><p>Evaluation at a fixed point is uniformly continuous on <code>α →ᵤ β</code>.</p></div></div><div class="decl" id="UniformFun.mem_gen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L335-L338">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.mem_gen"><span class="name">UniformFun</span>.<span class="name">mem_gen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">f</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">g</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">V</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a> <span class="fn">f</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a> <span class="fn">g</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span></div></div></div></div><div class="decl" id="UniformFun.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L340-L343">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.mono"><span class="name">UniformFun</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">(@<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span>)</span></span></div></div><p>If <code>u₁</code> and <code>u₂</code> are two uniform structures on <code>γ</code> and <code>u₁ ≤ u₂</code>, then
<code>𝒰(α, γ, u₁) ≤ 𝒰(α, γ, u₂)</code>.</p></div></div><div class="decl" id="UniformFun.iInf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L345-L353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.iInf_eq"><span class="name">UniformFun</span>.<span class="name">iInf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span></span></div></div><p>If <code>u</code> is a family of uniform structures on <code>γ</code>, then
<code>𝒰(α, γ, (⨅ i, u i)) = ⨅ i, 𝒰(α, γ, u i)</code>.</p></div></div><div class="decl" id="UniformFun.inf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L355-L363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.inf_eq"><span class="name">UniformFun</span>.<span class="name">inf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u₁ </span><span class="fn">u₂</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> ⊓ <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span></span></div></div><p>If <code>u₁</code> and <code>u₂</code> are two uniform structures on <code>γ</code>, then
<code>𝒰(α, γ, u₁ ⊓ u₂) = 𝒰(α, γ, u₁) ⊓ 𝒰(α, γ, u₂)</code>.</p></div></div><div class="decl" id="UniformFun.postcomp_isUniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L365-L373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.postcomp_isUniformInducing"><span class="name">UniformFun</span>.<span class="name">postcomp_isUniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span>)</span></div></div><p>Post-composition by a uniform inducing function is
a uniform inducing function for the uniform structures of uniform convergence.</p><p>More precisely, if <code>f : γ → β</code> is uniform inducing,
then <code>(f ∘ ·) : (α →ᵤ γ) → (α →ᵤ β)</code> is uniform inducing.</p></div></div><div class="decl" id="UniformFun.postcomp_isUniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L375-L384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.postcomp_isUniformEmbedding"><span class="name">UniformFun</span>.<span class="name">postcomp_isUniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span>)</span></div></div><p>Post-composition by a uniform embedding is
a uniform embedding for the uniform structures of uniform convergence.</p><p>More precisely, if <code>f : γ → β</code> is a uniform embedding,
then <code>(f ∘ ·) : (α →ᵤ γ) → (α →ᵤ β)</code> is a uniform embedding.</p></div></div><div class="decl" id="UniformFun.comap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L386-L391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.comap_eq"><span class="name">UniformFun</span>.<span class="name">comap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><p>If <code>u</code> is a uniform structures on <code>β</code> and <code>f : γ → β</code>, then
<code>𝒰(α, γ, comap f u) = comap (fun g ↦ f ∘ g) 𝒰(α, γ, u₁)</code>.</p></div></div><div class="decl" id="UniformFun.postcomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L393-L405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.postcomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">postcomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span>)</span></div></div><p>Post-composition by a uniformly continuous function is uniformly continuous on <code>α →ᵤ β</code>.</p><p>More precisely, if <code>f : γ → β</code> is uniformly continuous, then <code>(fun g ↦ f ∘ g) : (α →ᵤ γ) → (α →ᵤ β)</code>
is uniformly continuous.</p></div></div><div class="decl" id="UniformFun.congrRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L407-L412">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.congrRight"><span class="name">UniformFun</span>.<span class="name">congrRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">γ</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Turn a uniform isomorphism <code>γ ≃ᵤ β</code> into a uniform isomorphism <code>(α →ᵤ γ) ≃ᵤ (α →ᵤ β)</code> by
post-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.congrRight">UniformFun.congrRight</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">{</a> <span class="fn">toEquiv</span> := <span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piCongrRight">Equiv.piCongrRight</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">e</span>.<a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.toEquiv">toEquiv</a></span></span></span>, <span class="fn">uniformContinuous_toFun</span> := <span class="fn">⋯</span>,
    <span class="fn">uniformContinuous_invFun</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">}</a></li></ul></details><details id="instances-for-list-UniformFun.congrRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.precomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L414-L424">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.precomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">precomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a> (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></span></div></div><p>Pre-composition by any function is uniformly continuous for the uniform structures of
uniform convergence.</p><p>More precisely, for any <code>f : γ → α</code>, the function <code>(· ∘ f) : (α →ᵤ β) → (γ →ᵤ β)</code> is uniformly
continuous.</p></div></div><div class="decl" id="UniformFun.congrLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L426-L431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.congrLeft"><span class="name">UniformFun</span>.<span class="name">congrLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">γ</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">γ</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>Turn a bijection <code>γ ≃ α</code> into a uniform isomorphism
<code>(γ →ᵤ β) ≃ᵤ (α →ᵤ β)</code> by pre-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.congrLeft">UniformFun.congrLeft</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">{</a> <span class="fn">toEquiv</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.arrowCongr">arrowCongr</a></span> <span class="fn">(<a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.refl">Equiv.refl</a> <span class="fn">β</span>)</span></span>, <span class="fn">uniformContinuous_toFun</span> := <span class="fn">⋯</span>, <span class="fn">uniformContinuous_invFun</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">}</a></li></ul></details><details id="instances-for-list-UniformFun.congrLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.uniformContinuous_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L433-L441">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformContinuous_toFun"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span></span></div></div><p>The natural map <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a></code> from <code>α →ᵤ β</code> to <code>α → β</code> is uniformly continuous.</p><p>In other words, the uniform structure of uniform convergence is finer than that of pointwise
convergence, aka the product uniform structure.</p></div></div><div class="decl" id="UniformFun.instT2Space"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L443-L445">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.instT2Space"><span class="name">UniformFun</span>.<span class="name">instT2Space</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation/Hausdorff.html#T2Space">T2Space</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Separation/Hausdorff.html#T2Space">T2Space</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div><p>The topology of uniform convergence is T₂.</p></div></div><div class="decl" id="UniformFun.tendsto_iff_tendstoUniformly"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L447-L452">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.tendsto_iff_tendstoUniformly"><span class="name">UniformFun</span>.<span class="name">tendsto_iff_tendstoUniformly</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">F</span> <span class="fn">p</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">F</span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a> <span class="fn">f</span>)</span> <span class="fn">p</span></span></div></div><p>The topology of uniform convergence indeed gives the same notion of convergence as
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a></code>.</p></div></div><div class="decl" id="UniformFun.uniformEquivProdArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L454-L474">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformEquivProdArrow"><span class="name">UniformFun</span>.<span class="name">uniformEquivProdArrow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span>)</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">γ</span></span></div></div><p>The natural bijection between <code>α → β × γ</code> and <code>(α → β) × (α → γ)</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ β × γ</code> and <code>(α →ᵤ β) × (α →ᵤ γ)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformEquivProdArrow">UniformFun.uniformEquivProdArrow</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Equiv/Prod.html#Equiv.arrowProdEquivProdArrow">Equiv.arrowProdEquivProdArrow</a> <span class="fn">α</span> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn">β</span>)</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn">γ</span></span>)</span>.<a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#Equiv.toUniformEquivOfIsUniformInducing">toUniformEquivOfIsUniformInducing</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-UniformFun.uniformEquivProdArrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.uniformEquivPiComm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L479-L499">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformEquivPiComm"><span class="name">UniformFun</span>.<span class="name">uniformEquivPiComm</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">δ</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_5</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span>)</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span></span>)</span></div></div><p>The natural bijection between <code>α → Π i, δ i</code> and <code>Π i, α → δ i</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ (Π i, δ i)</code> and <code>Π i, α →ᵤ δ i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformEquivPiComm">UniformFun.uniformEquivPiComm</a> <span class="fn">α</span> <span class="fn">δ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piComm">Equiv.piComm</a> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn">δ</span></span>)</span>.<a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#Equiv.toUniformEquivOfIsUniformInducing">toUniformEquivOfIsUniformInducing</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-UniformFun.uniformEquivPiComm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.isClosed_setOf_continuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L503-L509">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.isClosed_setOf_continuous"><span class="name">UniformFun</span>.<span class="name">isClosed_setOf_continuous</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a> <span class="fn">f</span>)</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></div></div><p>The set of continuous functions is closed in the uniform convergence topology.
This is a simple wrapper over <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformApproximation.html#TendstoUniformly.continuous">TendstoUniformly.continuous</a></code>.</p></div></div><div class="decl" id="UniformFun.uniformSpace_eq_inf_precomp_of_cover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L512-L528">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace_eq_inf_precomp_of_cover"><span class="name">UniformFun</span>.<span class="name">uniformSpace_eq_inf_precomp_of_cover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ₁</span> : <a href="../../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ₂</span> : <a href="../../.././foundational_types.html">Type</a> u_7}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ₁</span> : <span class="fn"><span class="fn">δ₁</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">φ₂</span> : <span class="fn"><span class="fn">δ₂</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_cover</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">φ₁</span></span> <a href="../../.././Init/Core.html#Union.union">∪</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">φ₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">φ₁</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">δ₁</span> <span class="fn">β</span>)</span></span> ⊓
    <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">φ₂</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">δ₂</span> <span class="fn">β</span>)</span></span></span></div></div></div></div><div class="decl" id="UniformFun.uniformSpace_eq_iInf_precomp_of_cover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L531-L542">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace_eq_iInf_precomp_of_cover"><span class="name">UniformFun</span>.<span class="name">uniformSpace_eq_iInf_precomp_of_cover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_6</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_cover</span> : <span class="fn">∃ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">ι</span></span>), <span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">⋃ <span class="fn">i</span> ∈ <span class="fn">I</span>, <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">(<span class="fn">φ</span> <span class="fn">i</span>)</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">toFun</a></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">uniformSpace</a> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span> <span class="fn">β</span>)</span></span></span></div></div></div></div><div class="decl" id="UniformOnFun.gen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L553-L558">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen"><span class="name">UniformOnFun</span>.<span class="name">gen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></div></div><p>Basis sets for the uniformity of <code>𝔖</code>-convergence: for <code>S : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> α</code> and <code>V : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (β × β)</code>,
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">gen</a> 𝔖 S V</code> is the set of pairs <code>(f, g)</code> of functions <code>α →ᵤ[𝔖] β</code> such that
<code>∀ x ∈ S, (f x, g x) ∈ V</code>. Note that the family <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code> is only used to specify which
type alias of <code>α → β</code> to use here.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">uv</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a>     <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">S</span>, <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn"><span class="fn">uv</span>.1</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn"><span class="fn">uv</span>.2</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></li></ul></details><details id="instances-for-list-UniformOnFun.gen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.gen_eq_preimage_restrict"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L560-L570">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen_eq_preimage_restrict"><span class="name">UniformOnFun</span>.<span class="name">gen_eq_preimage_restrict</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> (<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a></span>) (<span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a></span>)</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">(↑<span class="fn">S</span>)</span> <span class="fn">β</span> <span class="fn">V</span></span></div></div><p>For <code>S : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> α</code> and <code>V : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (β × β)</code>, we have
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> 𝔖 S V = (S.restrict × S.restrict) ⁻¹' (UniformFun.<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">gen</a> S β V)</code>.
This is the crucial fact for proving that the family <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> S V</code> for <code>S ∈ 𝔖</code> and
<code>V ∈ 𝓤 β</code> is indeed a basis for the uniformity <code>α →ᵤ[𝔖] β</code> endowed with <code>𝒱(α, β, 𝔖, uβ)</code>
the uniform structure of <code>𝔖</code>-convergence, as defined in <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a></code>.</p></div></div><div class="decl" id="UniformOnFun.gen_mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L572-L574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen_mono"><span class="name">UniformOnFun</span>.<span class="name">gen_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S </span><span class="fn">S'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V </span><span class="fn">V'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hS</span> : <span class="fn">S'</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">S</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hV</span> : <span class="fn">V</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">V'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">V</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S'</span> <span class="fn">V'</span></span></div></div><p><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a></code> is antitone in the first argument and monotone in the second.</p></div></div><div class="decl" id="UniformOnFun.isBasis_gen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L576-L590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.isBasis_gen"><span class="name">UniformOnFun</span>.<span class="name">isBasis_gen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">𝔖</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">𝓑</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#FilterBasis">FilterBasis</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.IsBasis">Filter.IsBasis</a> <span class="fn">(fun (<span class="fn">SV</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn"><span class="fn">SV</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">SV</span>.2</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝓑</span>)</span> <span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt;
  <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">SV</span>.1</span> <span class="fn"><span class="fn">SV</span>.2</span></span></span></span></div></div><p>If <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code> is nonempty and directed and <code>𝓑</code> is a filter basis on <code>β × β</code>, then the
family <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> 𝔖 S V</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓑</code> is a filter basis on
<code>(α →ᵤ[𝔖] β) × (α →ᵤ[𝔖] β)</code>.
We will show in <code>has_basis_uniformity_of_basis</code> that, if <code>𝓑</code> is a basis for <code>𝓤 β</code>, then the
corresponding filter is the uniformity of <code>α →ᵤ[𝔖] β</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L594-L600">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div><p>Uniform structure of <code>𝔖</code>-convergence, i.e uniform convergence on the elements of <code>𝔖</code>,
declared as an instance on <code>α →ᵤ[𝔖] β</code>. It is defined as the infimum, for <code>S ∈ 𝔖</code>, of the pullback
by <code>S.restrict</code>, the map of restriction to <code>S</code>, of the uniform structure <code>𝒰(s, β, uβ)</code> on
<code>↥S →ᵤ β</code>. We will denote it <code>𝒱(α, β, 𝔖, uβ)</code>, where <code>uβ</code> is the uniform structure on <code>β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">⨅ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>,
    <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">UniformFun.ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span>)</span></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">(↑<span class="fn">s</span>)</span> <span class="fn">β</span>)</span></span></span></li></ul></details></div></div><div class="decl" id="UniformOnFun.topologicalSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L604-L607">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div><p>Topology of <code>𝔖</code>-convergence, i.e uniform convergence on the elements of <code>𝔖</code>, declared as an
instance on <code>α →ᵤ[𝔖] β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace">UniformOnFun.topologicalSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span>.<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace.toTopologicalSpace">toTopologicalSpace</a></span></li></ul></details></div></div><div class="decl" id="UniformOnFun.topologicalSpace_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L609-L617">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace_eq"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace_eq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace">topologicalSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">⨅ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#TopologicalSpace.induced">TopologicalSpace.induced</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">UniformFun.ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.topologicalSpace">UniformFun.topologicalSpace</a> <span class="fn">(↑<span class="fn">s</span>)</span> <span class="fn">β</span>)</span></span></span></div></div><p>The topology of <code>𝔖</code>-convergence is the infimum, for <code>S ∈ 𝔖</code>, of topology induced by the map
of <code>S.restrict : (α →ᵤ[𝔖] β) → (↥S →ᵤ β)</code> of restriction to <code>S</code>, where <code>↥S →ᵤ β</code> is endowed with
the topology of uniform convergence.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity_of_basis_aux₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L619-L624">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_basis_aux₁"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₁</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">(<span class="fn">s</span> <span class="fn">i</span>)</span></span></span></span></div></div></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity_of_basis_aux₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L626-L635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_basis_aux₂"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₂</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> (<span class="fn">(fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">(↑<span class="fn">s</span>)</span> <span class="fn">β</span>)</span></span>)</span> <a href="../../.././Mathlib/Order/Basic.html#Order.Preimage">⁻¹'o</a> <a href="../../.././Init/Prelude.html#GE.ge">GE.ge</a>) <span class="fn">𝔖</span></span></div></div></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L637-L648">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">𝔖</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">Si</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn">Si</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">Si</span>.2</span></span>)</span> <span class="fn">fun (<span class="fn">Si</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span>) =&gt;
  <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">Si</span>.1</span> <span class="fn">(<span class="fn">s</span> <span class="fn"><span class="fn">Si</span>.2</span>)</span></span></span></span></div></div><p>If <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code> is nonempty and directed and <code>𝓑</code> is a filter basis of <code>𝓤 β</code>, then the
uniformity of <code>α →ᵤ[𝔖] β</code> admits the family <code>{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and
<code>V ∈ 𝓑</code> as a filter basis.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L650-L655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">𝔖</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">SV</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn"><span class="fn">SV</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">SV</span>.2</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span>
  <span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">SV</span>.1</span> <span class="fn"><span class="fn">SV</span>.2</span></span></span></span></div></div><p>If <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code> is nonempty and directed, then the uniformity of <code>α →ᵤ[𝔖] β</code> admits the
family <code>{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓤 β</code> as a filter basis.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity_of_covering_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L659-L677">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_covering_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_covering_of_basis</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι'</span> : <a href="../../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι'</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><span class="fn">ι'</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hdir</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span>)</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hex</span> : <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn">∃ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">V</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn">ι</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι'</span>) =&gt; <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">i</span>.2</span></span>)</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">ι</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι'</span>) =&gt;
  <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">(<span class="fn">t</span> <span class="fn"><span class="fn">i</span>.1</span>)</span> <span class="fn">(<span class="fn">V</span> <span class="fn"><span class="fn">i</span>.2</span>)</span></span></span></span></div></div><p>Let <code>t i</code> be a nonempty directed subfamily of <code>𝔖</code>
such that every <code>s ∈ 𝔖</code> is included in some <code>t i</code>.
Let <code>V</code> bounded by <code>p</code> be a basis of entourages of <code>β</code>.</p><p>Then <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> 𝔖 (t i) (V j)</code> bounded by <code>p j</code> is a basis of entourages of <code>α →ᵤ[𝔖] β</code>.</p></div></div><div class="decl" id="UniformOnFun.hasAntitoneBasis_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L679-L694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasAntitoneBasis_uniformity"><span class="name">UniformOnFun</span>.<span class="name">hasAntitoneBasis_uniformity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">ι</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">ι</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn">∀ (<span class="fn">n</span> : <span class="fn">ι</span>), <span class="fn"><span class="fn">t</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmono</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hex</span> : <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn">∃ (<span class="fn">n</span> : <span class="fn">ι</span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">t</span> <span class="fn">n</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasAntitoneBasis">HasAntitoneBasis</a></span> <span class="fn">V</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasAntitoneBasis">HasAntitoneBasis</a></span> <span class="fn">fun (<span class="fn">n</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">(<span class="fn">t</span> <span class="fn">n</span>)</span> <span class="fn">(<span class="fn">V</span> <span class="fn">n</span>)</span></span></span></span></div></div><p>If <code>t n</code> is a monotone sequence of sets in <code>𝔖</code>
such that each <code>s ∈ 𝔖</code> is included in some <code>t n</code>
and <code>V n</code> is an antitone basis of entourages of <code>β</code>,
then <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> 𝔖 (t n) (V n)</code> is an antitone basis of entourages of <code>α →ᵤ[𝔖] β</code>.</p></div></div><div class="decl" id="UniformOnFun.isCountablyGenerated_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L696-L700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.isCountablyGenerated_uniformity"><span class="name">UniformOnFun</span>.<span class="name">isCountablyGenerated_uniformity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/CountablyGenerated.html#Filter.IsCountablyGenerated">IsCountablyGenerated</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn">∀ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn"><span class="fn">t</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmono</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hex</span> : <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn">∃ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn">t</span> <span class="fn">n</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/CountablyGenerated.html#Filter.IsCountablyGenerated">IsCountablyGenerated</a></span></div></div></div></div><div class="decl" id="UniformOnFun.hasBasis_nhds_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L704-L712">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_nhds_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">𝔖</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">Si</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn">Si</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">Si</span>.2</span></span>)</span> <span class="fn">fun (<span class="fn">Si</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span>) =&gt;
  <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">g</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">g</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">f</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">Si</span>.1</span> <span class="fn">(<span class="fn">s</span> <span class="fn"><span class="fn">Si</span>.2</span>)</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></span></div></div><p>For <code>f : α →ᵤ[𝔖] β</code>, where <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code> is nonempty and directed, <code>𝓝 f</code> admits the
family <code>{g | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓑</code> as a filter basis, for any basis
<code>𝓑</code> of <code>𝓤 β</code>.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L714-L719">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_nhds"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">𝔖</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">x2</span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">SV</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt; <span class="fn"><span class="fn">SV</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">SV</span>.2</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>) =&gt;
  <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">g</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">g</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">f</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">SV</span>.1</span> <span class="fn"><span class="fn">SV</span>.2</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></span></div></div><p>For <code>f : α →ᵤ[𝔖] β</code>, where <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code> is nonempty and directed, <code>𝓝 f</code> admits the
family <code>{g | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓤 β</code> as a filter basis.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_restrict"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L721-L727">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_restrict"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_restrict</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">UniformFun.ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div><p>If <code>S ∈ 𝔖</code>, then the restriction to <code>S</code> is a uniformly continuous map from <code>α →ᵤ[𝔖] β</code> to
<code>↥S →ᵤ β</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformity_eq_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L731-L742">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformity_eq_of_basis"><span class="name">UniformOnFun</span>.<span class="name">uniformity_eq_of_basis</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">V</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn">⨅ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn">⨅ (_ : <span class="fn"><span class="fn">p</span> <span class="fn">i</span></span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">s</span> <span class="fn">(<span class="fn">V</span> <span class="fn">i</span>)</span>)</span></span></span></span></span></div></div><p>A version of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_basis">UniformOnFun.hasBasis_uniformity_of_basis</a></code>
with weaker conclusion and weaker assumptions.</p><p>We make no assumptions about the set <code>𝔖</code>
but conclude only that the uniformity is equal to some indexed infimum.</p></div></div><div class="decl" id="UniformOnFun.uniformity_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L744-L745">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformity_eq"><span class="name">UniformOnFun</span>.<span class="name">uniformity_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn">⨅ <span class="fn">V</span> ∈ <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>, <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">s</span> <span class="fn">V</span>)</span></span></span></span></div></div></div></div><div class="decl" id="UniformOnFun.gen_mem_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L747-L750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen_mem_uniformity"><span class="name">UniformOnFun</span>.<span class="name">gen_mem_uniformity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hV</span> : <span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">s</span> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div></div></div><div class="decl" id="UniformOnFun.nhds_eq_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L752-L761">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.nhds_eq_of_basis"><span class="name">UniformOnFun</span>.<span class="name">nhds_eq_of_basis</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">p</span> <span class="fn">V</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">⨅ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>,
    <span class="fn">⨅ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn">⨅ (_ : <span class="fn"><span class="fn">p</span> <span class="fn">i</span></span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">g</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">s</span>, <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">g</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">V</span> <span class="fn">i</span></span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></span></span></span></div></div><p>A version of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_nhds_of_basis">UniformOnFun.hasBasis_nhds_of_basis</a></code>
with weaker conclusion and weaker assumptions.</p><p>We make no assumptions about the set <code>𝔖</code>
but conclude only that the neighbourhoods filter is equal to some indexed infimum.</p></div></div><div class="decl" id="UniformOnFun.nhds_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L763-L765">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.nhds_eq"><span class="name">UniformOnFun</span>.<span class="name">nhds_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">⨅ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn">⨅ <span class="fn">V</span> ∈ <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>, <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">g</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">s</span>, <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">g</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></span></span></div></div></div></div><div class="decl" id="UniformOnFun.gen_mem_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L767-L770">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen_mem_nhds"><span class="name">UniformOnFun</span>.<span class="name">gen_mem_nhds</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hV</span> : <span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">g</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">s</span>, <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">g</span> <span class="fn">x</span></span><a href="../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformOnFun.uniformContinuous_ofUniformFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L772-L776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_ofUniformFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_ofUniformFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a> <span class="fn">f</span>)</span></span></span></span></div></div></div></div><div class="decl" id="UniformOnFun.uniformEquivUniformFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L778-L789">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivUniformFun"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivUniformFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></div></div><p>The uniformity on <code>α →ᵤ[𝔖] β</code> is the same as the uniformity on <code>α →ᵤ β</code>,
provided that <code><a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> ∈ 𝔖</code>.</p><p>Here we formulate it as a <code><a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">UniformEquiv</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformOnFun.uniformEquivUniformFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.uniformContinuous_ofFun_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L791-L807">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_ofFun_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_ofFun_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖 </span><span class="fn">𝔗</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn">∃ <span class="fn">T</span> ⊆ <span class="fn">𝔗</span>, <span class="fn"><span class="fn">T</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">⋃₀</a> <span class="fn">T</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔗</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div><p>If <code>𝔖</code> and <code>𝔗</code> are families of sets in <code>α</code>, then the identity map
<code>(α →ᵤ[𝔗] β) → (α →ᵤ[𝔖] β)</code> is uniformly continuous if every <code>s ∈ 𝔖</code> is contained in a finite
union of elements of <code>𝔗</code>.</p><p>With more API around <code>Order.Ideal</code>, this could be phrased in that language instead.</p></div></div><div class="decl" id="UniformOnFun.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L809-L815">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.mono"><span class="name">UniformOnFun</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃<span class="fn">u₁ </span><span class="fn">u₂</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hu</span> : <span class="fn">u₁</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">u₂</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">⦃<span class="fn">𝔖₁ </span><span class="fn">𝔖₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h𝔖</span> : <span class="fn">𝔖₂</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">𝔖₁</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖₁</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖₂</span></span></div></div><p>Let <code>u₁</code>, <code>u₂</code> be two uniform structures on <code>γ</code> and <code>𝔖₁ 𝔖₂ : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code>. If <code>u₁ ≤ u₂</code> and
<code>𝔖₂ ⊆ 𝔖₁</code> then <code>𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_eval_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L817-L822">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_eval_of_mem"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hxs</span> : <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div><p>If <code>x : α</code> is in some <code>S ∈ 𝔖</code>, then evaluation at <code>x</code> is uniformly continuous on
<code>α →ᵤ[𝔖] β</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_eval_of_mem_sUnion"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L824-L827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_eval_of_mem_sUnion"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval_of_mem_sUnion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">⋃₀</a> <span class="fn">𝔖</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div></div></div><div class="decl" id="UniformOnFun.uniformContinuous_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L831-L833">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_eval"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">⋃₀</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div></div></div><div class="decl" id="UniformOnFun.iInf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L835-L841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.iInf_eq"><span class="name">UniformOnFun</span>.<span class="name">iInf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span></span></div></div><p>If <code>u</code> is a family of uniform structures on <code>γ</code>, then
<code>𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)</code>.</p></div></div><div class="decl" id="UniformOnFun.inf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L843-L849">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.inf_eq"><span class="name">UniformOnFun</span>.<span class="name">inf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u₁ </span><span class="fn">u₂</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> ⊓ <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span></span></div></div><p>If <code>u₁</code> and <code>u₂</code> are two uniform structures on <code>γ</code>, then
<code>𝒱(α, γ, 𝔖, u₁ ⊓ u₂) = 𝒱(α, γ, 𝔖, u₁) ⊓ 𝒱(α, γ, 𝔖, u₂)</code>.</p></div></div><div class="decl" id="UniformOnFun.comap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L851-L860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.comap_eq"><span class="name">UniformOnFun</span>.<span class="name">comap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div><p>If <code>u</code> is a uniform structure on <code>β</code> and <code>f : γ → β</code>, then
<code>𝒱(α, γ, 𝔖, comap f u) = comap (fun g ↦ f ∘ g) 𝒱(α, γ, 𝔖, u₁)</code>.</p></div></div><div class="decl" id="UniformOnFun.postcomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L862-L871">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">postcomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔖</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div><p>Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of <code>𝔖</code>-convergence.</p><p>More precisely, if <code>f : γ → β</code> is uniformly continuous, then
<code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is uniformly continuous.</p></div></div><div class="decl" id="UniformOnFun.postcomp_isUniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L873-L887">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_isUniformInducing"><span class="name">UniformOnFun</span>.<span class="name">postcomp_isUniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔖</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div><p>Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of <code>𝔖</code>-convergence.</p><p>More precisely, if <code>f : γ → β</code> is a uniform inducing, then
<code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is a uniform inducing.</p></div></div><div class="decl" id="UniformOnFun.postcomp_isUniformEmbedding"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L889-L897">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_isUniformEmbedding"><span class="name">UniformOnFun</span>.<span class="name">postcomp_isUniformEmbedding</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformEmbedding">IsUniformEmbedding</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔖</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div><p>Post-composition by a uniform embedding is a uniform embedding for the
uniform structures of <code>𝔖</code>-convergence.</p><p>More precisely, if <code>f : γ → β</code> is a uniform embedding, then
<code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is a uniform embedding.</p></div></div><div class="decl" id="UniformOnFun.congrRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L899-L904">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrRight"><span class="name">UniformOnFun</span>.<span class="name">congrRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">γ</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></div></div><p>Turn a uniform isomorphism <code>γ ≃ᵤ β</code> into a uniform isomorphism <code>(α →ᵤ[𝔖] γ) ≃ᵤ (α →ᵤ[𝔖] β)</code>
by post-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrRight">UniformOnFun.congrRight</a> <span class="fn">e</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">{</a> <span class="fn">toEquiv</span> := <span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piCongrRight">Equiv.piCongrRight</a> <span class="fn">fun (<span class="fn">_a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">e</span>.<a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.toEquiv">toEquiv</a></span></span></span>, <span class="fn">uniformContinuous_toFun</span> := <span class="fn">⋯</span>,
    <span class="fn">uniformContinuous_invFun</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">}</a></li></ul></details><details id="instances-for-list-UniformOnFun.congrRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.precomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L906-L919">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.precomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">precomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔗</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">γ</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">γ</span></span>) =&gt; <span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">x</span>)</span> <span class="fn">𝔗</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>) =&gt; <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔗</span>)</span> (<span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></span></div></div><p>Let <code>f : γ → α</code>, <code>𝔖 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set α)</code>, <code>𝔗 : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (Set γ)</code>, and assume that <code>∀ T ∈ 𝔗, f '' T ∈ 𝔖</code>.
Then, the function <code>(fun g ↦ g ∘ f) : (α →ᵤ[𝔖] β) → (γ →ᵤ[𝔗] β)</code> is uniformly continuous.</p><p>Note that one can easily see that assuming <code>∀ T ∈ 𝔗, ∃ S ∈ 𝔖, f '' T ⊆ S</code> would work too, but
we will get this for free when we prove that <code>𝒱(α, β, 𝔖, uβ) = 𝒱(α, β, 𝔖', uβ)</code> where <code>𝔖'</code> is the
<em><strong>noncovering</strong></em> bornology generated by <code>𝔖</code>.</p></div></div><div class="decl" id="UniformOnFun.congrLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L921-L930">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrLeft"><span class="name">UniformOnFun</span>.<span class="name">congrLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔗</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">γ</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">γ</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn">𝔗</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">Set.image</a> <span class="fn">⇑<span class="fn">e</span></span></span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn">𝔖</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he'</span> : <span class="fn">𝔖</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">Set.preimage</a> <span class="fn">⇑<span class="fn">e</span></span></span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn">𝔗</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">γ</span> <span class="fn">β</span> <span class="fn">𝔗</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></div></div><p>Turn a bijection <code>e : γ ≃ α</code> such that we have both <code>∀ T ∈ 𝔗, e '' T ∈ 𝔖</code> and
<code>∀ S ∈ 𝔖, e ⁻¹' S ∈ 𝔗</code> into a uniform isomorphism <code>(γ →ᵤ[𝔗] β) ≃ᵤ (α →ᵤ[𝔖] β)</code> by pre-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrLeft">UniformOnFun.congrLeft</a> <span class="fn">e</span> <span class="fn">he</span> <span class="fn">he'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">{</a> <span class="fn">toEquiv</span> := <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.arrowCongr">arrowCongr</a></span> <span class="fn">(<a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.refl">Equiv.refl</a> <span class="fn">β</span>)</span></span>, <span class="fn">uniformContinuous_toFun</span> := <span class="fn">⋯</span>, <span class="fn">uniformContinuous_invFun</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv.mk">}</a></li></ul></details><details id="instances-for-list-UniformOnFun.congrLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.t2Space_of_covering"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L932-L937">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.t2Space_of_covering"><span class="name">UniformOnFun</span>.<span class="name">t2Space_of_covering</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation/Hausdorff.html#T2Space">T2Space</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">⋃₀</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Separation/Hausdorff.html#T2Space">T2Space</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div><p>If <code>𝔖</code> covers <code>α</code>, then the topology of <code>𝔖</code>-convergence is T₂.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_restrict_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L939-L945">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_restrict_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_restrict_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> (<span class="fn">(<a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">⋃₀</a> <span class="fn">𝔖</span>).<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>)</span></div></div><p>The restriction map from <code>α →ᵤ[𝔖] β</code> to <code>⋃₀ 𝔖 → β</code> is uniformly continuous.</p></div></div><div class="decl" id="UniformOnFun.isUniformInducing_pi_restrict"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L947-L955">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.isUniformInducing_pi_restrict"><span class="name">UniformOnFun</span>.<span class="name">isUniformInducing_pi_restrict</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#IsUniformInducing">IsUniformInducing</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>) (<span class="fn">s</span> : <span class="fn">↑<span class="fn">𝔖</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">UniformFun.ofFun</a> <span class="fn">(<span class="fn"><span class="fn">(↑<span class="fn">s</span>)</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <span class="fn">(<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span>)</span>)</span></span></span></span></div></div><p>The map sending a function <code>f : α →ᵤ[𝔖] β</code> to the family of restrictions of <code>f</code> to each <code>s ∈ 𝔖</code>
(each coordinate equipped with its respective uniform structure <code>s →ᵤ β</code>) induces the uniformity on
<code>α →ᵤ[𝔖] β</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L957-L965">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">⋃₀</a> <span class="fn">𝔖</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span></span></div></div><p>If <code>𝔖</code> covers <code>α</code>, the natural map <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a></code> from <code>α →ᵤ[𝔖] β</code> to <code>α → β</code> is
uniformly continuous.</p><p>In other words, if <code>𝔖</code> covers <code>α</code>, then the uniform structure of <code>𝔖</code>-convergence is finer than
that of pointwise convergence.</p></div></div><div class="decl" id="UniformOnFun.continuousAt_eval₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L967-L978">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.continuousAt_eval₂"><span class="name">UniformOnFun</span>.<span class="name">continuousAt_eval₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h𝔖</span> : <span class="fn">∃ <span class="fn">V</span> ∈ <span class="fn">𝔖</span>, <span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousAt">ContinuousAt</a> <span class="fn">(<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span>)</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousAt">ContinuousAt</a> <span class="fn">(fun (<span class="fn">fx</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn"><span class="fn">fx</span>.1</span> <span class="fn"><span class="fn">fx</span>.2</span></span>)</span> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">f</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span></div></div><p>If <code>f : α →ᵤ[𝔖] β</code> is continuous at <code>x</code> and <code>x</code> admits a neighbourhood <code>V ∈ 𝔖</code>,
then evaluation of <code>g : α →ᵤ[𝔖] β</code> at <code>y : α</code> is continuous in <code>(g, y)</code> at <code>(f, x)</code>.</p></div></div><div class="decl" id="UniformOnFun.continuousOn_eval₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L980-L986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.continuousOn_eval₂"><span class="name">UniformOnFun</span>.<span class="name">continuousOn_eval₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h𝔖</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">∃ <span class="fn">V</span> ∈ <span class="fn">𝔖</span>, <span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousOn">ContinuousOn</a> <span class="fn">(fun (<span class="fn">fx</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn"><span class="fn">fx</span>.1</span> <span class="fn"><span class="fn">fx</span>.2</span></span>)</span>
  <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">fx</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousAt">ContinuousAt</a> <span class="fn">(<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn"><span class="fn">fx</span>.1</span>)</span> <span class="fn"><span class="fn">fx</span>.2</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></div></div><p>If each point of <code>α</code> admits a neighbourhood <code>V ∈ 𝔖</code>,
then the evaluation of <code>f : α →ᵤ[𝔖] β</code> at <code>x : α</code> is continuous in <code>(f, x)</code>
on the set of <code>(f, x)</code> such that <code>f</code> is continuous at <code>x</code>.</p></div></div><div class="decl" id="UniformOnFun.tendsto_iff_tendstoUniformlyOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L988-L993">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.tendsto_iff_tendstoUniformlyOn"><span class="name">UniformOnFun</span>.<span class="name">tendsto_iff_tendstoUniformlyOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">F</span> <span class="fn">p</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">f</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformlyOn">TendstoUniformlyOn</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">F</span>) <span class="fn">(<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span>)</span> <span class="fn">p</span> <span class="fn">s</span></span></span></div></div><p>Convergence in the topology of <code>𝔖</code>-convergence means uniform convergence on <code>S</code> (in the sense
of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformlyOn">TendstoUniformlyOn</a></code>) for all <code>S ∈ 𝔖</code>.</p></div></div><div class="decl" id="UniformOnFun.continuous_rng_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L995-L1001">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.continuous_rng_iff"><span class="name">UniformOnFun</span>.<span class="name">continuous_rng_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> (<span class="fn">⇑<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun">UniformFun.ofFun</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Restrict.html#Set.restrict">restrict</a></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="UniformOnFun.instCompleteSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1003-L1019">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.instCompleteSpace"><span class="name">UniformOnFun</span>.<span class="name">instCompleteSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span>)</span></span></div></div></div></div><div class="decl" id="UniformOnFun.uniformEquivProdArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1021-L1043">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivProdArrow"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivProdArrow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> (<span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span>) <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span></div></div><p>The natural bijection between <code>α → β × γ</code> and <code>(α → β) × (α → γ)</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ[𝔖] β × γ</code> and <code>(α →ᵤ[𝔖] β) × (α →ᵤ[𝔖] γ)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformOnFun.uniformEquivProdArrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.uniformEquivPiComm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1047-L1067">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivPiComm"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivPiComm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">δ</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_5</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span>)</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span> <span class="fn">𝔖</span></span>)</span></div></div><p>The natural bijection between <code>α → Π i, δ i</code> and <code>Π i, α → δ i</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ[𝔖] (Π i, δ i)</code> and <code>Π i, α →ᵤ[𝔖] δ i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivPiComm">UniformOnFun.uniformEquivPiComm</a> <span class="fn">𝔖</span> <span class="fn">δ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piComm">Equiv.piComm</a> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn">δ</span></span>)</span>.<a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#Equiv.toUniformEquivOfIsUniformInducing">toUniformEquivOfIsUniformInducing</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-UniformOnFun.uniformEquivPiComm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.isClosed_setOf_continuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1070-L1078">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.isClosed_setOf_continuous"><span class="name">UniformOnFun</span>.<span class="name">isClosed_setOf_continuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsCoherentWith">Topology.IsCoherentWith</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">(<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span> <span class="fn">f</span>)</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></div></div><p>Suppose that the topology on <code>α</code> is defined by its restrictions to the sets of <code>𝔖</code>.</p><p>Then the set of continuous functions is closed
in the topology of uniform convergence on the sets of <code>𝔖</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformSpace_eq_inf_precomp_of_cover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1081-L1104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace_eq_inf_precomp_of_cover"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace_eq_inf_precomp_of_cover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ₁</span> : <a href="../../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ₂</span> : <a href="../../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ₁</span> : <span class="fn"><span class="fn">δ₁</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">φ₂</span> : <span class="fn"><span class="fn">δ₂</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">𝔗₁</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">δ₁</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">𝔗₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">δ₂</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_image₁</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">δ₁</span></span>) =&gt; <span class="fn">φ₁</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">x</span>)</span> <span class="fn">𝔗₁</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_image₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">δ₂</span></span>) =&gt; <span class="fn">φ₂</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">x</span>)</span> <span class="fn">𝔗₂</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_preimage₁</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">φ₁</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn">x</span>)</span> <span class="fn">𝔖</span> <span class="fn">𝔗₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_preimage₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">φ₂</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn">x</span>)</span> <span class="fn">𝔖</span> <span class="fn">𝔗₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_cover</span> : <span class="fn">∀ <span class="fn">S</span> ∈ <span class="fn">𝔖</span>, <span class="fn">S</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">φ₁</span></span> <a href="../../.././Init/Core.html#Union.union">∪</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">φ₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔗₁</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">φ₁</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">δ₁</span> <span class="fn">β</span> <span class="fn">𝔗₁</span>)</span></span> ⊓
    <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">𝔗₂</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">φ₂</span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">δ₂</span> <span class="fn">β</span> <span class="fn">𝔗₂</span>)</span></span></span></div></div></div></div><div class="decl" id="UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1107-L1124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace_eq_iInf_precomp_of_cover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">𝔖</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_5</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">φ</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">𝔗</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_image</span> : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span></span>) =&gt; <span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">𝔗</span> <span class="fn">i</span>)</span> <span class="fn">𝔖</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_preimage</span> : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn">x</span>)</span> <span class="fn">𝔖</span> <span class="fn">(<span class="fn">𝔗</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h_cover</span> : <span class="fn">∀ <span class="fn">S</span> ∈ <span class="fn">𝔖</span>, <span class="fn">∃ (<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">ι</span></span>), <span class="fn"><span class="fn">I</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">S</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">⋃ <span class="fn">i</span> ∈ <span class="fn">I</span>, <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">(<span class="fn">φ</span> <span class="fn">i</span>)</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">⨅ (<span class="fn">i</span> : <span class="fn">ι</span>),
    <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> (<span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">ofFun</a> <span class="fn">(<span class="fn">𝔗</span> <span class="fn">i</span>)</span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) =&gt; <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">φ</span> <span class="fn">i</span></span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">toFun</a> <span class="fn">𝔖</span>)</span></span>) <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">uniformSpace</a> <span class="fn">(<span class="fn">δ</span> <span class="fn">i</span>)</span> <span class="fn">β</span> <span class="fn">(<span class="fn">𝔗</span> <span class="fn">i</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="UniformFun.instCompleteSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1130-L1131">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.instCompleteSpace"><span class="name">UniformFun</span>.<span class="name">instCompleteSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Cauchy.html#CompleteSpace">CompleteSpace</a> <span class="fn">(<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span>)</span></span></div></div></div></div><div class="decl" id="UniformContinuousOn.comp_tendstoUniformly"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1140-L1152">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformContinuousOn.comp_tendstoUniformly"><span class="name">UniformContinuousOn</span>.<span class="name">comp_tendstoUniformly</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn">ι</span>) (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">F</span> <span class="fn">i</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuousOn">UniformContinuousOn</a> <span class="fn">g</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a> <span class="fn">F</span> <span class="fn">f</span> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn">ι</span>) (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">F</span> <span class="fn">i</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">p</span></span></div></div><p>Composing on the left by a uniformly continuous function preserves uniform convergence</p></div></div><div class="decl" id="UniformContinuousOn.comp_tendstoUniformly_eventually"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1154-L1169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformContinuousOn.comp_tendstoUniformly_eventually"><span class="name">UniformContinuousOn</span>.<span class="name">comp_tendstoUniformly_eventually</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">∀ᶠ</a> (<span class="fn">i</span> : <span class="fn">ι</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">p</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">F</span> <span class="fn">i</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuousOn">UniformContinuousOn</a> <span class="fn">g</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a> <span class="fn">F</span> <span class="fn">f</span> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn">ι</span>) (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">F</span> <span class="fn">i</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="UniformContinuousOn.comp_tendstoUniformlyOn_eventually"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L1171-L1177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformContinuousOn.comp_tendstoUniformlyOn_eventually"><span class="name">UniformContinuousOn</span>.<span class="name">comp_tendstoUniformlyOn_eventually</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hF</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">∀ᶠ</a> (<span class="fn">i</span> : <span class="fn">ι</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">p</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">t</span>, <span class="fn"><span class="fn">F</span> <span class="fn">i</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">t</span>, <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformContinuousOn">UniformContinuousOn</a> <span class="fn">g</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformlyOn">TendstoUniformlyOn</a> <span class="fn">F</span> <span class="fn">f</span> <span class="fn">p</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformlyOn">TendstoUniformlyOn</a> <span class="fn">(fun (<span class="fn">i</span> : <span class="fn">ι</span>) (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">F</span> <span class="fn">i</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">p</span> <span class="fn">t</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
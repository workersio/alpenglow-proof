<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Order.Circular</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Order.Circular";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Order</span>.<span class="name">Circular</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Order/Lattice.html">Mathlib.Order.Lattice</a></li><li><a href="../.././Mathlib/Tactic/Order.html">Mathlib.Tactic.Order</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Order.Circular" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Btw"><span class="name">Btw</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw"><span class="name">SBtw</span></a></div><div class="nav_link"><a class="break_within" href="#CircularPreorder"><span class="name">CircularPreorder</span></a></div><div class="nav_link"><a class="break_within" href="#CircularPartialOrder"><span class="name">CircularPartialOrder</span></a></div><div class="nav_link"><a class="break_within" href="#CircularOrder"><span class="name">CircularOrder</span></a></div><div class="nav_link"><a class="break_within" href="#btw_rfl"><span class="name">btw_rfl</span></a></div><div class="nav_link"><a class="break_within" href="#Btw.btw.cyclic_left"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">cyclic_left</span></a></div><div class="nav_link"><a class="break_within" href="#btw_cyclic_right"><span class="name">btw_cyclic_right</span></a></div><div class="nav_link"><a class="break_within" href="#Btw.btw.cyclic_right"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">cyclic_right</span></a></div><div class="nav_link"><a class="break_within" href="#btw_cyclic"><span class="name">btw_cyclic</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_iff_btw_not_btw"><span class="name">sbtw_iff_btw_not_btw</span></a></div><div class="nav_link"><a class="break_within" href="#btw_of_sbtw"><span class="name">btw_of_sbtw</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw.sbtw.btw"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">btw</span></a></div><div class="nav_link"><a class="break_within" href="#not_btw_of_sbtw"><span class="name">not_btw_of_sbtw</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw.sbtw.not_btw"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">not_btw</span></a></div><div class="nav_link"><a class="break_within" href="#not_sbtw_of_btw"><span class="name">not_sbtw_of_btw</span></a></div><div class="nav_link"><a class="break_within" href="#Btw.btw.not_sbtw"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">not_sbtw</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_of_btw_not_btw"><span class="name">sbtw_of_btw_not_btw</span></a></div><div class="nav_link"><a class="break_within" href="#Btw.btw.sbtw_of_not_btw"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">sbtw_of_not_btw</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_cyclic_left"><span class="name">sbtw_cyclic_left</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw.sbtw.cyclic_left"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">cyclic_left</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_cyclic_right"><span class="name">sbtw_cyclic_right</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw.sbtw.cyclic_right"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">cyclic_right</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_cyclic"><span class="name">sbtw_cyclic</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw.sbtw.trans_left"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">trans_left</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_trans_right"><span class="name">sbtw_trans_right</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw.sbtw.trans_right"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">trans_right</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_asymm"><span class="name">sbtw_asymm</span></a></div><div class="nav_link"><a class="break_within" href="#SBtw.sbtw.not_sbtw"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">not_sbtw</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_irrefl_left_right"><span class="name">sbtw_irrefl_left_right</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_irrefl_left"><span class="name">sbtw_irrefl_left</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_irrefl_right"><span class="name">sbtw_irrefl_right</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_irrefl"><span class="name">sbtw_irrefl</span></a></div><div class="nav_link"><a class="break_within" href="#Btw.btw.antisymm"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">antisymm</span></a></div><div class="nav_link"><a class="break_within" href="#btw_refl_left_right"><span class="name">btw_refl_left_right</span></a></div><div class="nav_link"><a class="break_within" href="#btw_rfl_left_right"><span class="name">btw_rfl_left_right</span></a></div><div class="nav_link"><a class="break_within" href="#btw_refl_left"><span class="name">btw_refl_left</span></a></div><div class="nav_link"><a class="break_within" href="#btw_rfl_left"><span class="name">btw_rfl_left</span></a></div><div class="nav_link"><a class="break_within" href="#btw_refl_right"><span class="name">btw_refl_right</span></a></div><div class="nav_link"><a class="break_within" href="#btw_rfl_right"><span class="name">btw_rfl_right</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_iff_not_btw"><span class="name">sbtw_iff_not_btw</span></a></div><div class="nav_link"><a class="break_within" href="#btw_iff_not_sbtw"><span class="name">btw_iff_not_sbtw</span></a></div><div class="nav_link"><a class="break_within" href="#Set.cIcc"><span class="name">Set</span>.<span class="name">cIcc</span></a></div><div class="nav_link"><a class="break_within" href="#Set.cIoo"><span class="name">Set</span>.<span class="name">cIoo</span></a></div><div class="nav_link"><a class="break_within" href="#Set.mem_cIcc"><span class="name">Set</span>.<span class="name">mem_cIcc</span></a></div><div class="nav_link"><a class="break_within" href="#Set.mem_cIoo"><span class="name">Set</span>.<span class="name">mem_cIoo</span></a></div><div class="nav_link"><a class="break_within" href="#Set.left_mem_cIcc"><span class="name">Set</span>.<span class="name">left_mem_cIcc</span></a></div><div class="nav_link"><a class="break_within" href="#Set.right_mem_cIcc"><span class="name">Set</span>.<span class="name">right_mem_cIcc</span></a></div><div class="nav_link"><a class="break_within" href="#Set.compl_cIcc"><span class="name">Set</span>.<span class="name">compl_cIcc</span></a></div><div class="nav_link"><a class="break_within" href="#Set.compl_cIoo"><span class="name">Set</span>.<span class="name">compl_cIoo</span></a></div><div class="nav_link"><a class="break_within" href="#LE.toBtw"><span class="name">LE</span>.<span class="name">toBtw</span></a></div><div class="nav_link"><a class="break_within" href="#LT.toSBtw"><span class="name">LT</span>.<span class="name">toSBtw</span></a></div><div class="nav_link"><a class="break_within" href="#btw_iff"><span class="name">btw_iff</span></a></div><div class="nav_link"><a class="break_within" href="#sbtw_iff"><span class="name">sbtw_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Preorder.toCircularPreorder"><span class="name">Preorder</span>.<span class="name">toCircularPreorder</span></a></div><div class="nav_link"><a class="break_within" href="#PartialOrder.toCircularPartialOrder"><span class="name">PartialOrder</span>.<span class="name">toCircularPartialOrder</span></a></div><div class="nav_link"><a class="break_within" href="#LinearOrder.toCircularOrder"><span class="name">LinearOrder</span>.<span class="name">toCircularOrder</span></a></div><div class="nav_link"><a class="break_within" href="#OrderDual.btw"><span class="name">OrderDual</span>.<span class="name">btw</span></a></div><div class="nav_link"><a class="break_within" href="#OrderDual.sbtw"><span class="name">OrderDual</span>.<span class="name">sbtw</span></a></div><div class="nav_link"><a class="break_within" href="#OrderDual.circularPreorder"><span class="name">OrderDual</span>.<span class="name">circularPreorder</span></a></div><div class="nav_link"><a class="break_within" href="#OrderDual.circularPartialOrder"><span class="name">OrderDual</span>.<span class="name">circularPartialOrder</span></a></div><div class="nav_link"><a class="break_within" href="#OrderDual.instCircularOrder"><span class="name">OrderDual</span>.<span class="name">instCircularOrder</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Circular-order-hierarchy">Circular order hierarchy <a class="hover-link" href="#Circular-order-hierarchy">#</a></h1><p>This file defines circular preorders, circular partial orders and circular orders.</p><h2 class="markdown-heading" id="Hierarchy">Hierarchy <a class="hover-link" href="#Hierarchy">#</a></h2><ul>
<li>A ternary &quot;betweenness&quot; relation <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> : α → α → α → Prop</code> forms a <code><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a></code> if it is<ul>
<li>reflexive: <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> a a a</code></li>
<li>cyclic: <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> a b c → <a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> b c a</code></li>
<li>antisymmetric: <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> a b c → <a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> c b a → a = b ∨ b = c ∨ c = a</code></li>
<li>total: <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> a b c ∨ <a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> c b a</code>
along with a strict betweenness relation <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> : α → α → α → Prop</code> which respects
<code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> a b c ↔ <a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> a b c ∧ ¬ <a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> c b a</code>, analogously to how <code>&lt;</code> and <code>≤</code> are related, and is</li>
<li>transitive: <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> a b c → <a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> b d c → <a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> a d c</code>.</li>
</ul>
</li>
<li>A <code><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a></code> drops totality.</li>
<li>A <code><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a></code> further drops antisymmetry.</li>
</ul><p>The intuition is that a circular order is a circle and <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> a b c</code> means that going around
clockwise from <code>a</code> you reach <code>b</code> before <code>c</code> (<code>b</code> is between <code>a</code> and <code>c</code> is meaningless on an
unoriented circle). A circular partial order is several, potentially intersecting, circles. A
circular preorder is like a circular partial order, but several points can coexist.</p><p>Note that the relations between <code><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a></code>, <code><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a></code> and <code><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a></code>
are subtler than between <code><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a></code>, <code><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a></code>, <code><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a></code>. In particular, one cannot
simply extend the <code><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a></code> of a <code><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a></code> to make it a <code><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a></code>.</p><p>One can translate from usual orders to circular ones by &quot;closing the necklace at infinity&quot;. See
<code><a href="../.././Mathlib/Order/Circular.html#LE.toBtw">LE.toBtw</a></code> and <code><a href="../.././Mathlib/Order/Circular.html#LT.toSBtw">LT.toSBtw</a></code>. Going the other way involves &quot;cutting the necklace&quot; or
&quot;rolling the necklace open&quot;.</p><h2 class="markdown-heading" id="Examples">Examples <a class="hover-link" href="#Examples">#</a></h2><p>Some concrete circular orders one encounters in the wild are <code>ZMod n</code> for <code>0 &lt; n</code>, <code>Circle</code>,
<code>Real.Angle</code>...</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../.././Mathlib/Order/Circular.html#Set.cIcc">Set.cIcc</a></code>: Closed-closed circular interval.</li>
<li><code><a href="../.././Mathlib/Order/Circular.html#Set.cIoo">Set.cIoo</a></code>: Open-open circular interval.</li>
</ul><h2 class="markdown-heading" id="Notes">Notes <a class="hover-link" href="#Notes">#</a></h2><p>There's an unsolved diamond on <code><a href="../.././Mathlib/Order/Basic.html#OrderDual">OrderDual</a> α</code> here. The instances <code><a href="../.././Init/Prelude.html#LE">LE</a> α → <a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> αᵒᵈ</code> and
<code><a href="../.././Init/Prelude.html#LT">LT</a> α → <a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> αᵒᵈ</code> can each be inferred in two ways:</p><ul>
<li><code><a href="../.././Init/Prelude.html#LE">LE</a> α</code> → <code><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> α</code> → <code><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> αᵒᵈ</code> vs
<code><a href="../.././Init/Prelude.html#LE">LE</a> α</code> → <code><a href="../.././Init/Prelude.html#LE">LE</a> αᵒᵈ</code> → <code><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> αᵒᵈ</code></li>
<li><code><a href="../.././Init/Prelude.html#LT">LT</a> α</code> → <code><a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> α</code> → <code><a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> αᵒᵈ</code> vs
<code><a href="../.././Init/Prelude.html#LT">LT</a> α</code> → <code><a href="../.././Init/Prelude.html#LT">LT</a> αᵒᵈ</code> → <code><a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> αᵒᵈ</code>
The fields are propeq, but not defeq. It is temporarily fixed by turning the circularizing instances
into definitions.</li>
</ul><h2 class="markdown-heading" id="TODO">TODO <a class="hover-link" href="#TODO">#</a></h2><p>Antisymmetry is quite weak in the sense that there's no way to discriminate which two points are
equal. This prevents defining closed-open intervals <code>cIco</code> and <code>cIoc</code> in the neat <code>=</code>-less way. We
currently haven't defined them at all.</p><p>What is the correct generality of &quot;rolling the necklace&quot; open? At least, this works for <code>α × β</code> and
<code>β × α</code> where <code>α</code> is a circular order and <code>β</code> is a linear order.</p><p>What's next is to define circular groups and provide instances for <code>ZMod n</code>, the usual circle group
<code>Circle</code>, and <code>RootsOfUnity M</code>. What conditions do we need on <code>M</code> for this last one
to work?</p><p>We should have circular order homomorphisms. The typical example is
<code>daysToMonth : DaysOfTheYear →c MonthsOfTheYear</code> which relates the circular order of days
and the circular order of months. Is <code>α →c β</code> a good notation?</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Cyclic_order">https://en.wikipedia.org/wiki/Cyclic_order</a></li>
<li><a href="https://en.wikipedia.org/wiki/Partial_cyclic_order">https://en.wikipedia.org/wiki/Partial_cyclic_order</a></li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>circular order, cyclic order, circularly ordered set, cyclically ordered set</p></div><div class="decl" id="Btw"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L90-L94">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Btw"><span class="name">Btw</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_1</div></div><p>Syntax typeclass for a betweenness relation.</p><ul class="structure_fields" id="Btw.mk"><li id="Btw.btw" class="structure_field"><div class="structure_field_info">btw : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>Betweenness for circular orders. <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> a b c</code> states that <code>b</code> is between <code>a</code> and <code>c</code> (in that
order).</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Btw" class="instances-list"></ul></details></div></div><div class="decl" id="SBtw"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L98-L102">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw"><span class="name">SBtw</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_1</div></div><p>Syntax typeclass for a strict betweenness relation.</p><ul class="structure_fields" id="SBtw.mk"><li id="SBtw.sbtw" class="structure_field"><div class="structure_field_info">sbtw : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div><div class="structure_field_doc"><p>Strict betweenness for circular orders. <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> a b c</code> states that <code>b</code> is strictly between <code>a</code>
and <code>c</code> (in that order).</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-SBtw" class="instances-list"></ul></details></div></div><div class="decl" id="CircularPreorder"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L106-L125">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#CircularPreorder"><span class="name">CircularPreorder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> <span class="fn">α</span></span>, <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_1</div></div><p>A circular preorder is the analogue of a preorder where you can loop around. <code>≤</code> and <code>&lt;</code> are
replaced by ternary relations <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a></code> and <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a></code>. <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a></code> is reflexive and cyclic. <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a></code> is transitive.</p><ul class="structure_fields" id="CircularPreorder.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li id="CircularPreorder.btw_refl" class="structure_field"><div class="structure_field_info">btw_refl<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">a</span></span></div><div class="structure_field_doc"><p><code>a</code> is between <code>a</code> and <code>a</code>.</p></div></li><li id="CircularPreorder.btw_cyclic_left" class="structure_field"><div class="structure_field_info">btw_cyclic_left<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">b</span> <span class="fn">c</span> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>If <code>b</code> is between <code>a</code> and <code>c</code>, then <code>c</code> is between <code>b</code> and <code>a</code>.
This is motivated by imagining three points on a circle.</p></div></li><li id="CircularPreorder.sbtw_iff_btw_not_btw" class="structure_field"><div class="structure_field_info">sbtw_iff_btw_not_btw<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div><div class="structure_field_doc"><p>Strict betweenness is given by betweenness in one direction and non-betweenness in the other.</p><p>I.e., if <code>b</code> is between <code>a</code> and <code>c</code> but not between <code>c</code> and <code>a</code>, then we say <code>b</code> is strictly
between <code>a</code> and <code>c</code>.</p></div></li><li id="CircularPreorder.sbtw_trans_left" class="structure_field"><div class="structure_field_info">sbtw_trans_left<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">b</span> <span class="fn">d</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">d</span> <span class="fn">c</span></span></span></span></div><div class="structure_field_doc"><p>For any fixed <code>c</code>, <code>fun a b ↦ <a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> a b c</code> is a transitive relation.</p><p>I.e., given <code>a</code> <code>b</code> <code>d</code> <code>c</code> in that &quot;order&quot;, if we have <code>b</code> strictly between <code>a</code> and <code>c</code>, and <code>d</code>
strictly between <code>b</code> and <code>c</code>, then <code>d</code> is strictly between <code>a</code> and <code>c</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CircularPreorder" class="instances-list"></ul></details></div></div><div class="decl" id="CircularPartialOrder"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L129-L135">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#CircularPartialOrder"><span class="name">CircularPartialOrder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_1</div></div><p>A circular partial order is the analogue of a partial order where you can loop around. <code>≤</code> and
<code>&lt;</code> are replaced by ternary relations <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a></code> and <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a></code>. <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a></code> is reflexive, cyclic and
antisymmetric. <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a></code> is transitive.</p><ul class="structure_fields" id="CircularPartialOrder.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.btw_refl">btw_refl</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">a</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.btw_cyclic_left">btw_cyclic_left</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">b</span> <span class="fn">c</span> <span class="fn">a</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.sbtw_iff_btw_not_btw">sbtw_iff_btw_not_btw</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.sbtw_trans_left">sbtw_trans_left</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">b</span> <span class="fn">d</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">d</span> <span class="fn">c</span></span></span></span></div></li><li id="CircularPartialOrder.btw_antisymm" class="structure_field"><div class="structure_field_info">btw_antisymm<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div><div class="structure_field_doc"><p>If <code>b</code> is between <code>a</code> and <code>c</code> and also between <code>c</code> and <code>a</code>, then at least one pair of points
among <code>a</code>, <code>b</code>, <code>c</code> are identical.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CircularPartialOrder" class="instances-list"></ul></details></div></div><div class="decl" id="CircularOrder"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L139-L144">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#CircularOrder"><span class="name">CircularOrder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_extends">extends</span> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a> <span class="fn">α</span></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_1</div></div><p>A circular order is the analogue of a linear order where you can loop around. <code>≤</code> and <code>&lt;</code> are
replaced by ternary relations <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a></code> and <code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a></code>. <code><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a></code> is reflexive, cyclic, antisymmetric and total.
<code><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a></code> is transitive.</p><ul class="structure_fields" id="CircularOrder.mk"><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.btw_refl">btw_refl</a><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">a</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.btw_cyclic_left">btw_cyclic_left</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">b</span> <span class="fn">c</span> <span class="fn">a</span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.sbtw_iff_btw_not_btw">sbtw_iff_btw_not_btw</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder.sbtw_trans_left">sbtw_trans_left</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">b</span> <span class="fn">d</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">d</span> <span class="fn">c</span></span></span></span></div></li><li class="structure_field inherited_field"><div class="structure_field_info"><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder.btw_antisymm">btw_antisymm</a><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></li><li id="CircularOrder.btw_total" class="structure_field"><div class="structure_field_info">btw_total<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div><div class="structure_field_doc"><p>For any triple of points, the second is between the other two one way or another.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CircularOrder" class="instances-list"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Circular-preorders">Circular preorders <a class="hover-link" href="#Circular-preorders">#</a></h3></div><div class="decl" id="btw_rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L155-L156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_rfl"><span class="name">btw_rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Btw.btw.cyclic_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L160-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Btw.btw.cyclic_left"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">cyclic_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">b</span> <span class="fn">c</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="btw_cyclic_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L163-L164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_cyclic_right"><span class="name">btw_cyclic_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Btw.btw.cyclic_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L166-L166">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Btw.btw.cyclic_right"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">cyclic_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#btw_cyclic_right">btw_cyclic_right</a></code>.</p></div></div><div class="decl" id="btw_cyclic"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L168-L171">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_cyclic"><span class="name">btw_cyclic</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p>The order of the <code>↔</code> has been chosen so that <code>rw [btw_cyclic]</code> cycles to the right while
<code>rw [← btw_cyclic]</code> cycles to the left (thus following the prepended arrow).</p></div></div><div class="decl" id="sbtw_iff_btw_not_btw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L173-L174">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_iff_btw_not_btw"><span class="name">sbtw_iff_btw_not_btw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="btw_of_sbtw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L176-L177">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_of_sbtw"><span class="name">btw_of_sbtw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="SBtw.sbtw.btw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L179-L179">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw.sbtw.btw"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">btw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">Btw.btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#btw_of_sbtw">btw_of_sbtw</a></code>.</p></div></div><div class="decl" id="not_btw_of_sbtw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L181-L182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#not_btw_of_sbtw"><span class="name">not_btw_of_sbtw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="SBtw.sbtw.not_btw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L184-L184">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw.sbtw.not_btw"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">not_btw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">Btw.btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#not_btw_of_sbtw">not_btw_of_sbtw</a></code>.</p></div></div><div class="decl" id="not_sbtw_of_btw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L186-L186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#not_sbtw_of_btw"><span class="name">not_sbtw_of_btw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Btw.btw.not_sbtw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L188-L188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Btw.btw.not_sbtw"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">not_sbtw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#not_sbtw_of_btw">not_sbtw_of_btw</a></code>.</p></div></div><div class="decl" id="sbtw_of_btw_not_btw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L190-L191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_of_btw_not_btw"><span class="name">sbtw_of_btw_not_btw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">habc</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hcba</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Btw.btw.sbtw_of_not_btw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L193-L193">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Btw.btw.sbtw_of_not_btw"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">sbtw_of_not_btw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">habc</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hcba</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#sbtw_of_btw_not_btw">sbtw_of_btw_not_btw</a></code>.</p></div></div><div class="decl" id="sbtw_cyclic_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L195-L196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_cyclic_left"><span class="name">sbtw_cyclic_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">b</span> <span class="fn">c</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="SBtw.sbtw.cyclic_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L198-L198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw.sbtw.cyclic_left"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">cyclic_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">b</span> <span class="fn">c</span> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#sbtw_cyclic_left">sbtw_cyclic_left</a></code>.</p></div></div><div class="decl" id="sbtw_cyclic_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L200-L201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_cyclic_right"><span class="name">sbtw_cyclic_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="SBtw.sbtw.cyclic_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L203-L203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw.sbtw.cyclic_right"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">cyclic_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#sbtw_cyclic_right">sbtw_cyclic_right</a></code>.</p></div></div><div class="decl" id="sbtw_cyclic"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L205-L208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_cyclic"><span class="name">sbtw_cyclic</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div><p>The order of the <code>↔</code> has been chosen so that <code>rw [sbtw_cyclic]</code> cycles to the right while
<code>rw [← sbtw_cyclic]</code> cycles to the left (thus following the prepended arrow).</p></div></div><div class="decl" id="SBtw.sbtw.trans_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L212-L213">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw.sbtw.trans_left"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">trans_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">b</span> <span class="fn">d</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">d</span> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="sbtw_trans_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L215-L216">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_trans_right"><span class="name">sbtw_trans_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hcd</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">c</span> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">d</span></span></div></div></div></div><div class="decl" id="SBtw.sbtw.trans_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L218-L218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw.sbtw.trans_right"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">trans_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hcd</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">c</span> <span class="fn">d</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">d</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#sbtw_trans_right">sbtw_trans_right</a></code>.</p></div></div><div class="decl" id="sbtw_asymm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L220-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_asymm"><span class="name">sbtw_asymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="SBtw.sbtw.not_sbtw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L223-L223">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#SBtw.sbtw.not_sbtw"><span class="name">SBtw</span>.<span class="name">sbtw</span>.<span class="name">not_sbtw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div><p><strong>Alias</strong> of <code><a href="../.././Mathlib/Order/Circular.html#sbtw_asymm">sbtw_asymm</a></code>.</p></div></div><div class="decl" id="sbtw_irrefl_left_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L225-L225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_irrefl_left_right"><span class="name">sbtw_irrefl_left_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="sbtw_irrefl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L227-L227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_irrefl_left"><span class="name">sbtw_irrefl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="sbtw_irrefl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L229-L229">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_irrefl_right"><span class="name">sbtw_irrefl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="sbtw_irrefl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L231-L232">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_irrefl"><span class="name">sbtw_irrefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">a</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Circular-partial-orders">Circular partial orders <a class="hover-link" href="#Circular-partial-orders">#</a></h3></div><div class="decl" id="Btw.btw.antisymm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L245-L246">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Btw.btw.antisymm"><span class="name">Btw</span>.<span class="name">btw</span>.<span class="name">antisymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Circular-orders">Circular orders <a class="hover-link" href="#Circular-orders">#</a></h3></div><div class="decl" id="btw_refl_left_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L257-L258">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_refl_left_right"><span class="name">btw_refl_left_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="btw_rfl_left_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L260-L261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_rfl_left_right"><span class="name">btw_rfl_left_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="btw_refl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L263-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_refl_left"><span class="name">btw_refl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="btw_rfl_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L266-L267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_rfl_left"><span class="name">btw_rfl_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="btw_refl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L269-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_refl_right"><span class="name">btw_refl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="btw_rfl_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L272-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_rfl_right"><span class="name">btw_rfl_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="sbtw_iff_not_btw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L275-L277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_iff_not_btw"><span class="name">sbtw_iff_not_btw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="btw_iff_not_sbtw"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L279-L280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_iff_not_sbtw"><span class="name">btw_iff_not_sbtw</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Circular-intervals">Circular intervals <a class="hover-link" href="#Circular-intervals">#</a></h3></div><div class="decl" id="Set.cIcc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L293-L295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.cIcc"><span class="name">Set</span>.<span class="name">cIcc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span></div></div><p>Closed-closed circular interval</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIcc">Set.cIcc</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">x</span> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn">α</span> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">x</span> <span class="fn">b</span></span><a href="../.././Mathlib/Data/Set/Defs.html#setOf">}</a></li></ul></details><details id="instances-for-list-Set.cIcc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Set.cIoo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L297-L299">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.cIoo"><span class="name">Set</span>.<span class="name">cIoo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span></div></div><p>Open-open circular interval</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIoo">Set.cIoo</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">x</span> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn">α</span> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">x</span> <span class="fn">b</span></span><a href="../.././Mathlib/Data/Set/Defs.html#setOf">}</a></li></ul></details><details id="instances-for-list-Set.cIoo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Set.mem_cIcc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L301-L303">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.mem_cIcc"><span class="name">Set</span>.<span class="name">mem_cIcc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIcc">cIcc</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">x</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Set.mem_cIoo"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L305-L307">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.mem_cIoo"><span class="name">Set</span>.<span class="name">mem_cIoo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIoo">cIoo</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">x</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Set.left_mem_cIcc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L315-L316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.left_mem_cIcc"><span class="name">Set</span>.<span class="name">left_mem_cIcc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIcc">cIcc</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Set.right_mem_cIcc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L318-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.right_mem_cIcc"><span class="name">Set</span>.<span class="name">right_mem_cIcc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIcc">cIcc</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Set.compl_cIcc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L321-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.compl_cIcc"><span class="name">Set</span>.<span class="name">compl_cIcc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Mathlib/Order/Circular.html#Set.cIcc">cIcc</a> <span class="fn">a</span> <span class="fn">b</span>)</span><a href="../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIoo">cIoo</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Set.compl_cIoo"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L325-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Set.compl_cIoo"><span class="name">Set</span>.<span class="name">compl_cIoo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Mathlib/Order/Circular.html#Set.cIoo">cIoo</a> <span class="fn">a</span> <span class="fn">b</span>)</span><a href="../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Set.cIcc">cIcc</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Circularizing-instances">Circularizing instances <a class="hover-link" href="#Circularizing-instances">#</a></h3></div><div class="decl" id="LE.toBtw"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L336-L339">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#LE.toBtw"><span class="name">LE</span>.<span class="name">toBtw</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> <span class="fn">α</span></span></div></div><p>The betweenness relation obtained from &quot;looping around&quot; <code>≤</code>.
See note [reducible non-instances].</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#LE.toBtw">LE.toBtw</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#Btw.mk">{</a> <span class="fn">btw</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span> : <span class="fn">α</span>) =&gt; <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span> <a href="../.././Mathlib/Order/Circular.html#Btw.mk">}</a></li></ul></details><details id="instances-for-list-LE.toBtw" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LT.toSBtw"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L341-L344">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#LT.toSBtw"><span class="name">LT</span>.<span class="name">toSBtw</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> <span class="fn">α</span></span></div></div><p>The strict betweenness relation obtained from &quot;looping around&quot; <code>&lt;</code>.
See note [reducible non-instances].</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#LT.toSBtw">LT.toSBtw</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#SBtw.mk">{</a> <span class="fn">sbtw</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span> : <span class="fn">α</span>) =&gt; <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span></span> <a href="../.././Mathlib/Order/Circular.html#SBtw.mk">}</a></li></ul></details><details id="instances-for-list-LT.toSBtw" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="btw_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L352-L354">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#btw_iff"><span class="name">btw_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></div></div><p>The following lemmas are about the non-instances <code><a href="../.././Mathlib/Order/Circular.html#LE.toBtw">LE.toBtw</a></code>, <code><a href="../.././Mathlib/Order/Circular.html#LT.toSBtw">LT.toSBtw</a></code> and
<code><a href="../.././Mathlib/Order/Circular.html#LinearOrder.toCircularOrder">LinearOrder.toCircularOrder</a></code>.</p></div></div><div class="decl" id="sbtw_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L355-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#sbtw_iff"><span class="name">sbtw_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span></div></div><p>The following lemmas are about the non-instances <code><a href="../.././Mathlib/Order/Circular.html#LE.toBtw">LE.toBtw</a></code>, <code><a href="../.././Mathlib/Order/Circular.html#LT.toSBtw">LT.toSBtw</a></code> and
<code><a href="../.././Mathlib/Order/Circular.html#LinearOrder.toCircularOrder">LinearOrder.toCircularOrder</a></code>.</p></div></div><div class="decl" id="Preorder.toCircularPreorder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L361-L379">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#Preorder.toCircularPreorder"><span class="name">Preorder</span>.<span class="name">toCircularPreorder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span></div></div><p>The circular preorder obtained from &quot;looping around&quot; a preorder.
See note [reducible non-instances].</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Preorder.toCircularPreorder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="PartialOrder.toCircularPartialOrder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L381-L395">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#PartialOrder.toCircularPartialOrder"><span class="name">PartialOrder</span>.<span class="name">toCircularPartialOrder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a> <span class="fn">α</span></span></div></div><p>The circular partial order obtained from &quot;looping around&quot; a partial order.
See note [reducible non-instances].</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#PartialOrder.toCircularPartialOrder">PartialOrder.toCircularPartialOrder</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder.mk">{</a> <span class="fn">toCircularPreorder</span> := <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Preorder.toCircularPreorder">Preorder.toCircularPreorder</a> <span class="fn">α</span></span>, <span class="fn">btw_antisymm</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder.mk">}</a></li></ul></details><details id="instances-for-list-PartialOrder.toCircularPartialOrder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LinearOrder.toCircularOrder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L397-L411">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#LinearOrder.toCircularOrder"><span class="name">LinearOrder</span>.<span class="name">toCircularOrder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span></div></div><p>The circular order obtained from &quot;looping around&quot; a linear order.
See note [reducible non-instances].</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#LinearOrder.toCircularOrder">LinearOrder.toCircularOrder</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#CircularOrder.mk">{</a> <span class="fn">toCircularPartialOrder</span> := <span class="fn"><a href="../.././Mathlib/Order/Circular.html#PartialOrder.toCircularPartialOrder">PartialOrder.toCircularPartialOrder</a> <span class="fn">α</span></span>, <span class="fn">btw_total</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/Order/Circular.html#CircularOrder.mk">}</a></li></ul></details><details id="instances-for-list-LinearOrder.toCircularOrder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Dual-constructions">Dual constructions <a class="hover-link" href="#Dual-constructions">#</a></h3></div><div class="decl" id="OrderDual.btw"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L418-L419">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#OrderDual.btw"><span class="name">OrderDual</span>.<span class="name">btw</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw">Btw</a> <span class="fn">α</span><a href="../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.btw">OrderDual.btw</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#Btw.mk">{</a> <span class="fn">btw</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../.././Mathlib/Order/Circular.html#Btw.btw">btw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></span> <a href="../.././Mathlib/Order/Circular.html#Btw.mk">}</a></li></ul></details></div></div><div class="decl" id="OrderDual.sbtw"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L421-L422">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#OrderDual.sbtw"><span class="name">OrderDual</span>.<span class="name">sbtw</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw">SBtw</a> <span class="fn">α</span><a href="../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.sbtw">OrderDual.sbtw</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#SBtw.mk">{</a> <span class="fn">sbtw</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> <span class="fn">c</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../.././Mathlib/Order/Circular.html#SBtw.sbtw">sbtw</a> <span class="fn">c</span> <span class="fn">b</span> <span class="fn">a</span></span></span> <a href="../.././Mathlib/Order/Circular.html#SBtw.mk">}</a></li></ul></details></div></div><div class="decl" id="OrderDual.circularPreorder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L424-L430">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#OrderDual.circularPreorder"><span class="name">OrderDual</span>.<span class="name">circularPreorder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPreorder">CircularPreorder</a> <span class="fn">α</span><a href="../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.circularPreorder">OrderDual.circularPreorder</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Mathlib/Order/Circular.html#CircularPreorder.mk">{</a> <span class="fn">toBtw</span> := <span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.btw">OrderDual.btw</a> <span class="fn">α</span></span>, <span class="fn">toSBtw</span> := <span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.sbtw">OrderDual.sbtw</a> <span class="fn">α</span></span>, <span class="fn">btw_refl</span> := <span class="fn">⋯</span>, <span class="fn">btw_cyclic_left</span> := <span class="fn">⋯</span>,
    <span class="fn">sbtw_iff_btw_not_btw</span> := <span class="fn">⋯</span>, <span class="fn">sbtw_trans_left</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/Order/Circular.html#CircularPreorder.mk">}</a></li></ul></details></div></div><div class="decl" id="OrderDual.circularPartialOrder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L432-L434">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#OrderDual.circularPartialOrder"><span class="name">OrderDual</span>.<span class="name">circularPartialOrder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder">CircularPartialOrder</a> <span class="fn">α</span><a href="../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.circularPartialOrder">OrderDual.circularPartialOrder</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder.mk">{</a> <span class="fn">toCircularPreorder</span> := <span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.circularPreorder">OrderDual.circularPreorder</a> <span class="fn">α</span></span>, <span class="fn">btw_antisymm</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/Order/Circular.html#CircularPartialOrder.mk">}</a></li></ul></details></div></div><div class="decl" id="OrderDual.instCircularOrder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Circular.lean#L436-L438">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/Circular.html#OrderDual.instCircularOrder"><span class="name">OrderDual</span>.<span class="name">instCircularOrder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#CircularOrder">CircularOrder</a> <span class="fn">α</span><a href="../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.instCircularOrder">OrderDual.instCircularOrder</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Mathlib/Order/Circular.html#CircularOrder.mk">{</a> <span class="fn">toCircularPartialOrder</span> := <span class="fn"><a href="../.././Mathlib/Order/Circular.html#OrderDual.circularPartialOrder">OrderDual.circularPartialOrder</a> <span class="fn">α</span></span>, <span class="fn">btw_total</span> := <span class="fn">⋯</span> <a href="../.././Mathlib/Order/Circular.html#CircularOrder.mk">}</a></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
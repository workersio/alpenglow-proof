<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.LinearAlgebra.InvariantBasisNumber</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.LinearAlgebra.InvariantBasisNumber";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">LinearAlgebra</span>.<span class="name">InvariantBasisNumber</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/RingTheory/OrzechProperty.html">Mathlib.RingTheory.OrzechProperty</a></li><li><a href="../.././Mathlib/RingTheory/PrincipalIdealDomain.html">Mathlib.RingTheory.PrincipalIdealDomain</a></li><li><a href="../.././Mathlib/LinearAlgebra/Finsupp/Pi.html">Mathlib.LinearAlgebra.Finsupp.Pi</a></li><li><a href="../.././Mathlib/RingTheory/Noetherian/Orzech.html">Mathlib.RingTheory.Noetherian.Orzech</a></li><li><a href="../.././Mathlib/RingTheory/Ideal/Quotient/Basic.html">Mathlib.RingTheory.Ideal.Quotient.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.LinearAlgebra.InvariantBasisNumber" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#StrongRankCondition"><span class="name">StrongRankCondition</span></a></div><div class="nav_link"><a class="break_within" href="#strongRankCondition_iff"><span class="name">strongRankCondition_iff</span></a></div><div class="nav_link"><a class="break_within" href="#le_of_fin_injective"><span class="name">le_of_fin_injective</span></a></div><div class="nav_link"><a class="break_within" href="#strongRankCondition_iff_succ"><span class="name">strongRankCondition_iff_succ</span></a></div><div class="nav_link"><a class="break_within" href="#strongRankCondition_of_orzechProperty"><span class="name">strongRankCondition_of_orzechProperty</span></a></div><div class="nav_link"><a class="break_within" href="#card_le_of_injective"><span class="name">card_le_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#card_le_of_injective'"><span class="name">card_le_of_injective'</span></a></div><div class="nav_link"><a class="break_within" href="#RankCondition"><span class="name">RankCondition</span></a></div><div class="nav_link"><a class="break_within" href="#le_of_fin_surjective"><span class="name">le_of_fin_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#card_le_of_surjective"><span class="name">card_le_of_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#card_le_of_surjective'"><span class="name">card_le_of_surjective'</span></a></div><div class="nav_link"><a class="break_within" href="#Module.Finite.exists_nat_not_surjective"><span class="name">Module</span>.<span class="name">Finite</span>.<span class="name">exists_nat_not_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#rankCondition_of_strongRankCondition"><span class="name">rankCondition_of_strongRankCondition</span></a></div><div class="nav_link"><a class="break_within" href="#InvariantBasisNumber"><span class="name">InvariantBasisNumber</span></a></div><div class="nav_link"><a class="break_within" href="#invariantBasisNumber_of_rankCondition"><span class="name">invariantBasisNumber_of_rankCondition</span></a></div><div class="nav_link"><a class="break_within" href="#eq_of_fin_equiv"><span class="name">eq_of_fin_equiv</span></a></div><div class="nav_link"><a class="break_within" href="#card_eq_of_linearEquiv"><span class="name">card_eq_of_linearEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#nontrivial_of_invariantBasisNumber"><span class="name">nontrivial_of_invariantBasisNumber</span></a></div><div class="nav_link"><a class="break_within" href="#IsNoetherianRing.strongRankCondition"><span class="name">IsNoetherianRing</span>.<span class="name">strongRankCondition</span></a></div><div class="nav_link"><a class="break_within" href="#invariantBasisNumber_of_nontrivial_of_commRing"><span class="name">invariantBasisNumber_of_nontrivial_of_commRing</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Invariant-basis-number-property">Invariant basis number property <a class="hover-link" href="#Invariant-basis-number-property">#</a></h1><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><p>Let <code>R</code> be a (not necessary commutative) ring.</p><ul>
<li><p><code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber">InvariantBasisNumber</a> R</code> is a type class stating that <code>(Fin n → R) ≃ₗ[R] (Fin m → R)</code>
implies <code>n = m</code>, a property known as the <em>invariant basis number property.</em></p>
<p>This assumption implies that there is a well-defined notion of the rank
of a finitely generated free (left) <code>R</code>-module.</p>
</li>
</ul><p>It is also useful to consider the following stronger conditions:</p><ul>
<li><p>The <em>rank condition</em>, witnessed by the type class <code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition">RankCondition</a> R</code>, states that
the existence of a surjective linear map <code>(Fin n → R) →ₗ[R] (Fin m → R)</code> implies <code>m ≤ n</code>.</p>
</li>
<li><p>The <em>strong rank condition</em>, witnessed by the type class <code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> R</code>, states
that the existence of an injective linear map <code>(Fin n → R) →ₗ[R] (Fin m → R)</code>
implies <code>n ≤ m</code>.</p>
</li>
<li><p><code><a href="../.././Mathlib/RingTheory/OrzechProperty.html#OrzechProperty">OrzechProperty</a> R</code>, defined in <code><a href="../.././Mathlib/RingTheory/OrzechProperty.html">Mathlib/RingTheory/OrzechProperty.lean</a></code>,
states that for any finitely generated <code>R</code>-module <code>M</code>, any surjective homomorphism <code>f : N → M</code>
from a submodule <code>N</code> of <code>M</code> to <code>M</code> is injective.</p>
</li>
</ul><h2 class="markdown-heading" id="Instances">Instances <a class="hover-link" href="#Instances">#</a></h2><ul>
<li><p><code><a href="../.././Mathlib/RingTheory/Noetherian/Orzech.html#IsNoetherianRing.orzechProperty">IsNoetherianRing.orzechProperty</a></code> (defined in <code><a href="../.././Mathlib/RingTheory/Noetherian.html">Mathlib/RingTheory/Noetherian.lean</a></code>) :
any left-Noetherian ring satisfies the Orzech property.
This applies in particular to division rings.</p>
</li>
<li><p><code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#strongRankCondition_of_orzechProperty">strongRankCondition_of_orzechProperty</a></code> : the Orzech property implies the strong rank condition
(for non-trivial rings).</p>
</li>
<li><p><code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#IsNoetherianRing.strongRankCondition">IsNoetherianRing.strongRankCondition</a></code> : every nontrivial left-Noetherian ring satisfies the
strong rank condition (and so in particular every division ring or field).</p>
</li>
<li><p><code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#rankCondition_of_strongRankCondition">rankCondition_of_strongRankCondition</a></code> : the strong rank condition implies the rank condition.</p>
</li>
<li><p><code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#invariantBasisNumber_of_rankCondition">invariantBasisNumber_of_rankCondition</a></code> : the rank condition implies the
invariant basis number property.</p>
</li>
<li><p><code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#invariantBasisNumber_of_nontrivial_of_commRing">invariantBasisNumber_of_nontrivial_of_commRing</a></code>: a nontrivial commutative ring satisfies
the invariant basis number property.</p>
</li>
</ul><p>More generally, every commutative ring satisfies the Orzech property,
hence the strong rank condition, which is proved in <code><a href="../.././Mathlib/RingTheory/FiniteType.html">Mathlib/RingTheory/FiniteType.lean</a></code>.
We keep <code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#invariantBasisNumber_of_nontrivial_of_commRing">invariantBasisNumber_of_nontrivial_of_commRing</a></code> here since it imports fewer files.</p><h2 class="markdown-heading" id="Counterexamples-to-converse-results">Counterexamples to converse results <a class="hover-link" href="#Counterexamples-to-converse-results">#</a></h2><p>The following examples can be found in the book of Lam [lam_1999]
(see also <a href="https://math.stackexchange.com/questions/4711904">https://math.stackexchange.com/questions/4711904</a>):</p><ul>
<li>Let <code>k</code> be a field, then the free (non-commutative) algebra <code>k⟨x, y⟩</code> satisfies
the rank condition but not the strong rank condition.</li>
<li>The free (non-commutative) algebra <code>ℚ⟨a, b, c, d⟩</code> quotient by the
two-sided ideal <code>(ac − 1, bd − 1, ab, cd)</code> satisfies the invariant basis number property
but not the rank condition.</li>
</ul><h2 class="markdown-heading" id="Future-work">Future work <a class="hover-link" href="#Future-work">#</a></h2><p>So far, there is no API at all for the <code><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber">InvariantBasisNumber</a></code> class. There are several natural
ways to formulate that a module <code>M</code> is finitely generated and free, for example
<code>M ≃ₗ[R] (Fin n → R)</code>, <code>M ≃ₗ[R] (ι → R)</code>, where <code>ι</code> is a fintype, or providing a basis indexed by
a finite type. There should be lemmas applying the invariant basis number property to each
situation.</p><p>The finite version of the invariant basis number property implies the infinite analogue, i.e., that
<code>(ι →₀ R) ≃ₗ[R] (ι' →₀ R)</code> implies that <code><a href="../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal.mk">Cardinal.mk</a> ι = <a href="../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal.mk">Cardinal.mk</a> ι'</code>. This fact (and its
variants) should be formalized.</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Invariant_basis_number">https://en.wikipedia.org/wiki/Invariant_basis_number</a></li>
<li><a href="https://mathoverflow.net/a/2574/">https://mathoverflow.net/a/2574/</a></li>
<li>[Lam, T. Y. <em>Lectures on Modules and Rings</em>][lam_1999]</li>
<li>[Orzech, Morris. <em>Onto endomorphisms are isomorphisms</em>][orzech1971]</li>
<li>[Djoković, D. Ž. <em>Epimorphisms of modules which must be isomorphisms</em>][djokovic1973]</li>
<li>[Ribenboim, Paulo.
<em>Épimorphismes de modules qui sont nécessairement des isomorphismes</em>][ribenboim1971]</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>free module, rank, Orzech property, (strong) rank condition, invariant basis number, IBN</p></div><div class="decl" id="StrongRankCondition"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L114-L119">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition"><span class="name">StrongRankCondition</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>We say that <code>R</code> satisfies the strong rank condition if <code>(Fin n → R) →ₗ[R] (Fin m → R)</code> injective
implies <code>n ≤ m</code>.</p><ul class="structure_fields" id="StrongRankCondition.mk"><li id="StrongRankCondition.le_of_fin_injective" class="structure_field"><div class="structure_field_info">le_of_fin_injective<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span> → <span class="fn">R</span></span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">f</span></span></span> → <span class="fn">n</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></div><div class="structure_field_doc"><p>Any injective linear map from <code>Rⁿ</code> to <code>Rᵐ</code> guarantees <code>n ≤ m</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-StrongRankCondition" class="instances-list"></ul></details></div></div><div class="decl" id="strongRankCondition_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L116-L116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#strongRankCondition_iff"><span class="name">strongRankCondition_iff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">n </span><span class="fn">m</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>} (<span class="fn">f</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span> → <span class="fn">R</span></span>), <span class="fn"><span class="fn"><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">f</span></span></span> → <span class="fn">n</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="le_of_fin_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L121-L123">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#le_of_fin_injective"><span class="name">le_of_fin_injective</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span> → <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">f</span></span></span> → <span class="fn">n</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="strongRankCondition_iff_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L125-L136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#strongRankCondition_iff_succ"><span class="name">strongRankCondition_iff_succ</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>) (<span class="fn">f</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> (<span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span></span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">f</span></span></span></span></div></div><p>A ring satisfies the strong rank condition if and only if, for all <code>n : ℕ</code>, any linear map
<code>(Fin (n + 1) → R) →ₗ[R] (Fin n → R)</code> is not injective.</p></div></div><div class="decl" id="strongRankCondition_of_orzechProperty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L138-L152">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#strongRankCondition_of_orzechProperty"><span class="name">strongRankCondition_of_orzechProperty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/RingTheory/OrzechProperty.html#OrzechProperty">OrzechProperty</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span></div></div><p>Any nontrivial ring satisfying Orzech property also satisfies strong rank condition.</p></div></div><div class="decl" id="card_le_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L154-L160">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#card_le_of_injective"><span class="name">card_le_of_injective</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">α</span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn">β</span> → <span class="fn">R</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span></div></div></div></div><div class="decl" id="card_le_of_injective'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L162-L168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#card_le_of_injective'"><span class="name">card_le_of_injective'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : (<span class="fn">α</span> <a href="../.././Mathlib/Data/Finsupp/Defs.html#Finsupp">→₀</a> <span class="fn">R</span>) <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn">β</span> <a href="../.././Mathlib/Data/Finsupp/Defs.html#Finsupp">→₀</a> <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span></div></div></div></div><div class="decl" id="RankCondition"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L170-L174">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition"><span class="name">RankCondition</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>We say that <code>R</code> satisfies the rank condition if <code>(Fin n → R) →ₗ[R] (Fin m → R)</code> surjective
implies <code>m ≤ n</code>.</p><ul class="structure_fields" id="RankCondition.mk"><li id="RankCondition.le_of_fin_surjective" class="structure_field"><div class="structure_field_info">le_of_fin_surjective<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span> → <span class="fn">R</span></span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span> → <span class="fn">m</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></div><div class="structure_field_doc"><p>Any surjective linear map from <code>Rⁿ</code> to <code>Rᵐ</code> guarantees <code>m ≤ n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-RankCondition" class="instances-list"></ul></details></div></div><div class="decl" id="le_of_fin_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L176-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#le_of_fin_surjective"><span class="name">le_of_fin_surjective</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition">RankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span> → <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span> → <span class="fn">m</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="card_le_of_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L180-L186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#card_le_of_surjective"><span class="name">card_le_of_surjective</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition">RankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">α</span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn">β</span> → <span class="fn">R</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="card_le_of_surjective'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L188-L194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#card_le_of_surjective'"><span class="name">card_le_of_surjective'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition">RankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : (<span class="fn">α</span> <a href="../.././Mathlib/Data/Finsupp/Defs.html#Finsupp">→₀</a> <span class="fn">R</span>) <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn">β</span> <a href="../.././Mathlib/Data/Finsupp/Defs.html#Finsupp">→₀</a> <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="Module.Finite.exists_nat_not_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L196-L199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#Module.Finite.exists_nat_not_surjective"><span class="name">Module</span>.<span class="name">Finite</span>.<span class="name">exists_nat_not_surjective</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition">RankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">M</span> : <a href="../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Module/Defs.html#Module">Module</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/RingTheory/Finiteness/Defs.html#Module.Finite">Module.Finite</a> <span class="fn">R</span> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">n</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>), <span class="fn">∀ (<span class="fn">f</span> : <span class="fn">M</span> <a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">→ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span></span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span></span></span></div></div></div></div><div class="decl" id="rankCondition_of_strongRankCondition"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L201-L208">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#rankCondition_of_strongRankCondition"><span class="name">rankCondition_of_strongRankCondition</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition">RankCondition</a> <span class="fn">R</span></span></div></div><p>By the universal property for free modules, any surjective map <code>(Fin n → R) →ₗ[R] (Fin m → R)</code>
has an injective splitting <code>(Fin m → R) →ₗ[R] (Fin n → R)</code>
from which the strong rank condition gives the necessary inequality for the rank condition.</p></div></div><div class="decl" id="InvariantBasisNumber"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L210-L215">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber"><span class="name">InvariantBasisNumber</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>We say that <code>R</code> has the invariant basis number property if <code>(Fin n → R) ≃ₗ[R] (Fin m → R)</code>
implies <code>n = m</code>. This gives rise to a well-defined notion of rank of a finitely generated free
module.</p><ul class="structure_fields" id="InvariantBasisNumber.mk"><li id="InvariantBasisNumber.eq_of_fin_equiv" class="structure_field"><div class="structure_field_info">eq_of_fin_equiv<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/Equiv/Defs.html#LinearEquiv">≃ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/Equiv/Defs.html#LinearEquiv">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span> → <span class="fn">R</span></span>), <span class="fn">n</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></div><div class="structure_field_doc"><p>Any linear equiv between <code>Rⁿ</code> and <code>Rᵐ</code> guarantees <code>m = n</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-InvariantBasisNumber" class="instances-list"></ul></details></div></div><div class="decl" id="invariantBasisNumber_of_rankCondition"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L217-L220">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#invariantBasisNumber_of_rankCondition"><span class="name">invariantBasisNumber_of_rankCondition</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#RankCondition">RankCondition</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber">InvariantBasisNumber</a> <span class="fn">R</span></span></div></div></div></div><div class="decl" id="eq_of_fin_equiv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L228-L229">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#eq_of_fin_equiv"><span class="name">eq_of_fin_equiv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber">InvariantBasisNumber</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">m</span> : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/Equiv/Defs.html#LinearEquiv">≃ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/Equiv/Defs.html#LinearEquiv">]</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span> → <span class="fn">R</span></span>), <span class="fn">n</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="card_eq_of_linearEquiv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L231-L235">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#card_eq_of_linearEquiv"><span class="name">card_eq_of_linearEquiv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber">InvariantBasisNumber</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">α</span> → <span class="fn">R</span>)</span> <a href="../.././Mathlib/Algebra/Module/Equiv/Defs.html#LinearEquiv">≃ₗ[</a><span class="fn">R</span><a href="../.././Mathlib/Algebra/Module/Equiv/Defs.html#LinearEquiv">]</a> <span class="fn"><span class="fn">β</span> → <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Data/Fintype/Card.html#Fintype.card">Fintype.card</a> <span class="fn">β</span></span></div></div></div></div><div class="decl" id="nontrivial_of_invariantBasisNumber"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L237-L248">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#nontrivial_of_invariantBasisNumber"><span class="name">nontrivial_of_invariantBasisNumber</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Semiring">Semiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber">InvariantBasisNumber</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">R</span></span></div></div></div></div><div class="decl" id="IsNoetherianRing.strongRankCondition"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L256-L259">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#IsNoetherianRing.strongRankCondition"><span class="name">IsNoetherianRing</span>.<span class="name">strongRankCondition</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/RingTheory/Noetherian/Defs.html#IsNoetherianRing">IsNoetherianRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#StrongRankCondition">StrongRankCondition</a> <span class="fn">R</span></span></div></div><p>Any nontrivial Noetherian ring satisfies the strong rank condition,
since it satisfies Orzech property.</p></div></div><div class="mod_doc"><p>We want to show that nontrivial commutative rings have invariant basis number. The idea is to
take a maximal ideal <code>I</code> of <code>R</code> and use an isomorphism <code>R^n ≃ R^m</code> of <code>R</code> modules to produce an
isomorphism <code>(R/I)^n ≃ (R/I)^m</code> of <code>R/I</code>-modules, which will imply <code>n = m</code> since <code>R/I</code> is a field
and we know that fields have invariant basis number.</p><p>We construct the isomorphism in two steps:</p><ol>
<li>We construct the ring <code>R^n/I^n</code>, show that it is an <code>R/I</code>-module and show that there is an
isomorphism of <code>R/I</code>-modules <code>R^n/I^n ≃ (R/I)^n</code>. This isomorphism is called
<code><a href="../.././Mathlib/RingTheory/Ideal/Quotient/Basic.html#Ideal.piQuotEquiv">Ideal.piQuotEquiv</a></code> and is located in the file <code><a href="../.././RingTheory/Ideals.html">RingTheory/Ideals.lean</a></code>.</li>
<li>We construct an isomorphism of <code>R/I</code>-modules <code>R^n/I^n ≃ R^m/I^m</code> using the isomorphism
<code>R^n ≃ R^m</code>.</li>
</ol></div><div class="decl" id="invariantBasisNumber_of_nontrivial_of_commRing"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/LinearAlgebra/InvariantBasisNumber.lean#L309-L323">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#invariantBasisNumber_of_nontrivial_of_commRing"><span class="name">invariantBasisNumber_of_nontrivial_of_commRing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Algebra/Ring/Defs.html#CommRing">CommRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/LinearAlgebra/InvariantBasisNumber.html#InvariantBasisNumber">InvariantBasisNumber</a> <span class="fn">R</span></span></div></div><p>Nontrivial commutative rings have the invariant basis number property.</p><p>There are two stronger results in mathlib: <code>commRing_strongRankCondition</code>, which says that any
nontrivial commutative ring satisfies the strong rank condition, and
<code>rankCondition_of_nontrivial_of_commSemiring</code>, which says that any nontrivial commutative semiring
satisfies the rank condition.</p><p>We prove this instance separately to avoid dependency on
<code><a href="../.././Mathlib/LinearAlgebra/Charpoly/Basic.html">Mathlib/LinearAlgebra/Charpoly/Basic.lean</a></code> or <code><a href="../.././Mathlib/LinearAlgebra/Matrix/ToLin.html">Mathlib/LinearAlgebra/Matrix/ToLin.lean</a></code>.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.GroupTheory.Congruence.Hom</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.GroupTheory.Congruence.Hom";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">GroupTheory</span>.<span class="name">Congruence</span>.<span class="name">Hom</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html">Mathlib.GroupTheory.Congruence.Defs</a></li><li><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html">Mathlib.Algebra.Group.Hom.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.GroupTheory.Congruence.Hom" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Con.mkMulHom"><span class="name">Con</span>.<span class="name">mkMulHom</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mkAddHom"><span class="name">AddCon</span>.<span class="name">mkAddHom</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mkMulHom_apply"><span class="name">Con</span>.<span class="name">mkMulHom_apply</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mkAddHom_apply"><span class="name">AddCon</span>.<span class="name">mkAddHom_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Con.ker"><span class="name">Con</span>.<span class="name">ker</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.ker"><span class="name">AddCon</span>.<span class="name">ker</span></a></div><div class="nav_link"><a class="break_within" href="#Con.ker_coeMulHom"><span class="name">Con</span>.<span class="name">ker_coeMulHom</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.ker_coeAddHom"><span class="name">AddCon</span>.<span class="name">ker_coeAddHom</span></a></div><div class="nav_link"><a class="break_within" href="#Con.ker_rel"><span class="name">Con</span>.<span class="name">ker_rel</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.ker_rel"><span class="name">AddCon</span>.<span class="name">ker_rel</span></a></div><div class="nav_link"><a class="break_within" href="#Con.ker_mkMulHom_eq"><span class="name">Con</span>.<span class="name">ker_mkMulHom_eq</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.ker_mkAddHom_eq"><span class="name">AddCon</span>.<span class="name">ker_mkAddHom_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mulKer"><span class="name">Con</span>.<span class="name">mulKer</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.addKer"><span class="name">AddCon</span>.<span class="name">addKer</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mul_ker_mk_eq"><span class="name">Con</span>.<span class="name">mul_ker_mk_eq</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.add_ker_mk_eq"><span class="name">AddCon</span>.<span class="name">add_ker_mk_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mapGen"><span class="name">Con</span>.<span class="name">mapGen</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mapGen"><span class="name">AddCon</span>.<span class="name">mapGen</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mapOfSurjective"><span class="name">Con</span>.<span class="name">mapOfSurjective</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mapOfSurjective"><span class="name">AddCon</span>.<span class="name">mapOfSurjective</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mapOfSurjective_eq_mapGen"><span class="name">Con</span>.<span class="name">mapOfSurjective_eq_mapGen</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mapOfSurjective_eq_mapGen"><span class="name">AddCon</span>.<span class="name">mapOfSurjective_eq_mapGen</span></a></div><div class="nav_link"><a class="break_within" href="#Con.correspondence"><span class="name">Con</span>.<span class="name">correspondence</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.correspondence"><span class="name">AddCon</span>.<span class="name">correspondence</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mk'"><span class="name">Con</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mk'"><span class="name">AddCon</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mk'_ker"><span class="name">Con</span>.<span class="name">mk'_ker</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mk'_ker"><span class="name">AddCon</span>.<span class="name">mk'_ker</span></a></div><div class="nav_link"><a class="break_within" href="#Con.mk'_surjective"><span class="name">Con</span>.<span class="name">mk'_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.mk'_surjective"><span class="name">AddCon</span>.<span class="name">mk'_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Con.coe_mk'"><span class="name">Con</span>.<span class="name">coe_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.coe_mk'"><span class="name">AddCon</span>.<span class="name">coe_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Con.ker_apply"><span class="name">Con</span>.<span class="name">ker_apply</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.ker_apply"><span class="name">AddCon</span>.<span class="name">ker_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Con.comap_eq"><span class="name">Con</span>.<span class="name">comap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.comap_eq"><span class="name">AddCon</span>.<span class="name">comap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift"><span class="name">Con</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift"><span class="name">AddCon</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift_mk'"><span class="name">Con</span>.<span class="name">lift_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift_mk'"><span class="name">AddCon</span>.<span class="name">lift_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift_coe"><span class="name">Con</span>.<span class="name">lift_coe</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift_coe"><span class="name">AddCon</span>.<span class="name">lift_coe</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift_comp_mk'"><span class="name">Con</span>.<span class="name">lift_comp_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift_comp_mk'"><span class="name">AddCon</span>.<span class="name">lift_comp_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift_apply_mk'"><span class="name">Con</span>.<span class="name">lift_apply_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift_apply_mk'"><span class="name">AddCon</span>.<span class="name">lift_apply_mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Con.hom_ext"><span class="name">Con</span>.<span class="name">hom_ext</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.hom_ext"><span class="name">AddCon</span>.<span class="name">hom_ext</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.hom_ext_iff"><span class="name">AddCon</span>.<span class="name">hom_ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Con.hom_ext_iff"><span class="name">Con</span>.<span class="name">hom_ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift_funext"><span class="name">Con</span>.<span class="name">lift_funext</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift_funext"><span class="name">AddCon</span>.<span class="name">lift_funext</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift_unique"><span class="name">Con</span>.<span class="name">lift_unique</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift_unique"><span class="name">AddCon</span>.<span class="name">lift_unique</span></a></div><div class="nav_link"><a class="break_within" href="#Con.lift_surjective_of_surjective"><span class="name">Con</span>.<span class="name">lift_surjective_of_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.lift_surjective_of_surjective"><span class="name">AddCon</span>.<span class="name">lift_surjective_of_surjective</span></a></div><div class="nav_link"><a class="break_within" href="#Con.ker_eq_lift_of_injective"><span class="name">Con</span>.<span class="name">ker_eq_lift_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.ker_eq_lift_of_injective"><span class="name">AddCon</span>.<span class="name">ker_eq_lift_of_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Con.kerLift"><span class="name">Con</span>.<span class="name">kerLift</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.kerLift"><span class="name">AddCon</span>.<span class="name">kerLift</span></a></div><div class="nav_link"><a class="break_within" href="#Con.kerLift_mk"><span class="name">Con</span>.<span class="name">kerLift_mk</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.kerLift_mk"><span class="name">AddCon</span>.<span class="name">kerLift_mk</span></a></div><div class="nav_link"><a class="break_within" href="#Con.kerLift_injective"><span class="name">Con</span>.<span class="name">kerLift_injective</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.kerLift_injective"><span class="name">AddCon</span>.<span class="name">kerLift_injective</span></a></div><div class="nav_link"><a class="break_within" href="#Con.map"><span class="name">Con</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.map"><span class="name">AddCon</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Con.map_apply"><span class="name">Con</span>.<span class="name">map_apply</span></a></div><div class="nav_link"><a class="break_within" href="#AddCon.map_apply"><span class="name">AddCon</span>.<span class="name">map_apply</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Congruence-relations-and-homomorphisms">Congruence relations and homomorphisms <a class="hover-link" href="#Congruence-relations-and-homomorphisms">#</a></h1><p>This file contains elementary definitions involving congruence relations and morphisms.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">Con.ker</a></code>: the kernel of a monoid homomorphism as a congruence relation</li>
<li><code><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">Con.mk'</a></code>: the map from a monoid to its quotient by a congruence relation</li>
<li><code><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">Con.lift</a></code>: the homomorphism on the quotient given that the congruence is in the kernel</li>
<li><code><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.map">Con.map</a></code>: homomorphism from a smaller to a larger quotient</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>congruence, congruence relation, quotient, quotient by congruence relation, monoid,
quotient monoid</p></div><div class="decl" id="Con.mkMulHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L40-L45">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mkMulHom"><span class="name">Con</span>.<span class="name">mkMulHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHom">→ₙ*</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span></div></div><p>The natural homomorphism from a magma to its quotient by a congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mkMulHom">mkMulHom</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHom.mk">{</a> <span class="fn">toFun</span> := <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.toQuotient">Con.toQuotient</a>, <span class="fn">map_mul'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHom.mk">}</a></li></ul></details><details id="instances-for-list-Con.mkMulHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.mkAddHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L41-L42">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mkAddHom"><span class="name">AddCon</span>.<span class="name">mkAddHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHom">→ₙ+</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span></div></div><p>The natural homomorphism from an additive magma to its quotient by
an additive congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mkAddHom">mkAddHom</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHom.mk">{</a> <span class="fn">toFun</span> := <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.toQuotient">AddCon.toQuotient</a>, <span class="fn">map_add'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHom.mk">}</a></li></ul></details><details id="instances-for-list-AddCon.mkAddHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.mkMulHom_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L41-L41">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mkMulHom_apply"><span class="name">Con</span>.<span class="name">mkMulHom_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a✝</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mkMulHom">mkMulHom</a></span> <span class="fn">a✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑<span class="fn">a✝</span></span></div></div></div></div><div class="decl" id="AddCon.mkAddHom_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L41-L41">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mkAddHom_apply"><span class="name">AddCon</span>.<span class="name">mkAddHom_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a✝</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mkAddHom">mkAddHom</a></span> <span class="fn">a✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">↑<span class="fn">a✝</span></span></div></div></div></div><div class="decl" id="Con.ker"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L46-L52">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker"><span class="name">Con</span>.<span class="name">ker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHomClass">MulHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span></div></div><p>The kernel of a multiplicative homomorphism as a congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">Con.ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.mk">{</a> <span class="fn">toSetoid</span> := <span class="fn"><a href="../../.././Mathlib/Data/Setoid/Basic.html#Setoid.ker">Setoid.ker</a> <span class="fn">⇑<span class="fn">f</span></span></span>, <span class="fn">mul'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.mk">}</a></li></ul></details><details id="instances-for-list-Con.ker" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.ker"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L47-L47">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker"><span class="name">AddCon</span>.<span class="name">ker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHomClass">AddHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span></div></div><p>The kernel of an additive homomorphism as an additive congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">AddCon.ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.mk">{</a> <span class="fn">toSetoid</span> := <span class="fn"><a href="../../.././Mathlib/Data/Setoid/Basic.html#Setoid.ker">Setoid.ker</a> <span class="fn">⇑<span class="fn">f</span></span></span>, <span class="fn">add'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.mk">}</a></li></ul></details><details id="instances-for-list-AddCon.ker" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.ker_coeMulHom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L54-L55">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker_coeMulHom"><span class="name">Con</span>.<span class="name">ker_coeMulHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHomClass">MulHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">↑<span class="fn">f</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="AddCon.ker_coeAddHom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L54-L54">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker_coeAddHom"><span class="name">AddCon</span>.<span class="name">ker_coeAddHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHomClass">AddHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">↑<span class="fn">f</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Con.ker_rel"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L57-L61">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker_rel"><span class="name">Con</span>.<span class="name">ker_rel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHomClass">MulHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span>)</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></div></div><p>The definition of the congruence relation defined by a monoid homomorphism's kernel.</p></div></div><div class="decl" id="AddCon.ker_rel"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L58-L59">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker_rel"><span class="name">AddCon</span>.<span class="name">ker_rel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHomClass">AddHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span>)</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></div></div><p>The definition of the additive congruence relation defined by an
<code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> homomorphism's kernel.</p></div></div><div class="decl" id="Con.ker_mkMulHom_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L63-L66">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker_mkMulHom_eq"><span class="name">Con</span>.<span class="name">ker_mkMulHom_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mkMulHom">mkMulHom</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="AddCon.ker_mkAddHom_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L63-L64">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker_mkAddHom_eq"><span class="name">AddCon</span>.<span class="name">ker_mkAddHom_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mkAddHom">mkAddHom</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>The kernel of the quotient map induced by an additive congruence
relation <code>c</code> equals <code>c</code>.</p></div></div><div class="decl" id="Con.mulKer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L68-L72">source</a></div><div class="attributes">@[reducible, inline, deprecated Con.ker (since := &quot;2025-03-23&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mulKer"><span class="name">Con</span>.<span class="name">mulKer</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">M</span> → <span class="fn">P</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">M</span>), <span class="fn"><span class="fn">f</span> (<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span></div></div><p>The kernel of a multiplication-preserving function as a congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mulKer">Con.mulKer</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">Con.ker</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHom.mk">{</a> <span class="fn">toFun</span> := <span class="fn">f</span>, <span class="fn">map_mul'</span> := <span class="fn">h</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHom.mk">}</a></span></li></ul></details><details id="instances-for-list-Con.mulKer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.addKer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L69-L70">source</a></div><div class="attributes">@[reducible, inline, deprecated AddCon.ker (since := &quot;2025-03-23&quot;)]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.addKer"><span class="name">AddCon</span>.<span class="name">addKer</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">M</span> → <span class="fn">P</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">M</span>), <span class="fn"><span class="fn">f</span> (<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">y</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span></div></div><p>The kernel of an addition-preserving function as an additive congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.addKer">AddCon.addKer</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">AddCon.ker</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHom.mk">{</a> <span class="fn">toFun</span> := <span class="fn">f</span>, <span class="fn">map_add'</span> := <span class="fn">h</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHom.mk">}</a></span></li></ul></details><details id="instances-for-list-AddCon.addKer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.mul_ker_mk_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L78-L83">source</a></div><div class="attributes">@[simp, deprecated Con.ker_mkMulHom_eq (since := &quot;2025-03-23&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mul_ker_mk_eq"><span class="name">Con</span>.<span class="name">mul_ker_mk_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mulKer">mulKer</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.toQuotient">toQuotient</a> <span class="fn">⋯</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>The kernel of the quotient map induced by a congruence relation <code>c</code> equals <code>c</code>.</p></div></div><div class="decl" id="AddCon.add_ker_mk_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L79-L80">source</a></div><div class="attributes">@[simp, deprecated AddCon.ker_mkAddHom_eq (since := &quot;2025-03-23&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.add_ker_mk_eq"><span class="name">AddCon</span>.<span class="name">add_ker_mk_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.addKer">addKer</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.toQuotient">toQuotient</a> <span class="fn">⋯</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>The kernel of the quotient map induced by an additive congruence
relation <code>c</code> equals <code>c</code>.</p></div></div><div class="decl" id="Con.mapGen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L88-L95">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mapGen"><span class="name">Con</span>.<span class="name">mapGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">M</span> → <span class="fn">N</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">N</span></span></div></div><p>Given a function <code>f</code>, the smallest congruence relation containing the binary relation on <code>f</code>'s
image defined by '<code>x ≈ y</code> iff the elements of <code>f⁻¹(x)</code> are related to the elements of <code>f⁻¹(y)</code>
by a congruence relation <code>c</code>.'</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mapGen">Con.mapGen</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#conGen">conGen</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">(⇑<span class="fn">c</span>)</span> <span class="fn">f</span> <span class="fn">f</span>)</span></span></li></ul></details><details id="instances-for-list-Con.mapGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.mapGen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L91-L93">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mapGen"><span class="name">AddCon</span>.<span class="name">mapGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">M</span> → <span class="fn">N</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">N</span></span></div></div><p>Given a function <code>f</code>, the smallest additive congruence relation containing the
binary relation on <code>f</code>'s image defined by '<code>x ≈ y</code> iff the elements of <code>f⁻¹(x)</code> are related to the
elements of <code>f⁻¹(y)</code> by an additive congruence relation <code>c</code>.'</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mapGen">AddCon.mapGen</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#addConGen">addConGen</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">(⇑<span class="fn">c</span>)</span> <span class="fn">f</span> <span class="fn">f</span>)</span></span></li></ul></details><details id="instances-for-list-AddCon.mapGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.mapOfSurjective"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L97-L108">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mapOfSurjective"><span class="name">Con</span>.<span class="name">mapOfSurjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHomClass">MulHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">N</span></span></div></div><p>Given a surjective multiplicative-preserving function <code>f</code> whose kernel is contained in a
congruence relation <code>c</code>, the congruence relation on <code>f</code>'s codomain defined by '<code>x ≈ y</code> iff the
elements of <code>f⁻¹(x)</code> are related to the elements of <code>f⁻¹(y)</code> by <code>c</code>.'</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mapOfSurjective">Con.mapOfSurjective</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">hf</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.mk">{</a> <span class="fn">toSetoid</span> := <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/Data/Setoid/Basic.html#Setoid.mapOfSurjective">mapOfSurjective</a></span> <span class="fn">(⇑<span class="fn">f</span>)</span> <span class="fn">h</span> <span class="fn">hf</span></span>, <span class="fn">mul'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.mk">}</a></li></ul></details><details id="instances-for-list-Con.mapOfSurjective" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.mapOfSurjective"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L100-L102">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mapOfSurjective"><span class="name">AddCon</span>.<span class="name">mapOfSurjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHomClass">AddHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">N</span></span></div></div><p>Given a surjective addition-preserving function <code>f</code> whose kernel is contained in
an additive congruence relation <code>c</code>, the additive congruence relation on <code>f</code>'s codomain defined
by '<code>x ≈ y</code> iff the elements of <code>f⁻¹(x)</code> are related to the elements of <code>f⁻¹(y)</code> by <code>c</code>.'</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mapOfSurjective">AddCon.mapOfSurjective</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">hf</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.mk">{</a> <span class="fn">toSetoid</span> := <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/Data/Setoid/Basic.html#Setoid.mapOfSurjective">mapOfSurjective</a></span> <span class="fn">(⇑<span class="fn">f</span>)</span> <span class="fn">h</span> <span class="fn">hf</span></span>, <span class="fn">add'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.mk">}</a></li></ul></details><details id="instances-for-list-AddCon.mapOfSurjective" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.mapOfSurjective_eq_mapGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L110-L116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mapOfSurjective_eq_mapGen"><span class="name">Con</span>.<span class="name">mapOfSurjective_eq_mapGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHomClass">MulHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">F</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mapGen">mapGen</a> <span class="fn">⇑<span class="fn">f</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mapOfSurjective">mapOfSurjective</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">hf</span></span></div></div><p>A specialization of 'the smallest congruence relation containing a congruence relation <code>c</code>
equals <code>c</code>'.</p></div></div><div class="decl" id="AddCon.mapOfSurjective_eq_mapGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L112-L113">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mapOfSurjective_eq_mapGen"><span class="name">AddCon</span>.<span class="name">mapOfSurjective_eq_mapGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/FunLike/Basic.html#FunLike">FunLike</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHomClass">AddHomClass</a> <span class="fn">F</span> <span class="fn">M</span> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">F</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mapGen">mapGen</a> <span class="fn">⇑<span class="fn">f</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mapOfSurjective">mapOfSurjective</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">hf</span></span></div></div><p>A specialization of 'the smallest additive congruence relation containing
an additive congruence relation <code>c</code> equals <code>c</code>'.</p></div></div><div class="decl" id="Con.correspondence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L118-L147">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.correspondence"><span class="name">Con</span>.<span class="name">correspondence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Mul">Mul</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">d</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">d</span> <a href="../../.././Init/Prelude.html#Subtype">}</a> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderIso">≃o</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span></span></div></div><p>Given a congruence relation <code>c</code> on a type <code>M</code> with a multiplication, the order-preserving
bijection between the set of congruence relations containing <code>c</code> and the congruence relations
on the quotient of <code>M</code> by <code>c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Con.correspondence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.correspondence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L121-L123">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.correspondence"><span class="name">AddCon</span>.<span class="name">correspondence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Add">Add</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">d</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">d</span> <a href="../../.././Init/Prelude.html#Subtype">}</a> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderIso">≃o</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span></span></div></div><p>Given an additive congruence relation <code>c</code> on a type <code>M</code> with an addition,
the order-preserving bijection between the set of additive congruence relations containing <code>c</code> and
the additive congruence relations on the quotient of <code>M</code> by <code>c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-AddCon.correspondence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.mk'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L157-L162">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'"><span class="name">Con</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span></div></div><p>The natural homomorphism from a monoid to its quotient by a congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.mk">{</a> <span class="fn">toFun</span> := <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mkMulHom">mkMulHom</a></span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MulHom.toFun">toFun</a></span>, <span class="fn">map_one'</span> := <span class="fn">⋯</span>, <span class="fn">map_mul'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.mk">}</a></li></ul></details><details id="instances-for-list-Con.mk'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.mk'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L158-L159">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'"><span class="name">AddCon</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span></div></div><p>The natural homomorphism from an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> to its quotient by an additive
congruence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.mk">{</a> <span class="fn">toFun</span> := <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mkAddHom">mkAddHom</a></span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddHom.toFun">toFun</a></span>, <span class="fn">map_zero'</span> := <span class="fn">⋯</span>, <span class="fn">map_add'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.mk">}</a></li></ul></details><details id="instances-for-list-AddCon.mk'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.mk'_ker"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L166-L171">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'_ker"><span class="name">Con</span>.<span class="name">mk'_ker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>The kernel of the natural homomorphism from a monoid to its quotient by a congruence
relation <code>c</code> equals <code>c</code>.</p></div></div><div class="decl" id="AddCon.mk'_ker"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L168-L169">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'_ker"><span class="name">AddCon</span>.<span class="name">mk'_ker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>The kernel of the natural homomorphism from an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> to its
quotient by an additive congruence relation <code>c</code> equals <code>c</code>.</p></div></div><div class="decl" id="Con.mk'_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L175-L180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'_surjective"><span class="name">Con</span>.<span class="name">mk'_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span></span></div></div><p>The natural homomorphism from a monoid to its quotient by a congruence relation is
surjective.</p></div></div><div class="decl" id="AddCon.mk'_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L177-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'_surjective"><span class="name">AddCon</span>.<span class="name">mk'_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span></span></div></div><p>The natural homomorphism from an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> to its quotient by a congruence
relation is surjective.</p></div></div><div class="decl" id="Con.coe_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L182-L184">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.coe_mk'"><span class="name">Con</span>.<span class="name">coe_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">⇑<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.toQuotient">toQuotient</a></div></div></div></div><div class="decl" id="AddCon.coe_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L182-L182">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.coe_mk'"><span class="name">AddCon</span>.<span class="name">coe_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">⇑<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.toQuotient">toQuotient</a></div></div></div></div><div class="decl" id="Con.ker_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L186-L187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker_apply"><span class="name">Con</span>.<span class="name">ker_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span>)</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="AddCon.ker_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L186-L186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker_apply"><span class="name">AddCon</span>.<span class="name">ker_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">M</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span>)</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Con.comap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L189-L196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.comap_eq"><span class="name">Con</span>.<span class="name">comap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">N</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">M</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.comap">comap</a> <span class="fn">⇑<span class="fn">f</span></span> <span class="fn">⋯</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn">f</span>)</span></span></div></div><p>Given a monoid homomorphism <code>f : N → M</code> and a congruence relation <code>c</code> on <code>M</code>, the congruence
relation induced on <code>N</code> by <code>f</code> equals the kernel of <code>c</code>'s quotient homomorphism composed with
<code>f</code>.</p></div></div><div class="decl" id="AddCon.comap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L192-L194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.comap_eq"><span class="name">AddCon</span>.<span class="name">comap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">N</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">N</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">N</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">M</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.comap">comap</a> <span class="fn">⇑<span class="fn">f</span></span> <span class="fn">⋯</span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn">f</span>)</span></span></div></div><p>Given an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> homomorphism <code>f : N → M</code> and an additive congruence relation
<code>c</code> on <code>M</code>, the additive congruence relation induced on <code>N</code> by <code>f</code> equals the kernel of <code>c</code>'s
quotient homomorphism composed with <code>f</code>.</p></div></div><div class="decl" id="Con.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L200-L209">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift"><span class="name">Con</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span></div></div><p>The homomorphism on the quotient of a monoid by a congruence relation <code>c</code> induced by a
homomorphism constant on <code>c</code>'s equivalence classes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.mk">{</a> <span class="fn">toFun</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.liftOn">Con.liftOn</a> <span class="fn">x</span> <span class="fn">⇑<span class="fn">f</span></span> <span class="fn">⋯</span></span></span>, <span class="fn">map_one'</span> := <span class="fn">⋯</span>, <span class="fn">map_mul'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.mk">}</a></li></ul></details><details id="instances-for-list-Con.lift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L202-L203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift"><span class="name">AddCon</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span></div></div><p>The homomorphism on the quotient of an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> by an additive congruence
relation <code>c</code> induced by a homomorphism constant on <code>c</code>'s equivalence classes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.mk">{</a> <span class="fn">toFun</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.liftOn">AddCon.liftOn</a> <span class="fn">x</span> <span class="fn">⇑<span class="fn">f</span></span> <span class="fn">⋯</span></span></span>, <span class="fn">map_zero'</span> := <span class="fn">⋯</span>, <span class="fn">map_add'</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.mk">}</a></li></ul></details><details id="instances-for-list-AddCon.lift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.lift_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L213-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift_mk'"><span class="name">Con</span>.<span class="name">lift_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span> <span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span> <span class="fn">x</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></div></div><p>The diagram describing the universal property for quotients of monoids commutes.</p></div></div><div class="decl" id="AddCon.lift_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L214-L215">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift_mk'"><span class="name">AddCon</span>.<span class="name">lift_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span> <span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span> <span class="fn">x</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></div></div><p>The diagram describing the universal property for quotients of <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code>s
commutes.</p></div></div><div class="decl" id="Con.lift_coe"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L219-L223">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift_coe"><span class="name">Con</span>.<span class="name">lift_coe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span> <span class="fn">↑<span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></div></div><p>The diagram describing the universal property for quotients of monoids commutes.</p></div></div><div class="decl" id="AddCon.lift_coe"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L220-L221">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift_coe"><span class="name">AddCon</span>.<span class="name">lift_coe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span> <span class="fn">↑<span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></div></div><p>The diagram describing the universal property for quotients of
<code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code>s commutes.</p></div></div><div class="decl" id="Con.lift_comp_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L225-L228">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift_comp_mk'"><span class="name">Con</span>.<span class="name">lift_comp_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div><p>The diagram describing the universal property for quotients of monoids commutes.</p></div></div><div class="decl" id="AddCon.lift_comp_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L226-L227">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift_comp_mk'"><span class="name">AddCon</span>.<span class="name">lift_comp_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div><p>The diagram describing the universal property for quotients of
<code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code>s commutes.</p></div></div><div class="decl" id="Con.lift_apply_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L230-L238">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift_apply_mk'"><span class="name">Con</span>.<span class="name">lift_apply_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">(<span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span>)</span> <span class="fn">⋯</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div><p>Given a homomorphism <code>f</code> from the quotient of a monoid by a congruence relation, <code>f</code> equals the
homomorphism on the quotient induced by <code>f</code> composed with the natural map from the monoid to
the quotient.</p></div></div><div class="decl" id="AddCon.lift_apply_mk'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L233-L235">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift_apply_mk'"><span class="name">AddCon</span>.<span class="name">lift_apply_mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">(<span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span>)</span> <span class="fn">⋯</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></div></div><p>Given a homomorphism <code>f</code> from the quotient of an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> by an
additive congruence relation, <code>f</code> equals the homomorphism on the quotient induced by <code>f</code> composed
with the natural map from the <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> to the quotient.</p></div></div><div class="decl" id="Con.hom_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L240-L246">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.hom_ext"><span class="name">Con</span>.<span class="name">hom_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></div></div><p>Homomorphisms on the quotient of a monoid by a congruence relation <code>c</code> are equal if their
compositions with <code>c.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></code> are equal.</p></div></div><div class="decl" id="AddCon.hom_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L242-L243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.hom_ext"><span class="name">AddCon</span>.<span class="name">hom_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></div></div><p>Homomorphisms on the quotient of an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> by an additive
congruence relation <code>c</code> are equal if their compositions with <code>c.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></code> are equal.</p></div></div><div class="decl" id="AddCon.hom_ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L242-L242">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.hom_ext_iff"><span class="name">AddCon</span>.<span class="name">hom_ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span></div></div></div></div><div class="decl" id="Con.hom_ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L242-L242">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.hom_ext_iff"><span class="name">Con</span>.<span class="name">hom_ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span></div></div></div></div><div class="decl" id="Con.lift_funext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L248-L253">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift_funext"><span class="name">Con</span>.<span class="name">lift_funext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">M</span>), <span class="fn"><span class="fn">f</span> <span class="fn">↑<span class="fn">a</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">↑<span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></div></div><p>Homomorphisms on the quotient of a monoid by a congruence relation are equal if they
are equal on elements that are coercions from the monoid.</p></div></div><div class="decl" id="AddCon.lift_funext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L250-L251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift_funext"><span class="name">AddCon</span>.<span class="name">lift_funext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">M</span>), <span class="fn"><span class="fn">f</span> <span class="fn">↑<span class="fn">a</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">↑<span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></div></div><p>Homomorphisms on the quotient of an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> by an additive congruence relation
are equal if they are equal on elements that are coercions from the <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code>.</p></div></div><div class="decl" id="Con.lift_unique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L255-L259">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift_unique"><span class="name">Con</span>.<span class="name">lift_unique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Hg</span> : <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">g</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span></span></div></div><p>The uniqueness part of the universal property for quotients of monoids.</p></div></div><div class="decl" id="AddCon.lift_unique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L256-L256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift_unique"><span class="name">AddCon</span>.<span class="name">lift_unique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Hg</span> : <span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom.comp">comp</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">g</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span></span></div></div><p>The uniqueness part of the universal property for quotients of <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code>s.</p></div></div><div class="decl" id="Con.lift_surjective_of_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L261-L267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift_surjective_of_surjective"><span class="name">Con</span>.<span class="name">lift_surjective_of_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">h</span>)</span></span></span></div></div><p>Surjective monoid homomorphisms constant on a congruence relation <code>c</code>'s equivalence classes
induce a surjective homomorphism on <code>c</code>'s quotient.</p></div></div><div class="decl" id="AddCon.lift_surjective_of_surjective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L263-L264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift_surjective_of_surjective"><span class="name">AddCon</span>.<span class="name">lift_surjective_of_surjective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Function.html#Function.Surjective">Function.Surjective</a> <span class="fn">⇑<span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">h</span>)</span></span></span></div></div><p>Surjective <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> homomorphisms constant on an additive congruence
relation <code>c</code>'s equivalence classes induce a surjective homomorphism on <code>c</code>'s quotient.</p></div></div><div class="decl" id="Con.ker_eq_lift_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L271-L277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker_eq_lift_of_injective"><span class="name">Con</span>.<span class="name">ker_eq_lift_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>Given a monoid homomorphism <code>f</code> from <code>M</code> to <code>P</code>, the kernel of <code>f</code> is the unique congruence
relation on <code>M</code> whose induced map from the quotient of <code>M</code> to <code>P</code> is injective.</p></div></div><div class="decl" id="AddCon.ker_eq_lift_of_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L273-L275">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker_eq_lift_of_injective"><span class="name">AddCon</span>.<span class="name">ker_eq_lift_of_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">H</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div><p>Given an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> homomorphism <code>f</code> from <code>M</code> to <code>P</code>, the kernel of <code>f</code>
is the unique additive congruence relation on <code>M</code> whose induced map from the quotient of <code>M</code>
to <code>P</code> is injective.</p></div></div><div class="decl" id="Con.kerLift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L281-L285">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.kerLift"><span class="name">Con</span>.<span class="name">kerLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">ker</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span></div></div><p>The homomorphism induced on the quotient of a monoid by the kernel of a monoid homomorphism.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.kerLift">Con.kerLift</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.ker">Con.ker</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn">f</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Con.kerLift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.kerLift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L282-L283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.kerLift"><span class="name">AddCon</span>.<span class="name">kerLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">ker</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span></div></div><p>The homomorphism induced on the quotient of an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> by the kernel
of an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> homomorphism.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.kerLift">AddCon.kerLift</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.ker">AddCon.ker</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn">f</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-AddCon.kerLift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.kerLift_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L289-L295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.kerLift_mk"><span class="name">Con</span>.<span class="name">kerLift_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.kerLift">kerLift</a> <span class="fn">f</span>)</span> <span class="fn">↑<span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></div></div><p>The diagram described by the universal property for quotients of monoids, when the congruence
relation is the kernel of the homomorphism, commutes.</p></div></div><div class="decl" id="AddCon.kerLift_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L291-L293">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.kerLift_mk"><span class="name">AddCon</span>.<span class="name">kerLift_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">M</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.kerLift">kerLift</a> <span class="fn">f</span>)</span> <span class="fn">↑<span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span></div></div><p>The diagram described by the universal property for quotients
of <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code>s, when the additive congruence relation is the kernel of the homomorphism,
commutes.</p></div></div><div class="decl" id="Con.kerLift_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L297-L301">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.kerLift_injective"><span class="name">Con</span>.<span class="name">kerLift_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.kerLift">kerLift</a> <span class="fn">f</span>)</span></span></span></div></div><p>A monoid homomorphism <code>f</code> induces an injective homomorphism on the quotient by <code>f</code>'s kernel.</p></div></div><div class="decl" id="AddCon.kerLift_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L298-L299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.kerLift_injective"><span class="name">AddCon</span>.<span class="name">kerLift_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">M</span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn">P</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn">⇑<span class="fn">(<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.kerLift">kerLift</a> <span class="fn">f</span>)</span></span></span></div></div><p>An <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> homomorphism <code>f</code> induces an injective homomorphism on the quotient
by <code>f</code>'s kernel.</p></div></div><div class="decl" id="Con.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L303-L309">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.map"><span class="name">Con</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom">→*</a> <span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span></div></div><p>Given congruence relations <code>c, d</code> on a monoid such that <code>d</code> contains <code>c</code>, <code>d</code>'s quotient
map induces a homomorphism from the quotient by <code>c</code> to the quotient by <code>d</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.map">map</a></span> <span class="fn">d</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Con.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AddCon.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L305-L307">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.map"><span class="name">AddCon</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">c </span><span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">d</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span> <a href="../../.././Mathlib/Algebra/Group/Hom/Defs.html#AddMonoidHom">→+</a> <span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span></div></div><p>Given additive congruence relations <code>c, d</code> on an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> such that <code>d</code>
contains <code>c</code>, <code>d</code>'s quotient map induces a homomorphism from the quotient by <code>c</code> to the quotient
by <code>d</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.map">map</a></span> <span class="fn">d</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-AddCon.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Con.map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L311-L318">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.map_apply"><span class="name">Con</span>.<span class="name">map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#MulOneClass">MulOneClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con">Con</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">d</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#Con.Quotient">Quotient</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.map">map</a></span> <span class="fn">d</span> <span class="fn">h</span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.lift">lift</a></span> <span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#Con.mk'">mk'</a></span> <span class="fn">⋯</span>)</span> <span class="fn">x</span></span></div></div><p>Given congruence relations <code>c, d</code> on a monoid such that <code>d</code> contains <code>c</code>, the definition of
the homomorphism from the quotient by <code>c</code> to the quotient by <code>d</code> induced by <code>d</code>'s quotient map.</p></div></div><div class="decl" id="AddCon.map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/GroupTheory/Congruence/Hom.lean#L313-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.map_apply"><span class="name">AddCon</span>.<span class="name">map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">M</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddZeroClass">AddZeroClass</a> <span class="fn">M</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c </span><span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon">AddCon</a> <span class="fn">M</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">c</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">d</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Defs.html#AddCon.Quotient">Quotient</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.map">map</a></span> <span class="fn">d</span> <span class="fn">h</span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">c</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.lift">lift</a></span> <span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/GroupTheory/Congruence/Hom.html#AddCon.mk'">mk'</a></span> <span class="fn">⋯</span>)</span> <span class="fn">x</span></span></div></div><p>Given additive congruence relations <code>c, d</code> on an <code><a href="../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid">AddMonoid</a></code> such that <code>d</code>
contains <code>c</code>, the definition of the homomorphism from the quotient by <code>c</code> to the quotient by <code>d</code>
induced by <code>d</code>'s quotient map.</p></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
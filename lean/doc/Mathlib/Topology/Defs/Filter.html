<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.Defs.Filter</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.Defs.Filter";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">Defs</span>.<span class="name">Filter</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Tactic/IrreducibleDef.html">Mathlib.Tactic.IrreducibleDef</a></li><li><a href="../../.././Mathlib/Data/Setoid/Basic.html">Mathlib.Data.Setoid.Basic</a></li><li><a href="../../.././Mathlib/Order/Filter/Defs.html">Mathlib.Order.Filter.Defs</a></li><li><a href="../../.././Mathlib/Topology/Defs/Basic.html">Mathlib.Topology.Defs.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.Defs.Filter" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#nhds_def"><span class="name">nhds_def</span></a></div><div class="nav_link"><a class="break_within" href="#nhds"><span class="name">nhds</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.term𝓝"><span class="name">Topology</span>.<span class="name">term𝓝</span></a></div><div class="nav_link"><a class="break_within" href="#nhdsWithin"><span class="name">nhdsWithin</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.«term𝓝[_]_»"><span class="name">Topology</span>.<span class="name">«term𝓝[_]_»</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.nhdsNE"><span class="name">Topology</span>.<span class="name">nhdsNE</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.nhdsGE"><span class="name">Topology</span>.<span class="name">nhdsGE</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.nhdsLE"><span class="name">Topology</span>.<span class="name">nhdsLE</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.nhdsGT"><span class="name">Topology</span>.<span class="name">nhdsGT</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.nhdsLT"><span class="name">Topology</span>.<span class="name">nhdsLT</span></a></div><div class="nav_link"><a class="break_within" href="#nhdsSet"><span class="name">nhdsSet</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.«term𝓝ˢ»"><span class="name">Topology</span>.<span class="name">«term𝓝ˢ»</span></a></div><div class="nav_link"><a class="break_within" href="#nhdsKer"><span class="name">nhdsKer</span></a></div><div class="nav_link"><a class="break_within" href="#exterior"><span class="name">exterior</span></a></div><div class="nav_link"><a class="break_within" href="#ContinuousAt"><span class="name">ContinuousAt</span></a></div><div class="nav_link"><a class="break_within" href="#ContinuousWithinAt"><span class="name">ContinuousWithinAt</span></a></div><div class="nav_link"><a class="break_within" href="#ContinuousOn"><span class="name">ContinuousOn</span></a></div><div class="nav_link"><a class="break_within" href="#Specializes"><span class="name">Specializes</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⤳_»"><span class="name">«term_⤳_»</span></a></div><div class="nav_link"><a class="break_within" href="#Inseparable"><span class="name">Inseparable</span></a></div><div class="nav_link"><a class="break_within" href="#specializationPreorder"><span class="name">specializationPreorder</span></a></div><div class="nav_link"><a class="break_within" href="#inseparableSetoid"><span class="name">inseparableSetoid</span></a></div><div class="nav_link"><a class="break_within" href="#SeparationQuotient"><span class="name">SeparationQuotient</span></a></div><div class="nav_link"><a class="break_within" href="#lim"><span class="name">lim</span></a></div><div class="nav_link"><a class="break_within" href="#limUnder"><span class="name">limUnder</span></a></div><div class="nav_link"><a class="break_within" href="#ClusterPt"><span class="name">ClusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#MapClusterPt"><span class="name">MapClusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#AccPt"><span class="name">AccPt</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact"><span class="name">IsCompact</span></a></div><div class="nav_link"><a class="break_within" href="#CompactSpace"><span class="name">CompactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#NoncompactSpace"><span class="name">NoncompactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#WeaklyLocallyCompactSpace"><span class="name">WeaklyLocallyCompactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#LocallyCompactSpace"><span class="name">LocallyCompactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#LocallyCompactPair"><span class="name">LocallyCompactPair</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.cocompact"><span class="name">Filter</span>.<span class="name">cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.coclosedCompact"><span class="name">Filter</span>.<span class="name">coclosedCompact</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Definitions-about-filters-in-topological-spaces">Definitions about filters in topological spaces <a class="hover-link" href="#Definitions-about-filters-in-topological-spaces">#</a></h1><p>In this file we define filters in topological spaces,
as well as other definitions that rely on <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a></code>s.</p><h2 class="markdown-heading" id="Main-Definitions">Main Definitions <a class="hover-link" href="#Main-Definitions">#</a></h2><h3 class="markdown-heading" id="Neighborhoods-filter">Neighborhoods filter <a class="hover-link" href="#Neighborhoods-filter">#</a></h3><ul>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> x</code>: the filter of neighborhoods of a point in a topological space,
denoted by <code>𝓝 x</code> in the <code>Topology</code> scope.
A set is called a neighborhood of <code>x</code>, if it includes an open set around <code>x</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> x s</code>: the filter of neighborhoods of a point within a set,
defined as <code>𝓝 x ⊓ 𝓟 s</code> and denoted by <code>𝓝[s] x</code>.
We also introduce notation for some special sets <code>s</code>, see below.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> s</code>: the filter of neighborhoods of a set in a topological space,
denoted by <code>𝓝ˢ s</code> in the <code>Topology</code> scope.
A set <code>t</code> is called a neighborhood of <code>s</code>, if it includes an open set that includes <code>s</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsKer">nhdsKer</a> s</code>: The <em>neighborhoods kernel</em> of a set is the intersection of all its neighborhoods.
In an Alexandrov-discrete space, this is the smallest neighborhood of the set.</p>
<p>Note that this construction is unnamed in the literature.
We choose the name in analogy to <code><a href="../../.././Mathlib/Topology/Defs/Basic.html#interior">interior</a></code>.</p>
</li>
</ul><h3 class="markdown-heading" id="Continuity-at-a-point">Continuity at a point <a class="hover-link" href="#Continuity-at-a-point">#</a></h3><ul>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousAt">ContinuousAt</a> f x</code>: a function <code>f</code> is continuous at a point <code>x</code>,
if it tends to <code>𝓝 (f x)</code> along <code>𝓝 x</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousWithinAt">ContinuousWithinAt</a> f s x</code>: a function <code>f</code> is continuous within a set <code>s</code> at a point <code>x</code>,
if it tends to <code>𝓝 (f x)</code> along <code>𝓝[s] x</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousOn">ContinuousOn</a> f s</code>: a function <code>f : X → Y</code> is continuous on a set <code>s</code>,
if it is continuous within <code>s</code> at every point of <code>s</code>.</p>
</li>
</ul><h3 class="markdown-heading" id="Limits">Limits <a class="hover-link" href="#Limits">#</a></h3><ul>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#lim">lim</a> f</code>: a limit of a filter <code>f</code> in a nonempty topological space.
If there exists <code>x</code> such that <code>f ≤ 𝓝 x</code>, then <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#lim">lim</a> f</code> is one of such points,
otherwise it is <code><a href="../../.././Init/Prelude.html#Classical.choice">Classical.choice</a> _</code>.</p>
<p>In a Hausdorff topological space, the limit is unique if it exists.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#lim">Ultrafilter.lim</a> f</code>: a limit of an ultrafilter <code>f</code>,
defined as the limit of <code>(f : <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> X)</code>
with a proof of <code><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> X</code> deduced from existence of an ultrafilter on <code>X</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#limUnder">limUnder</a> f g</code>: a limit of a filter <code>f</code> along a function <code>g</code>, defined as <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#lim">lim</a> (Filter.map g f)</code>.</p>
</li>
</ul><h3 class="markdown-heading" id="Cluster-points-and-accumulation-points">Cluster points and accumulation points <a class="hover-link" href="#Cluster-points-and-accumulation-points">#</a></h3><ul>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> x F</code>: a point <code>x</code> is a <em>cluster point</em> of a filter <code>F</code>,
if <code>𝓝 x</code> is not disjoint with <code>F</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a> x F u</code>: a point <code>x</code> is a <em>cluster point</em> of a function <code>u</code> along a filter <code>F</code>,
if it is a cluster point of the filter <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> u F</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt">AccPt</a> x F</code>: a point <code>x</code> is an <em>accumulation point</em> of a filter <code>F</code>,
if <code>𝓝[≠] x</code> is not disjoint with <code>F</code>.
Every accumulation point of a filter is its cluster point, but not vice versa.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> s</code>: a set <code>s</code> is compact if for every nontrivial filter <code>f</code> that contains <code>s</code>,
there exists <code>a ∈ s</code> such that every set of <code>f</code> meets every neighborhood of <code>a</code>.
Equivalently, a set <code>s</code> is compact if for any cover of <code>s</code> by open sets,
there exists a finite subcover.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a></code>, <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a></code>: typeclasses saying that the whole space
is a compact set / is not a compact set, respectively.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#WeaklyLocallyCompactSpace">WeaklyLocallyCompactSpace</a> X</code>: typeclass saying that every point of <code>X</code>
has a compact neighborhood.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#LocallyCompactSpace">LocallyCompactSpace</a> X</code>: typeclass saying that every point of <code>X</code>
has a basis of compact neighborhoods.
Every locally compact space is a weakly locally compact space.
The reverse implication is true for R₁ (preregular) spaces.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#LocallyCompactPair">LocallyCompactPair</a> X Y</code>: an auxiliary typeclass saying that
for any continuous function <code>f : X → Y</code>, a point <code>x</code>, and a neighborhood <code>s</code> of <code>f x</code>,
there exists a compact neighborhood <code>K</code> of <code>x</code> such that <code>f</code> maps <code>K</code> to <code>s</code>.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a></code>, <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">Filter.coclosedCompact</a></code>:
filters generated by complements to compact and closed compact sets, respectively.</p>
</li>
</ul><h2 class="markdown-heading" id="Notation">Notation <a class="hover-link" href="#Notation">#</a></h2><ul>
<li><code>𝓝 x</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> x</code> of neighborhoods of a point <code>x</code>;</li>
<li><code>𝓟 s</code>: the principal filter of a set <code>s</code>, defined elsewhere;</li>
<li><code>𝓝[s] x</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> x s</code> of neighborhoods of a point <code>x</code> within a set <code>s</code>;</li>
<li><code>𝓝[≤] x</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> x (Set.Iic x)</code> of left-neighborhoods of <code>x</code>;</li>
<li><code>𝓝[≥] x</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> x (Set.Ici x)</code> of right-neighborhoods of <code>x</code>;</li>
<li><code>𝓝[&lt;] x</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> x (Set.Iio x)</code> of punctured left-neighborhoods of <code>x</code>;</li>
<li><code>𝓝[&gt;] x</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> x (Set.Ioi x)</code> of punctured right-neighborhoods of <code>x</code>;</li>
<li><code>𝓝[≠] x</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> x {x}ᶜ</code> of punctured neighborhoods of <code>x</code>;</li>
<li><code>𝓝ˢ s</code>: the filter <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> s</code> of neighborhoods of a set.</li>
</ul></div><div class="decl" id="nhds_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L119-L123">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#nhds_def"><span class="name">nhds_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ <span class="fn">s</span> ∈ <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">s</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="nhds"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L119-L123">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#nhds"><span class="name">nhds</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span></div></div><p>A set is called a neighborhood of <code>x</code> if it contains an open set around <code>x</code>. The set of all
neighborhoods of <code>x</code> forms a filter, the neighborhood filter at <code>x</code>, is here defined as the
infimum over the principal filters of all open sets containing <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ <span class="fn">s</span> ∈ <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">s</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-nhds" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.term𝓝"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L125-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.term𝓝"><span class="name">Topology</span>.<span class="name">term𝓝</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A set is called a neighborhood of <code>x</code> if it contains an open set around <code>x</code>. The set of all
neighborhoods of <code>x</code> forms a filter, the neighborhood filter at <code>x</code>, is here defined as the
infimum over the principal filters of all open sets containing <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.term𝓝">Topology.term𝓝</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Topology.term𝓝</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓝&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Topology.term𝓝" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="nhdsWithin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L128-L131">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin"><span class="name">nhdsWithin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span></div></div><p>The &quot;neighborhood within&quot; filter. Elements of <code>𝓝[s] x</code> are sets containing the
intersection of <code>s</code> and a neighborhood of <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">x</span> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> ⊓ <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-nhdsWithin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.«term𝓝[_]_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L133-L134">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.«term𝓝[_]_»"><span class="name">Topology</span>.<span class="name">«term𝓝[_]_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The &quot;neighborhood within&quot; filter. Elements of <code>𝓝[s] x</code> are sets containing the
intersection of <code>s</code> and a neighborhood of <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Topology.«term𝓝[_]_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.nhdsNE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L136-L138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsNE"><span class="name">Topology</span>.<span class="name">nhdsNE</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Notation for the filter of punctured neighborhoods of a point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsNE">Topology.nhdsNE</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Topology.nhdsNE</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓝[≠] &quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Topology.nhdsNE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.nhdsGE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L140-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsGE"><span class="name">Topology</span>.<span class="name">nhdsGE</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Notation for the filter of right neighborhoods of a point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsGE">Topology.nhdsGE</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Topology.nhdsGE</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓝[≥] &quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Topology.nhdsGE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.nhdsLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L143-L144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsLE"><span class="name">Topology</span>.<span class="name">nhdsLE</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Notation for the filter of left neighborhoods of a point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsLE">Topology.nhdsLE</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Topology.nhdsLE</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓝[≤] &quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Topology.nhdsLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.nhdsGT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L146-L147">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsGT"><span class="name">Topology</span>.<span class="name">nhdsGT</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Notation for the filter of punctured right neighborhoods of a point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsGT">Topology.nhdsGT</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Topology.nhdsGT</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓝[&gt;] &quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Topology.nhdsGT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.nhdsLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L149-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsLT"><span class="name">Topology</span>.<span class="name">nhdsLT</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Notation for the filter of punctured left neighborhoods of a point.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.nhdsLT">Topology.nhdsLT</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Topology.nhdsLT</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓝[&lt;] &quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">100</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Topology.nhdsLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="nhdsSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L152-L154">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet"><span class="name">nhdsSet</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span></div></div><p>The filter of neighborhoods of a set in a topological space.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#SupSet.sSup">sSup</a> (<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></li></ul></details><details id="instances-for-list-nhdsSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Topology.«term𝓝ˢ»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L156-L156">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.«term𝓝ˢ»"><span class="name">Topology</span>.<span class="name">«term𝓝ˢ»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The filter of neighborhoods of a set in a topological space.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Topology.«term𝓝ˢ»">Topology.«term𝓝ˢ»</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Topology.«term𝓝ˢ»</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓝ˢ&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Topology.«term𝓝ˢ»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="nhdsKer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L158-L160">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsKer"><span class="name">nhdsKer</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></div></div><p>The <em>neighborhoods kernel</em> of a set is the intersection of all its neighborhoods. In an
Alexandrov-discrete space, this is the smallest neighborhood of the set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsKer">nhdsKer</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.ker">ker</a></span></li></ul></details><details id="instances-for-list-nhdsKer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="exterior"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L162-L162">source</a></div><div class="attributes">@[deprecated nhdsKer (since := &quot;2025-07-09&quot;)]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#exterior"><span class="name">exterior</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsKer">nhdsKer</a></code>.</p><hr></hr><p>The <em>neighborhoods kernel</em> of a set is the intersection of all its neighborhoods. In an
Alexandrov-discrete space, this is the smallest neighborhood of the set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">@<a href="../../.././Mathlib/Topology/Defs/Filter.html#exterior">exterior</a> <a href="../../.././Init/Prelude.html#Eq">=</a> @<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsKer">nhdsKer</a></li></ul></details><details id="instances-for-list-exterior" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ContinuousAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L164-L168">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousAt"><span class="name">ContinuousAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> → <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A function between topological spaces is continuous at a point <code>x₀</code>
if <code>f x</code> tends to <code>f x₀</code> when <code>x</code> tends to <code>x₀</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousAt">ContinuousAt</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-ContinuousAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ContinuousWithinAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L170-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousWithinAt"><span class="name">ContinuousWithinAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> → <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A function between topological spaces is continuous at a point <code>x₀</code> within a subset <code>s</code>
if <code>f x</code> tends to <code>f x₀</code> when <code>x</code> tends to <code>x₀</code> while staying within <code>s</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousWithinAt">ContinuousWithinAt</a> <span class="fn">f</span> <span class="fn">s</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">x</span> <span class="fn">s</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-ContinuousWithinAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ContinuousOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L176-L180">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousOn"><span class="name">ContinuousOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> → <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A function between topological spaces is continuous on a subset <code>s</code>
when it's continuous at every point of <code>s</code> within <code>s</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousOn">ContinuousOn</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousWithinAt">ContinuousWithinAt</a> <span class="fn">f</span> <span class="fn">s</span> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-ContinuousOn" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Specializes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L182-L195">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Specializes"><span class="name">Specializes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>x</code> specializes to <code>y</code> (notation: <code>x ⤳ y</code>) if either of the following equivalent properties
hold:</p><ul>
<li><code>𝓝 x ≤ 𝓝 y</code>; this property is used as the definition;</li>
<li><code>pure x ≤ 𝓝 y</code>; in other words, any neighbourhood of <code>y</code> contains <code>x</code>;</li>
<li><code>y ∈ <a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {x}</code>;</li>
<li><code><a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {y} ⊆ <a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {x}</code>;</li>
<li>for any closed set <code>s</code> we have <code>x ∈ s → y ∈ s</code>;</li>
<li>for any open set <code>s</code> we have <code>y ∈ s → x ∈ s</code>;</li>
<li><code>y</code> is a cluster point of the filter <code>pure x = 𝓟 {x}</code>.</li>
</ul><p>This relation defines a <code><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a></code> on <code>X</code>. If <code>X</code> is a T₀ space, then this preorder is a partial
order. If <code>X</code> is a T₁ space, then this partial order is trivial : <code>x ⤳ y ↔ x = y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">x</span> <a href="../../.././Mathlib/Topology/Defs/Filter.html#Specializes">⤳</a> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span>)</li></ul></details><details id="instances-for-list-Specializes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="«term_⤳_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L197-L198">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#«term_⤳_»"><span class="name">«term_⤳_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>x</code> specializes to <code>y</code> (notation: <code>x ⤳ y</code>) if either of the following equivalent properties
hold:</p><ul>
<li><code>𝓝 x ≤ 𝓝 y</code>; this property is used as the definition;</li>
<li><code>pure x ≤ 𝓝 y</code>; in other words, any neighbourhood of <code>y</code> contains <code>x</code>;</li>
<li><code>y ∈ <a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {x}</code>;</li>
<li><code><a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {y} ⊆ <a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {x}</code>;</li>
<li>for any closed set <code>s</code> we have <code>x ∈ s → y ∈ s</code>;</li>
<li>for any open set <code>s</code> we have <code>y ∈ s → x ∈ s</code>;</li>
<li><code>y</code> is a cluster point of the filter <code>pure x = 𝓟 {x}</code>.</li>
</ul><p>This relation defines a <code><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a></code> on <code>X</code>. If <code>X</code> is a T₀ space, then this preorder is a partial
order. If <code>X</code> is a T₁ space, then this partial order is trivial : <code>x ⤳ y ↔ x = y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Topology/Defs/Filter.html#«term_⤳_»">«term_⤳_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`«term_⤳_»</span> <span class="fn">300</span> <span class="fn">300</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot; ⤳ &quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">301</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-«term_⤳_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Inseparable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L200-L210">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Inseparable"><span class="name">Inseparable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Two points <code>x</code> and <code>y</code> in a topological space are <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Inseparable">Inseparable</a></code> if any of the following
equivalent properties hold:</p><ul>
<li><code>𝓝 x = 𝓝 y</code>; we use this property as the definition;</li>
<li>for any open set <code>s</code>, <code>x ∈ s ↔ y ∈ s</code>, see <code>inseparable_iff_forall_isOpen</code>;</li>
<li>for any closed set <code>s</code>, <code>x ∈ s ↔ y ∈ s</code>, see <code>inseparable_iff_forall_isClosed</code>;</li>
<li><code>x ∈ <a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {y}</code> and <code>y ∈ <a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {x}</code>, see <code>inseparable_iff_mem_closure</code>;</li>
<li><code><a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {x} = <a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> {y}</code>, see <code>inseparable_iff_closure_eq</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Inseparable">Inseparable</a> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span>)</li></ul></details><details id="instances-for-list-Inseparable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="specializationPreorder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L214-L218">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#specializationPreorder"><span class="name">specializationPreorder</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">X</span></span></div></div><p>Specialization forms a preorder on the topological space.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#specializationPreorder">specializationPreorder</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder.mk">{</a> <span class="fn">le</span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">y</span> : <span class="fn">X</span>) =&gt; <span class="fn">y</span> <a href="../../.././Mathlib/Topology/Defs/Filter.html#Specializes">⤳</a> <span class="fn">x</span></span>, <span class="fn">le_refl</span> := <span class="fn">⋯</span>, <span class="fn">le_trans</span> := <span class="fn">⋯</span>, <span class="fn">lt_iff_le_not_ge</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder.mk">}</a></li></ul></details><details id="instances-for-list-specializationPreorder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="inseparableSetoid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L220-L221">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#inseparableSetoid"><span class="name">inseparableSetoid</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#Setoid">Setoid</a> <span class="fn">X</span></span></div></div><p>A <code>setoid</code> version of <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Inseparable">Inseparable</a></code>, used to define the <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#SeparationQuotient">SeparationQuotient</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#inseparableSetoid">inseparableSetoid</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#Setoid.mk">{</a> <span class="fn">r</span> := <a href="../../.././Mathlib/Topology/Defs/Filter.html#Inseparable">Inseparable</a>, <span class="fn">iseqv</span> := <span class="fn">⋯</span> <a href="../../.././Init/Core.html#Setoid.mk">}</a></li></ul></details><details id="instances-for-list-inseparableSetoid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="SeparationQuotient"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L223-L225">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#SeparationQuotient"><span class="name">SeparationQuotient</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u_1</div></div><p>The quotient of a topological space by its <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#inseparableSetoid">inseparableSetoid</a></code>.
This quotient is guaranteed to be a T₀ space.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#SeparationQuotient">SeparationQuotient</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#inseparableSetoid">inseparableSetoid</a> <span class="fn">X</span>)</span></span></li></ul></details><details id="instances-for-list-SeparationQuotient" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="lim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L232-L234">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#lim"><span class="name">lim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span></div></div><p>If <code>f</code> is a filter, then <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#lim">Filter.lim</a> f</code> is a limit of the filter, if it exists.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#lim">lim</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Classical.html#Classical.epsilon">Classical.epsilon</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">X</span>) =&gt; <span class="fn">f</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span></li></ul></details><details id="instances-for-list-lim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="limUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L236-L239">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#limUnder"><span class="name">limUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span></div></div><p>If <code>f</code> is a filter in <code>α</code> and <code>g : α → X</code> is a function, then <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#limUnder">limUnder</a> f g</code> is a limit of <code>g</code>
at <code>f</code>, if it exists.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#limUnder">limUnder</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#lim">lim</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">g</span> <span class="fn">f</span>)</span></span></li></ul></details><details id="instances-for-list-limUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ClusterPt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L243-L248">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt"><span class="name">ClusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A point <code>x</code> is a cluster point of a filter <code>F</code> if <code>𝓝 x ⊓ F ≠ ⊥</code>.
Also known as an accumulation point or a limit point, but beware that terminology varies.
This is <em>not</em> the same as asking <code>𝓝[≠] x ⊓ F ≠ ⊥</code>, which is called <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt">AccPt</a></code> in Mathlib.
See <code>mem_closure_iff_clusterPt</code> in particular.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> ⊓ <span class="fn">F</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span></li></ul></details><details id="instances-for-list-ClusterPt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="MapClusterPt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L250-L253">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt"><span class="name">MapClusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">ι</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">u</span> : <span class="fn"><span class="fn">ι</span> → <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A point <code>x</code> is a cluster point of a sequence <code>u</code> along a filter <code>F</code> if it is a cluster point
of <code>map u F</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a> <span class="fn">x</span> <span class="fn">F</span> <span class="fn">u</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">u</span> <span class="fn">F</span>)</span></span></li></ul></details><details id="instances-for-list-MapClusterPt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="AccPt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L255-L258">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt"><span class="name">AccPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A point <code>x</code> is an accumulation point of a filter <code>F</code> if <code>𝓝[≠] x ⊓ F ≠ ⊥</code>.
See also <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt">AccPt</a> <span class="fn">x</span> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">x</span> <a href="../../.././Init/Core.html#Singleton.singleton">{</a><span class="fn">x</span><a href="../../.././Init/Core.html#Singleton.singleton">}</a><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a></span> ⊓ <span class="fn">F</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span></li></ul></details><details id="instances-for-list-AccPt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="IsCompact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L260-L263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact"><span class="name">IsCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A set <code>s</code> is compact if for every nontrivial filter <code>f</code> that contains <code>s</code>,
there exists <code>a ∈ s</code> such that every set of <code>f</code> meets every neighborhood of <code>a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ ⦃<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>⦄ [<span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span>], <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span> → <span class="fn">∃ <span class="fn">x</span> ∈ <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">f</span></span></span></span></span></li></ul></details><details id="instances-for-list-IsCompact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompactSpace"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L266-L270">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace"><span class="name">CompactSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Type class for compact spaces. Separation is sometimes included in the definition, especially
in the French literature, but we do not include it here.</p><ul class="structure_fields" id="CompactSpace.mk"><li id="CompactSpace.isCompact_univ" class="structure_field"><div class="structure_field_info">isCompact_univ : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div><div class="structure_field_doc"><p>In a compact space, <code><a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></code> is a compact set.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CompactSpace" class="instances-list"></ul></details></div></div><div class="decl" id="NoncompactSpace"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L273-L276">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace"><span class="name">NoncompactSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>X</code> is a noncompact topological space if it is not a compact space.</p><ul class="structure_fields" id="NoncompactSpace.mk"><li id="NoncompactSpace.noncompact_univ" class="structure_field"><div class="structure_field_info">noncompact_univ : <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div><div class="structure_field_doc"><p>In a noncompact space, <code><a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></code> is not a compact set.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-NoncompactSpace" class="instances-list"></ul></details></div></div><div class="decl" id="WeaklyLocallyCompactSpace"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L278-L282">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#WeaklyLocallyCompactSpace"><span class="name">WeaklyLocallyCompactSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_3)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>We say that a topological space is a <em>weakly locally compact space</em>,
if each point of this space admits a compact neighborhood.</p><ul class="structure_fields" id="WeaklyLocallyCompactSpace.mk"><li id="WeaklyLocallyCompactSpace.exists_compact_mem_nhds" class="structure_field"><div class="structure_field_info">exists_compact_mem_nhds<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
 : <span class="fn">∃ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></div><div class="structure_field_doc"><p>Every point of a weakly locally compact space admits a compact neighborhood.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-WeaklyLocallyCompactSpace" class="instances-list"></ul></details></div></div><div class="decl" id="LocallyCompactSpace"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L286-L297">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#LocallyCompactSpace"><span class="name">LocallyCompactSpace</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_3)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>There are various definitions of &quot;locally compact space&quot; in the literature,
which agree for Hausdorff spaces but not in general.
This one is the precise condition on X needed
for the evaluation map <code>C(X, Y) × X → Y</code> to be continuous for all <code>Y</code>
when <code>C(X, Y)</code> is given the compact-open topology.</p><p>See also <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#WeaklyLocallyCompactSpace">WeaklyLocallyCompactSpace</a></code>, a typeclass that only assumes
that each point has a compact neighborhood.</p><ul class="structure_fields" id="LocallyCompactSpace.mk"><li id="LocallyCompactSpace.local_compact_nhds" class="structure_field"><div class="structure_field_info">local_compact_nhds<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>)</span></span>
 : <span class="fn"><span class="fn">n</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> → <span class="fn">∃ <span class="fn">s</span> ∈ <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span>, <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">n</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></span></span></div><div class="structure_field_doc"><p>In a locally compact space,
every neighbourhood of every point contains a compact neighbourhood of that same point.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LocallyCompactSpace" class="instances-list"></ul></details></div></div><div class="decl" id="LocallyCompactPair"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L299-L317">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#LocallyCompactPair"><span class="name">LocallyCompactPair</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_3)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_4)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>We say that <code>X</code> and <code>Y</code> are a locally compact pair of topological spaces,
if for any continuous map <code>f : X → Y</code>, a point <code>x : X</code>, and a neighbourhood <code>s ∈ 𝓝 (f x)</code>,
there exists a compact neighbourhood <code>K ∈ 𝓝 x</code> such that <code>f</code> maps <code>K</code> to <code>s</code>.</p><p>This is a technical assumption that appears in several theorems,
most notably in <code>ContinuousMap.continuous_comp'</code> and <code>ContinuousMap.continuous_eval</code>.
It is satisfied in two cases:</p><ul>
<li>if <code>X</code> is a locally compact topological space, for obvious reasons;</li>
<li>if <code>X</code> is a weakly locally compact topological space and <code>Y</code> is an R₁ space;
this fact is a simple generalization of the theorem
saying that a weakly locally compact R₁ topological space is locally compact.</li>
</ul><ul class="structure_fields" id="LocallyCompactPair.mk"><li id="LocallyCompactPair.exists_mem_nhds_isCompact_mapsTo" class="structure_field"><div class="structure_field_info">exists_mem_nhds_isCompact_mapsTo<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> → <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span> → <span class="fn">∃ <span class="fn">K</span> ∈ <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.MapsTo">Set.MapsTo</a> <span class="fn">f</span> <span class="fn">K</span> <span class="fn">s</span></span></span></span></span></div><div class="structure_field_doc"><p>If <code>f : X → Y</code> is a continuous map in a locally compact pair of topological spaces
and <code>s : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> Y</code> is a neighbourhood of <code>f x</code>, <code>x : X</code>,
then there exists a compact neighbourhood <code>K</code> of <code>x</code> such that <code>f</code> maps <code>K</code> to <code>s</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-LocallyCompactPair" class="instances-list"></ul></details></div></div><div class="decl" id="Filter.cocompact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L322-L324">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact"><span class="name">Filter</span>.<span class="name">cocompact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span></div></div><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a></code> is the filter generated by complements to compact sets.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>), <span class="fn">⨅ (_ : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a></span></span></span></li></ul></details><details id="instances-for-list-Filter.cocompact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.coclosedCompact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Topology/Defs/Filter.lean#L327-L330">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact"><span class="name">Filter</span>.<span class="name">coclosedCompact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span></div></div><p><code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">Filter.coclosedCompact</a></code> is the filter generated by complements to closed compact sets.
In a Hausdorff space, this is the same as <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">Filter.coclosedCompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>), <span class="fn">⨅ (_ : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span>), <span class="fn">⨅ (_ : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a></span></span></span></span></li></ul></details><details id="instances-for-list-Filter.coclosedCompact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
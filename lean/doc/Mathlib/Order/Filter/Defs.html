<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Order.Filter.Defs</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Order.Filter.Defs";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Order</span>.<span class="name">Filter</span>.<span class="name">Defs</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Order/SetNotation.html">Mathlib.Order.SetNotation</a></li><li><a href="../../.././Mathlib/Data/Set/Insert.html">Mathlib.Data.Set.Insert</a></li><li><a href="../../.././Mathlib/Order/BooleanAlgebra/Set.html">Mathlib.Order.BooleanAlgebra.Set</a></li><li><a href="../../.././Mathlib/Order/Bounds/Defs.html">Mathlib.Order.Bounds.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Order.Filter.Defs" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Filter"><span class="name">Filter</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.filter_eq"><span class="name">Filter</span>.<span class="name">filter_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instMembership"><span class="name">Filter</span>.<span class="name">instMembership</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.ext"><span class="name">Filter</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.ext_iff"><span class="name">Filter</span>.<span class="name">ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_mk"><span class="name">Filter</span>.<span class="name">mem_mk</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_sets"><span class="name">Filter</span>.<span class="name">mem_sets</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.univ_mem"><span class="name">Filter</span>.<span class="name">univ_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_of_superset"><span class="name">Filter</span>.<span class="name">mem_of_superset</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.univ_mem'"><span class="name">Filter</span>.<span class="name">univ_mem'</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.inter_mem"><span class="name">Filter</span>.<span class="name">inter_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mp_mem"><span class="name">Filter</span>.<span class="name">mp_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.copy"><span class="name">Filter</span>.<span class="name">copy</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_copy"><span class="name">Filter</span>.<span class="name">mem_copy</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.comk"><span class="name">Filter</span>.<span class="name">comk</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_comk"><span class="name">Filter</span>.<span class="name">mem_comk</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.principal"><span class="name">Filter</span>.<span class="name">principal</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.term𝓟"><span class="name">Filter</span>.<span class="name">term𝓟</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_principal"><span class="name">Filter</span>.<span class="name">mem_principal</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instPure"><span class="name">Filter</span>.<span class="name">instPure</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_pure"><span class="name">Filter</span>.<span class="name">mem_pure</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.ker"><span class="name">Filter</span>.<span class="name">ker</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.join"><span class="name">Filter</span>.<span class="name">join</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_join"><span class="name">Filter</span>.<span class="name">mem_join</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instPartialOrder"><span class="name">Filter</span>.<span class="name">instPartialOrder</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.le_def"><span class="name">Filter</span>.<span class="name">le_def</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instSupSet"><span class="name">Filter</span>.<span class="name">instSupSet</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_sSup"><span class="name">Filter</span>.<span class="name">mem_sSup</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.sInf"><span class="name">Filter</span>.<span class="name">sInf</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instInfSet"><span class="name">Filter</span>.<span class="name">instInfSet</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.sSup_lowerBounds"><span class="name">Filter</span>.<span class="name">sSup_lowerBounds</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instTop"><span class="name">Filter</span>.<span class="name">instTop</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_top_iff_forall"><span class="name">Filter</span>.<span class="name">mem_top_iff_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_top"><span class="name">Filter</span>.<span class="name">mem_top</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instBot"><span class="name">Filter</span>.<span class="name">instBot</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_bot"><span class="name">Filter</span>.<span class="name">mem_bot</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instInf"><span class="name">Filter</span>.<span class="name">instInf</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instSup"><span class="name">Filter</span>.<span class="name">instSup</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.NeBot"><span class="name">Filter</span>.<span class="name">NeBot</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.neBot_iff"><span class="name">Filter</span>.<span class="name">neBot_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.Eventually"><span class="name">Filter</span>.<span class="name">Eventually</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.«term∀ᶠ_In_,_»"><span class="name">Filter</span>.<span class="name">«term∀ᶠ_In_,_»</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.Frequently"><span class="name">Filter</span>.<span class="name">Frequently</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.«term∃ᶠ_In_,_»"><span class="name">Filter</span>.<span class="name">«term∃ᶠ_In_,_»</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.EventuallyEq"><span class="name">Filter</span>.<span class="name">EventuallyEq</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.«term_=ᶠ[_]_»"><span class="name">Filter</span>.<span class="name">«term_=ᶠ[_]_»</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.EventuallyLE"><span class="name">Filter</span>.<span class="name">EventuallyLE</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.«term_≤ᶠ[_]_»"><span class="name">Filter</span>.<span class="name">«term_≤ᶠ[_]_»</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.map"><span class="name">Filter</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.Tendsto"><span class="name">Filter</span>.<span class="name">Tendsto</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.comap"><span class="name">Filter</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.coprod"><span class="name">Filter</span>.<span class="name">coprod</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instSProd"><span class="name">Filter</span>.<span class="name">instSProd</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.prod_eq_inf"><span class="name">Filter</span>.<span class="name">prod_eq_inf</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.pi"><span class="name">Filter</span>.<span class="name">pi</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.bind"><span class="name">Filter</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.seq"><span class="name">Filter</span>.<span class="name">seq</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.curry"><span class="name">Filter</span>.<span class="name">curry</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instBind"><span class="name">Filter</span>.<span class="name">instBind</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.instFunctor"><span class="name">Filter</span>.<span class="name">instFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.lift"><span class="name">Filter</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.lift'"><span class="name">Filter</span>.<span class="name">lift'</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.IsBounded"><span class="name">Filter</span>.<span class="name">IsBounded</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.IsBoundedUnder"><span class="name">Filter</span>.<span class="name">IsBoundedUnder</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.IsCobounded"><span class="name">Filter</span>.<span class="name">IsCobounded</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.IsCoboundedUnder"><span class="name">Filter</span>.<span class="name">IsCoboundedUnder</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.filterUpwards"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">filterUpwards</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Definitions-about-filters">Definitions about filters <a class="hover-link" href="#Definitions-about-filters">#</a></h1><p>A <em>filter</em> on a type <code>α</code> is a collection of sets of <code>α</code> which contains the whole <code>α</code>,
is upwards-closed, and is stable under intersection. Filters are mostly used to
abstract two related kinds of ideas:</p><ul>
<li><em>limits</em>, including finite or infinite limits of sequences, finite or infinite limits of functions
at a point or at infinity, etc...</li>
<li><em>things happening eventually</em>, including things happening for large enough <code>n : ℕ</code>, or near enough
a point <code>x</code>, or for close enough pairs of points, or things happening almost everywhere in the
sense of measure theory. Dually, filters can also express the idea of <em>things happening often</em>:
for arbitrarily large <code>n</code>, or at a point in any neighborhood of given a point etc...</li>
</ul><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a></code> : filters on a set;</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a></code>, <code>𝓟 s</code> : filter of all sets containing a given set;</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a></code>, <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a></code> : operations on filters;</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a></code> : limit with respect to filters;</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">Filter.Eventually</a></code> : <code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">Eventually</a> p</code> means <code>{x | p x} ∈ f</code>;</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">Filter.Frequently</a></code> : <code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">Frequently</a> p</code> means <code>{x | ¬p x} ∉ f</code>;</li>
<li><code>filter_upwards [h₁, ..., hₙ]</code> :
a tactic that takes a list of proofs <code>hᵢ : sᵢ ∈ f</code>,
and replaces a goal <code>s ∈ f</code> with <code>∀ x, x ∈ s₁ → ... → x ∈ sₙ → x ∈ s</code>;</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">Filter.NeBot</a> f</code> : a utility class stating that <code>f</code> is a non-trivial filter.</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBounded">Filter.IsBounded</a> r f</code>: the filter <code>f</code> is eventually bounded w.r.t. the relation <code>r</code>,
i.e. eventually, it is bounded by some uniform bound.
<code>r</code> will be usually instantiated with <code>(· ≤ ·)</code> or <code>(· ≥ ·)</code>.</li>
<li><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCobounded">Filter.IsCobounded</a> r f</code> states that the filter <code>f</code> does not tend to infinity w.r.t. <code>r</code>.
This is also called frequently bounded. Will be usually instantiated with <code>(· ≤ ·)</code> or <code>(· ≥ ·)</code>.</li>
</ul><h2 class="markdown-heading" id="Notation">Notation <a class="hover-link" href="#Notation">#</a></h2><ul>
<li><code>∀ᶠ x in f, p x</code> : <code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">Eventually</a> p</code>;</li>
<li><code>∃ᶠ x in f, p x</code> : <code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">Frequently</a> p</code>;</li>
<li><code>f =ᶠ[l] g</code> : <code>∀ᶠ x in l, f x = g x</code>;</li>
<li><code>f ≤ᶠ[l] g</code> : <code>∀ᶠ x in l, f x ≤ g x</code>;</li>
<li><code>𝓟 s</code> : <code>Filter.Principal s</code>, localized in <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a></code>.</li>
</ul><h2 class="markdown-heading" id="Implementation-Notes">Implementation Notes <a class="hover-link" href="#Implementation-Notes">#</a></h2><p>Important note: Bourbaki requires that a filter on <code>X</code> cannot contain all sets of <code>X</code>,
which we do <em>not</em> require.
This gives <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> X</code> better formal properties,
in particular a bottom element <code>⊥</code> for its lattice structure,
at the cost of including the assumption <code>[NeBot f]</code> in a number of lemmas and definitions.</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>[N. Bourbaki, <em>General Topology</em>][bourbaki1966]</li>
</ul></div><div class="decl" id="Filter"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L67-L78">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter"><span class="name">Filter</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u_1</div></div><p>A filter <code>F</code> on a type <code>α</code> is a collection of sets of <code>α</code> which contains the whole <code>α</code>,
is upwards-closed, and is stable under intersection. We do not forbid this collection to be
all sets of <code>α</code>.</p><ul class="structure_fields" id="Filter.mk"><li id="Filter.sets" class="structure_field"><div class="structure_field_info">sets : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span></div><div class="structure_field_doc"><p>The set of sets that belong to the filter.</p></div></li><li id="Filter.univ_sets" class="structure_field"><div class="structure_field_info">univ_sets : <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span></div><div class="structure_field_doc"><p>The set <code><a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></code> belongs to any filter.</p></div></li><li id="Filter.sets_of_superset" class="structure_field"><div class="structure_field_info">sets_of_superset<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span> : <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span> → <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">y</span> → <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span></span></span></div><div class="structure_field_doc"><p>If a set belongs to a filter, then its superset belongs to the filter as well.</p></div></li><li id="Filter.inter_sets" class="structure_field"><div class="structure_field_info">inter_sets<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span> : <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span> → <span class="fn"><span class="fn">y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span> → <span class="fn">x</span> <a href="../../.././Init/Core.html#Inter.inter">∩</a> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span></span></span></div><div class="structure_field_doc"><p>If two sets belong to a filter, then their intersection belongs to the filter as well.</p></div></li></ul><details id="instances-for-list-Filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.filter_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L84-L85">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.filter_eq"><span class="name">Filter</span>.<span class="name">filter_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span> → <span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Filter.instMembership"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L87-L88">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instMembership"><span class="name">Filter</span>.<span class="name">instMembership</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><p>If <code>F</code> is a filter on <code>α</code>, and <code>U</code> a subset of <code>α</code> then we can write <code>U ∈ F</code> as on paper.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instMembership">Filter.instMembership</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Membership.mk">{</a> <span class="fn">mem</span> := <span class="fn">fun (<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>) (<span class="fn">U</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn">U</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span></span> <a href="../../.././Init/Prelude.html#Membership.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.ext"><span class="name">Filter</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></div></div></div></div><div class="decl" id="Filter.ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L90-L90">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.ext_iff"><span class="name">Filter</span>.<span class="name">ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="Filter.mem_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L93-L95">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_mk"><span class="name">Filter</span>.<span class="name">mem_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₂</span> : <span class="fn">∀ {<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}, <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span> → <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">y</span> → <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₃</span> : <span class="fn">∀ {<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}, <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span> → <span class="fn"><span class="fn">y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span> → <span class="fn">x</span> <a href="../../.././Init/Core.html#Inter.inter">∩</a> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <span class="fn">t</span>, <span class="fn">univ_sets</span> := <span class="fn">h₁</span>, <span class="fn">sets_of_superset</span> := <span class="fn">h₂</span>, <span class="fn">inter_sets</span> := <span class="fn">h₃</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></div></div></div></div><div class="decl" id="Filter.mem_sets"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L97-L99">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_sets"><span class="name">Filter</span>.<span class="name">mem_sets</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="Filter.univ_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L101-L103">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.univ_mem"><span class="name">Filter</span>.<span class="name">univ_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="Filter.mem_of_superset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L105-L106">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_of_superset"><span class="name">Filter</span>.<span class="name">mem_of_superset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hxy</span> : <span class="fn">x</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">y</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="Filter.univ_mem'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L108-L109">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.univ_mem'"><span class="name">Filter</span>.<span class="name">univ_mem'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="Filter.inter_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L111-L112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.inter_mem"><span class="name">Filter</span>.<span class="name">inter_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn">t</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">∩</a> <span class="fn">t</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="Filter.mp_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L114-L115">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mp_mem"><span class="name">Filter</span>.<span class="name">mp_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">x</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn">α</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span> → <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">t</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="Filter.copy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L117-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.copy"><span class="name">Filter</span>.<span class="name">copy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmem</span> : <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span></div></div><p>Override <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></code> field of a filter to provide better definitional equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.copy">copy</a></span> <span class="fn">S</span> <span class="fn">hmem</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <span class="fn">S</span>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>, <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></li></ul></details><details id="instances-for-list-Filter.copy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.mem_copy"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L124-L124">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_copy"><span class="name">Filter</span>.<span class="name">mem_copy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hmem</span> : <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.copy">copy</a></span> <span class="fn">S</span> <span class="fn">hmem</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">S</span></div></div></div></div><div class="decl" id="Filter.comk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L126-L134">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comk"><span class="name">Filter</span>.<span class="name">comk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">p</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmono</span> : <span class="fn">∀ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">t</span></span> → <span class="fn">∀ <span class="fn">s</span> ⊆ <span class="fn">t</span>, <span class="fn"><span class="fn">p</span> <span class="fn">s</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hunion</span> : <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">s</span></span> → <span class="fn">∀ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">t</span></span> → <span class="fn"><span class="fn">p</span> (<span class="fn">s</span> <a href="../../.././Init/Core.html#Union.union">∪</a> <span class="fn">t</span>)</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span></div></div><p>Construct a filter from a property that is stable under finite unions.
A set <code>s</code> belongs to <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comk">Filter.comk</a> p _ _ _</code> iff its complement satisfies the predicate <code>p</code>.
This constructor is useful to define filters like <code>Filter.cofinite</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comk">Filter.comk</a> <span class="fn">p</span> <span class="fn">he</span> <span class="fn">hmono</span> <span class="fn">hunion</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">t</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><span class="fn">p</span> <span class="fn">t</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>, <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></li></ul></details><details id="instances-for-list-Filter.comk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.mem_comk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L136-L139">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_comk"><span class="name">Filter</span>.<span class="name">mem_comk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">p</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hmono</span> : <span class="fn">∀ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">t</span></span> → <span class="fn">∀ <span class="fn">s</span> ⊆ <span class="fn">t</span>, <span class="fn"><span class="fn">p</span> <span class="fn">s</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hunion</span> : <span class="fn">∀ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">s</span></span> → <span class="fn">∀ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">t</span></span> → <span class="fn"><span class="fn">p</span> (<span class="fn">s</span> <a href="../../.././Init/Core.html#Union.union">∪</a> <span class="fn">t</span>)</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comk">comk</a> <span class="fn">p</span> <span class="fn">he</span> <span class="fn">hmono</span> <span class="fn">hunion</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">p</span> <span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a></span></div></div></div></div><div class="decl" id="Filter.principal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L141-L146">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal"><span class="name">Filter</span>.<span class="name">principal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span></div></div><p>The principal filter of <code>s</code> is the collection of all supersets of <code>s</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">t</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">t</span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>, <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></li></ul></details><details id="instances-for-list-Filter.principal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.term𝓟"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L148-L149">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.term𝓟"><span class="name">Filter</span>.<span class="name">term𝓟</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The principal filter of <code>s</code> is the collection of all supersets of <code>s</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.term𝓟">Filter.term𝓟</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Filter.term𝓟</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;𝓟&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Filter.term𝓟" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.mem_principal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L151-L151">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_principal"><span class="name">Filter</span>.<span class="name">mem_principal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">principal</a> <span class="fn">t</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">t</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">s</span></div></div></div></div><div class="decl" id="Filter.instPure"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L153-L156">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instPure"><span class="name">Filter</span>.<span class="name">instPure</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Pure">Pure</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a></span></div></div><p><code>pure x</code> is the set of sets that contain <code>x</code>. It is equal to <code>𝓟 {x}</code> but
with this definition we have <code>s ∈ pure a</code> defeq <code>a ∈ s</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instPure">Filter.instPure</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Pure.mk">{</a> <span class="fn">pure</span> := <span class="fn">fun {<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> ?u.6} (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <a href="../../.././Init/Core.html#Singleton.singleton">{</a><span class="fn">x</span><a href="../../.././Init/Core.html#Singleton.singleton">}</a>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.copy">copy</a></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <span class="fn">⋯</span></span></span> <a href="../../.././Init/Prelude.html#Pure.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.mem_pure"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L158-L160">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_pure"><span class="name">Filter</span>.<span class="name">mem_pure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">a</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></div></div></div></div><div class="decl" id="Filter.ker"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L162-L163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.ker"><span class="name">Filter</span>.<span class="name">ker</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span></div></div><p>The <em>kernel</em> of a filter is the intersection of all its sets.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.ker">ker</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/SetNotation.html#Set.sInter">⋂₀</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span></li></ul></details><details id="instances-for-list-Filter.ker" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.join"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L165-L170">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.join"><span class="name">Filter</span>.<span class="name">join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span></div></div><p>The join of a filter of filters is defined by the relation <code>s ∈ <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.join">join</a> f ↔ {t | s ∈ t} ∈ f</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.join">join</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">t</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>, <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></li></ul></details><details id="instances-for-list-Filter.join" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.mem_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L172-L174">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_join"><span class="name">Filter</span>.<span class="name">mem_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.join">join</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">t</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="Filter.instPartialOrder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L176-L180">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instPartialOrder"><span class="name">Filter</span>.<span class="name">instPartialOrder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instPartialOrder">Filter.instPartialOrder</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder.mk">{</a> <span class="fn">le</span> := <span class="fn">fun (<span class="fn">f</span> <span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>) =&gt; <span class="fn">∀ ⦃<span class="fn">U</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>⦄, <span class="fn"><span class="fn">U</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">g</span> → <span class="fn">U</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></span></span></span>, <span class="fn">le_refl</span> := <span class="fn">⋯</span>, <span class="fn">le_trans</span> := <span class="fn">⋯</span>, <span class="fn">lt_iff_le_not_ge</span> := <span class="fn">⋯</span>,
    <span class="fn">le_antisymm</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.le_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L182-L183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.le_def"><span class="name">Filter</span>.<span class="name">le_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">g</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">g</span>, <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Filter.instSupSet"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L185-L186">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instSupSet"><span class="name">Filter</span>.<span class="name">instSupSet</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#SupSet">SupSet</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instSupSet">Filter.instSupSet</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/SetNotation.html#SupSet.mk">{</a> <span class="fn">sSup</span> := <span class="fn">fun (<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span>) =&gt; <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">S</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.join">join</a></span></span> <a href="../../.././Mathlib/Order/SetNotation.html#SupSet.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.mem_sSup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L188-L188">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_sSup"><span class="name">Filter</span>.<span class="name">mem_sSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#SupSet.sSup">sSup</a> <span class="fn">S</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ <span class="fn">f</span> ∈ <span class="fn">S</span>, <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Filter.sInf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L190-L194">source</a></div><div class="attributes">@[irreducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sInf"><span class="name">Filter</span>.<span class="name">sInf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span></div></div><p>Infimum of a set of filters.
This definition is marked as irreducible
so that Lean doesn't try to unfold it when unifying expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sInf">Filter.sInf</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#SupSet.sSup">sSup</a> <span class="fn">(<a href="../../.././Mathlib/Order/Bounds/Defs.html#lowerBounds">lowerBounds</a> <span class="fn">s</span>)</span></span></li></ul></details><details id="instances-for-list-Filter.sInf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.instInfSet"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L196-L197">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instInfSet"><span class="name">Filter</span>.<span class="name">instInfSet</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#InfSet">InfSet</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instInfSet">Filter.instInfSet</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/SetNotation.html#InfSet.mk">{</a> <span class="fn">sInf</span> := <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sInf">Filter.sInf</a> <a href="../../.././Mathlib/Order/SetNotation.html#InfSet.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.sSup_lowerBounds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L199-L200">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sSup_lowerBounds"><span class="name">Filter</span>.<span class="name">sSup_lowerBounds</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#SupSet.sSup">sSup</a> <span class="fn">(<a href="../../.././Mathlib/Order/Bounds/Defs.html#lowerBounds">lowerBounds</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#InfSet.sInf">sInf</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="Filter.instTop"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L202-L203">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instTop"><span class="name">Filter</span>.<span class="name">instTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Notation.html#Top">Top</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instTop">Filter.instTop</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Notation.html#Top.mk">{</a> <span class="fn">top</span> := <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/SetNotation.html#SupSet.sSup">sSup</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <a href="../../.././Init/Prelude.html#Pure.pure">pure</a>)</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.copy">copy</a></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <span class="fn">⋯</span></span> <a href="../../.././Mathlib/Order/Notation.html#Top.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.mem_top_iff_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L205-L206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_top_iff_forall"><span class="name">Filter</span>.<span class="name">mem_top_iff_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <a href="../../.././Mathlib/Order/Notation.html#Top.top">⊤</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="Filter.mem_top"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L208-L210">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_top"><span class="name">Filter</span>.<span class="name">mem_top</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <a href="../../.././Mathlib/Order/Notation.html#Top.top">⊤</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></div></div></div></div><div class="decl" id="Filter.instBot"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L212-L213">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instBot"><span class="name">Filter</span>.<span class="name">instBot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Notation.html#Bot">Bot</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instBot">Filter.instBot</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.mk">{</a> <span class="fn">bot</span> := <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/SetNotation.html#SupSet.sSup">sSup</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.copy">copy</a></span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <span class="fn">⋯</span></span> <a href="../../.././Mathlib/Order/Notation.html#Bot.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.mem_bot"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L215-L217">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mem_bot"><span class="name">Filter</span>.<span class="name">mem_bot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a></div></div></div></div><div class="decl" id="Filter.instInf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L219-L233">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instInf"><span class="name">Filter</span>.<span class="name">instInf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Min">Min</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><p>The infimum of filters is the filter generated by intersections
of elements of the two filters.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instInf">Filter.instInf</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#Min.mk">{</a>     <span class="fn">min</span> := <span class="fn">fun (<span class="fn">f</span> <span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>) =&gt;
      <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∃ <span class="fn">a</span> ∈ <span class="fn">f</span>, <span class="fn">∃ <span class="fn">b</span> ∈ <span class="fn">g</span>, <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Core.html#Inter.inter">∩</a> <span class="fn">b</span></span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>, <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></span> <a href="../../.././Init/Prelude.html#Min.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.instSup"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L235-L237">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instSup"><span class="name">Filter</span>.<span class="name">instSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Max">Max</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span></span></div></div><p>The supremum of two filters is the filter that contains sets that belong to both filters.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instSup">Filter.instSup</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Max.mk">{</a> <span class="fn">max</span> := <span class="fn">fun (<span class="fn">f</span> <span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/SetNotation.html#SupSet.sSup">sSup</a> <a href="../../.././Init/Core.html#Insert.insert">{</a><span class="fn">f</span><a href="../../.././Init/Core.html#Insert.insert">,</a> <span class="fn">g</span><a href="../../.././Init/Core.html#Insert.insert">}</a>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.copy">copy</a></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">g</span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <span class="fn">⋯</span></span></span> <a href="../../.././Init/Prelude.html#Max.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.NeBot"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L239-L244">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot"><span class="name">Filter</span>.<span class="name">NeBot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A filter is <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></code> if it is not equal to <code>⊥</code>, or equivalently the empty set does not belong to
the filter. Bourbaki include this assumption in the definition of a filter but we prefer to have a
<code>CompleteLattice</code> structure on <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> _</code>, so we use a typeclass argument in lemmas instead.</p><ul class="structure_fields" id="Filter.NeBot.mk"><li id="Filter.NeBot.ne'" class="structure_field"><div class="structure_field_info">ne' : <span class="fn">f</span> <a href="../../.././Init/Core.html#Ne">≠</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a></div><div class="structure_field_doc"><p>The filter is nontrivial: <code>f ≠ ⊥</code> or equivalently, <code>∅ ∉ f</code>.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Filter.NeBot" class="instances-list"></ul></details></div></div><div class="decl" id="Filter.neBot_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L246-L247">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.neBot_iff"><span class="name">Filter</span>.<span class="name">neBot_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">f</span> <a href="../../.././Init/Core.html#Ne">≠</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a></div></div></div></div><div class="decl" id="Filter.Eventually"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L249-L252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually"><span class="name">Filter</span>.<span class="name">Eventually</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">Eventually</a> p</code> or <code>∀ᶠ x in f, p x</code> mean that <code>{x | p x} ∈ f</code>. E.g., <code>∀ᶠ x in atTop, p x</code>
means that <code>p</code> holds true for sufficiently large <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">Filter.Eventually</a> <span class="fn">p</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">x</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn">α</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span>)</li></ul></details><details id="instances-for-list-Filter.Eventually" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.«term∀ᶠ_In_,_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L254-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.«term∀ᶠ_In_,_»"><span class="name">Filter</span>.<span class="name">«term∀ᶠ_In_,_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">Eventually</a> p</code> or <code>∀ᶠ x in f, p x</code> mean that <code>{x | p x} ∈ f</code>. E.g., <code>∀ᶠ x in atTop, p x</code>
means that <code>p</code> holds true for sufficiently large <code>x</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Filter.«term∀ᶠ_In_,_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.Frequently"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L257-L260">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently"><span class="name">Filter</span>.<span class="name">Frequently</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">Frequently</a> p</code> or <code>∃ᶠ x in f, p x</code> mean that <code>{x | ¬p x} ∉ f</code>. E.g., <code>∃ᶠ x in atTop, p x</code>
means that there exist arbitrarily large <code>x</code> for which <code>p</code> holds true.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">Filter.Frequently</a> <span class="fn">p</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">∀ᶠ</a> (<span class="fn">x</span> : <span class="fn">α</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">f</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Filter.Frequently" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.«term∃ᶠ_In_,_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L262-L263">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.«term∃ᶠ_In_,_»"><span class="name">Filter</span>.<span class="name">«term∃ᶠ_In_,_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">Frequently</a> p</code> or <code>∃ᶠ x in f, p x</code> mean that <code>{x | ¬p x} ∉ f</code>. E.g., <code>∃ᶠ x in atTop, p x</code>
means that there exist arbitrarily large <code>x</code> for which <code>p</code> holds true.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Filter.«term∃ᶠ_In_,_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.EventuallyEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L265-L268">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.EventuallyEq"><span class="name">Filter</span>.<span class="name">EventuallyEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Two functions <code>f</code> and <code>g</code> are <em>eventually equal</em> along a filter <code>l</code> if the set of <code>x</code> such that
<code>f x = g x</code> belongs to <code>l</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">f</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.EventuallyEq">=ᶠ[</a><span class="fn">l</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.EventuallyEq">]</a> <span class="fn">g</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">∀ᶠ</a> (<span class="fn">x</span> : <span class="fn">α</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">l</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Filter.EventuallyEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.«term_=ᶠ[_]_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L270-L271">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.«term_=ᶠ[_]_»"><span class="name">Filter</span>.<span class="name">«term_=ᶠ[_]_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>Two functions <code>f</code> and <code>g</code> are <em>eventually equal</em> along a filter <code>l</code> if the set of <code>x</code> such that
<code>f x = g x</code> belongs to <code>l</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Filter.«term_=ᶠ[_]_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.EventuallyLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L273-L275">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.EventuallyLE"><span class="name">Filter</span>.<span class="name">EventuallyLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">g</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A function <code>f</code> is eventually less than or equal to a function <code>g</code> at a filter <code>l</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">(<span class="fn">f</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.EventuallyLE">≤ᶠ[</a><span class="fn">l</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.EventuallyLE">]</a> <span class="fn">g</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">∀ᶠ</a> (<span class="fn">x</span> : <span class="fn">α</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">l</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Filter.EventuallyLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.«term_≤ᶠ[_]_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L277-L278">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.«term_≤ᶠ[_]_»"><span class="name">Filter</span>.<span class="name">«term_≤ᶠ[_]_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>A function <code>f</code> is eventually less than or equal to a function <code>g</code> at a filter <code>l</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Filter.«term_≤ᶠ[_]_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L280-L285">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map"><span class="name">Filter</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span></div></div><p>The forward map of a filter</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">m</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">Set.preimage</a> <span class="fn">m</span></span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.sets">sets</a></span>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>, <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></li></ul></details><details id="instances-for-list-Filter.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.Tendsto"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L287-L291">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto"><span class="name">Filter</span>.<span class="name">Tendsto</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₁</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l₂</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a></code> is the generic &quot;limit of a function&quot; predicate.
<code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Tendsto</a> f l₁ l₂</code> asserts that for every <code>l₂</code> neighborhood <code>a</code>,
the <code>f</code>-preimage of <code>a</code> is an <code>l₁</code> neighborhood.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">l₁</span> <span class="fn">l₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">f</span> <span class="fn">l₁</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l₂</span>)</li></ul></details><details id="instances-for-list-Filter.Tendsto" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.comap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L293-L305">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap"><span class="name">Filter</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span></div></div><p>The inverse map of a filter. A set <code>s</code> belongs to <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> m f</code> if either of the following
equivalent conditions hold.</p><ol>
<li>There exists a set <code>t ∈ f</code> such that <code>m ⁻¹' t ⊆ s</code>. This is used as a definition.</li>
<li>The set <code>kernImage m s = {y | ∀ x, m x = y → x ∈ s}</code> belongs to <code>f</code>, see <code>Filter.mem_comap'</code>.</li>
<li>The set <code>(m '' sᶜ)ᶜ</code> belongs to <code>f</code>, see <code>Filter.mem_comap_iff_compl</code> and
<code>Filter.compl_mem_comap</code>.</li>
</ol><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">m</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∃ <span class="fn">t</span> ∈ <span class="fn">f</span>, <span class="fn">m</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">⁻¹'</a> <span class="fn">t</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">s</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>, <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></li></ul></details><details id="instances-for-list-Filter.comap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.coprod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L307-L309">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.coprod"><span class="name">Filter</span>.<span class="name">coprod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><p>Coproduct of filters.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.coprod">coprod</a></span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <a href="../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">f</span></span> ⊔ <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <a href="../../.././Init/Prelude.html#Prod.snd">Prod.snd</a> <span class="fn">g</span></span></span></li></ul></details><details id="instances-for-list-Filter.coprod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.instSProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L311-L314">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instSProd"><span class="name">Filter</span>.<span class="name">instSProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/SProd.html#SProd">SProd</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>))</span></span></div></div><p>Product of filters. This is the filter generated by Cartesian products
of elements of the component filters.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instSProd">Filter.instSProd</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/SProd.html#SProd.mk">{</a> <span class="fn">sprod</span> := <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>) (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <a href="../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">f</span></span> ⊓ <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <a href="../../.././Init/Prelude.html#Prod.snd">Prod.snd</a> <span class="fn">g</span></span></span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.prod_eq_inf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L316-L317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.prod_eq_inf"><span class="name">Filter</span>.<span class="name">prod_eq_inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">×ˢ</a> <span class="fn">g</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">comap</a> <a href="../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">f</span></span> ⊓ <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">comap</a> <a href="../../.././Init/Prelude.html#Prod.snd">Prod.snd</a> <span class="fn">g</span></span></span></div></div></div></div><div class="decl" id="Filter.pi"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L319-L321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.pi"><span class="name">Filter</span>.<span class="name">pi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ι</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_4</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">(<span class="fn">α</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">α</span> <span class="fn">i</span></span>)</span></span></div></div><p>The product of an indexed family of filters.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.pi">Filter.pi</a> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (<span class="fn">i</span> : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">Filter.comap</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">i</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span></li></ul></details><details id="instances-for-list-Filter.pi" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L323-L328">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.bind"><span class="name">Filter</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span></div></div><p>The monadic bind operation on filter is defined the usual way in terms of <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">map</a></code> and <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.join">join</a></code>.</p><p>Unfortunately, this <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.bind">bind</a></code> does not result in the expected applicative. See <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.seq">Filter.seq</a></code> for the
applicative instance.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.bind">bind</a></span> <span class="fn">m</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">m</span> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.join">join</a></span></li></ul></details><details id="instances-for-list-Filter.bind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.seq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L330-L338">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.seq"><span class="name">Filter</span>.<span class="name">seq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">(<span class="fn">α</span> → <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span></div></div><p>The applicative sequentiation operation. This is not induced by the bind operation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.seq">seq</a></span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">{</a> <span class="fn">sets</span> := <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">β</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">∃ <span class="fn">u</span> ∈ <span class="fn">f</span>, <span class="fn">∃ <span class="fn">t</span> ∈ <span class="fn">g</span>, <span class="fn">∀ <span class="fn">m</span> ∈ <span class="fn">u</span>, <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">t</span>, <span class="fn"><span class="fn">m</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span></span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a>, <span class="fn">univ_sets</span> := <span class="fn">⋯</span>, <span class="fn">sets_of_superset</span> := <span class="fn">⋯</span>,
    <span class="fn">inter_sets</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.mk">}</a></li></ul></details><details id="instances-for-list-Filter.seq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.curry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L340-L345">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.curry"><span class="name">Filter</span>.<span class="name">curry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> (<span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></div></div><p>This filter is characterized by <code>Filter.eventually_curry_iff</code>:
<code>(∀ᶠ (x : α × β) in f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.curry">curry</a> g, p x) ↔ ∀ᶠ (x : α) in f, ∀ᶠ (y : β) in g, p (x, y)</code>. Useful
in adding quantifiers to the middle of <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Tendsto</a></code>s. See
<code>hasFDerivAt_of_tendstoUniformlyOnFilter</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.curry">curry</a></span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.bind">bind</a></span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">g</span></span></span></span></li></ul></details><details id="instances-for-list-Filter.curry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.instBind"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L347-L348">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instBind"><span class="name">Filter</span>.<span class="name">instBind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Bind">Bind</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instBind">Filter.instBind</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bind.mk">{</a> <span class="fn">bind</span> := @<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.bind">Filter.bind</a> <a href="../../.././Init/Prelude.html#Bind.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.instFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L350-L350">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instFunctor"><span class="name">Filter</span>.<span class="name">instFunctor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Functor">Functor</a> <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.instFunctor">Filter.instFunctor</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Functor.mk">{</a> <span class="fn">map</span> := @<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <a href="../../.././Init/Prelude.html#Functor.mk">}</a></li></ul></details></div></div><div class="decl" id="Filter.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L352-L355">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.lift"><span class="name">Filter</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span></div></div><p>A variant on <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.bind">bind</a></code> using a function <code>g</code> taking a set instead of a member of <code>α</code>.
This is essentially a push-forward along a function mapping each set to a filter.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.lift">lift</a></span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ <span class="fn">s</span> ∈ <span class="fn">f</span>, <span class="fn"><span class="fn">g</span> <span class="fn">s</span></span></span></li></ul></details><details id="instances-for-list-Filter.lift" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.lift'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L357-L360">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.lift'"><span class="name">Filter</span>.<span class="name">lift'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span></div></div><p>Specialize <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.lift">lift</a></code> to functions <code><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> α → <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> β</code>. This can be viewed as a generalization of <code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">map</a></code>.
This is essentially a push-forward along a function mapping each set to a set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.lift'">lift'</a></span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.lift">lift</a></span> (<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">h</span>)</span></li></ul></details><details id="instances-for-list-Filter.lift'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.IsBounded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L362-L366">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBounded"><span class="name">Filter</span>.<span class="name">IsBounded</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBounded">IsBounded</a> r</code>: the filter <code>f</code> is eventually bounded w.r.t. the relation <code>r</code>,
i.e. eventually, it is bounded by some uniform bound.
<code>r</code> will be usually instantiated with <code>(· ≤ ·)</code> or <code>(· ≥ ·)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBounded">Filter.IsBounded</a> <span class="fn">r</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">∀ᶠ</a> (<span class="fn">x</span> : <span class="fn">α</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">f</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">b</span></span></span></span></li></ul></details><details id="instances-for-list-Filter.IsBounded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.IsBoundedUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L368-L371">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBoundedUnder"><span class="name">Filter</span>.<span class="name">IsBoundedUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">u</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBoundedUnder">IsBoundedUnder</a> (≺) u</code>: the image of the filter <code>f</code> under <code>u</code> is eventually bounded w.r.t.
the relation <code>≺</code>, i.e. eventually, it is bounded by some uniform bound.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBoundedUnder">Filter.IsBoundedUnder</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">u</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsBounded">Filter.IsBounded</a> <span class="fn">r</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">u</span> <span class="fn">f</span>)</span></span></li></ul></details><details id="instances-for-list-Filter.IsBoundedUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.IsCobounded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L373-L384">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCobounded"><span class="name">Filter</span>.<span class="name">IsCobounded</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCobounded">IsCobounded</a> (≺) f</code> states that the filter <code>f</code> does not tend to infinity w.r.t. <code>≺</code>. This is
also called frequently bounded. Will be usually instantiated with <code>≤</code> or <code>≥</code>.</p><p>There is a subtlety in this definition: we want <code>f.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCobounded">IsCobounded</a></code> to hold for any <code>f</code> in the case of
complete lattices. This will be relevant to deduce theorems on complete lattices from their
versions on conditionally complete lattices with additional assumptions. We have to be careful in
the edge case of the trivial filter containing the empty set: the other natural definition
<code>¬ ∀ a, ∀ᶠ n in f, a ≤ n</code>
would not work as well in this case.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCobounded">Filter.IsCobounded</a> <span class="fn">r</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">∀ᶠ</a> (<span class="fn">x</span> : <span class="fn">α</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">f</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">a</span></span>)</span> → <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></span></span></span></li></ul></details><details id="instances-for-list-Filter.IsCobounded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Filter.IsCoboundedUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L386-L390">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCoboundedUnder"><span class="name">Filter</span>.<span class="name">IsCoboundedUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">u</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCoboundedUnder">IsCoboundedUnder</a> (≺) f u</code> states that the image of the filter <code>f</code> under the map <code>u</code> does not
tend to infinity w.r.t. <code>≺</code>. This is also called frequently bounded. Will be usually instantiated
with <code>≤</code> or <code>≥</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCoboundedUnder">Filter.IsCoboundedUnder</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">u</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.IsCobounded">Filter.IsCobounded</a> <span class="fn">r</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">u</span> <span class="fn">f</span>)</span></span></li></ul></details><details id="instances-for-list-Filter.IsCoboundedUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.filterUpwards"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/Filter/Defs.lean#L398-L413">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Order/Filter/Defs.html#Mathlib.Tactic.filterUpwards"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">filterUpwards</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>filter_upwards [h₁, ⋯, hₙ]</code> replaces a goal of the form <code>s ∈ f</code> and terms
<code>h₁ : t₁ ∈ f, ⋯, hₙ : tₙ ∈ f</code> with <code>∀ x, x ∈ t₁ → ⋯ → x ∈ tₙ → x ∈ s</code>.
The list is an optional parameter, <code>[]</code> being its default value.</p><p><code>filter_upwards [h₁, ⋯, hₙ] with a₁ a₂ ⋯ aₖ</code> is a short form for
<code>{ filter_upwards [h₁, ⋯, hₙ], intro a₁ a₂ ⋯ aₖ }</code>.</p><p><code>filter_upwards [h₁, ⋯, hₙ] using e</code> is a short form for
<code>{ filter_upwards [h1, ⋯, hn], exact e }</code>.</p><p>Combining both shortcuts is done by writing <code>filter_upwards [h₁, ⋯, hₙ] with a₁ a₂ ⋯ aₖ using e</code>.
Note that in this case, the <code>aᵢ</code> terms can be used in <code>e</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.filterUpwards" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
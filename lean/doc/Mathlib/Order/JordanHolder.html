<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Order.JordanHolder</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Order.JordanHolder";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Order</span>.<span class="name">JordanHolder</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Order/Lattice.html">Mathlib.Order.Lattice</a></li><li><a href="../.././Mathlib/Order/RelSeries.html">Mathlib.Order.RelSeries</a></li><li><a href="../.././Mathlib/Data/Fintype/Pigeonhole.html">Mathlib.Data.Fintype.Pigeonhole</a></li><li><a href="../.././Mathlib/Data/List/Sort.html">Mathlib.Data.List.Sort</a></li><li><a href="../.././Mathlib/Logic/Equiv/Functor.html">Mathlib.Logic.Equiv.Functor</a></li><li><a href="../.././Mathlib/Logic/Equiv/Fin/Basic.html">Mathlib.Logic.Equiv.Fin.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Order.JordanHolder" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice"><span class="name">JordanHolderLattice</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_inf_right_of_isMaximal_sup</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.isMaximal_of_eq_inf"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_of_eq_inf</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.second_iso_of_eq"><span class="name">JordanHolderLattice</span>.<span class="name">second_iso_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.IsMaximal.iso_refl"><span class="name">JordanHolderLattice</span>.<span class="name">IsMaximal</span>.<span class="name">iso_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries"><span class="name">CompositionSeries</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.lt_succ"><span class="name">CompositionSeries</span>.<span class="name">lt_succ</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.strictMono"><span class="name">CompositionSeries</span>.<span class="name">strictMono</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.injective"><span class="name">CompositionSeries</span>.<span class="name">injective</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.inj"><span class="name">CompositionSeries</span>.<span class="name">inj</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.total"><span class="name">CompositionSeries</span>.<span class="name">total</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList_sorted"><span class="name">CompositionSeries</span>.<span class="name">toList_sorted</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList_nodup"><span class="name">CompositionSeries</span>.<span class="name">toList_nodup</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.ext"><span class="name">CompositionSeries</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.ext_iff"><span class="name">CompositionSeries</span>.<span class="name">ext_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.le_last"><span class="name">CompositionSeries</span>.<span class="name">le_last</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.le_last_of_mem"><span class="name">CompositionSeries</span>.<span class="name">le_last_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.head_le"><span class="name">CompositionSeries</span>.<span class="name">head_le</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.head_le_of_mem"><span class="name">CompositionSeries</span>.<span class="name">head_le_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.last_eraseLast_le"><span class="name">CompositionSeries</span>.<span class="name">last_eraseLast_le</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.mem_eraseLast_of_ne_of_mem"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseLast_of_ne_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.mem_eraseLast"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseLast</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.lt_last_of_mem_eraseLast"><span class="name">CompositionSeries</span>.<span class="name">lt_last_of_mem_eraseLast</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.isMaximal_eraseLast_last"><span class="name">CompositionSeries</span>.<span class="name">isMaximal_eraseLast_last</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eq_snoc_eraseLast"><span class="name">CompositionSeries</span>.<span class="name">eq_snoc_eraseLast</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.snoc_eraseLast_last"><span class="name">CompositionSeries</span>.<span class="name">snoc_eraseLast_last</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.refl"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.symm"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.trans"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.smash"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">smash</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.snoc"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.length_eq"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">length_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.snoc_snoc_swap"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc_snoc_swap</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.length_pos_of_head_eq_head_of_last_eq_last_of_length_pos"><span class="name">CompositionSeries</span>.<span class="name">length_pos_of_head_eq_head_of_last_eq_last_of_length_pos</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.exists_last_eq_snoc_equivalent"><span class="name">CompositionSeries</span>.<span class="name">exists_last_eq_snoc_equivalent</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.jordan_holder"><span class="name">CompositionSeries</span>.<span class="name">jordan_holder</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Jordan-Hölder-Theorem">Jordan-Hölder Theorem <a class="hover-link" href="#Jordan-Hölder-Theorem">#</a></h1><p>This file proves the Jordan Hölder theorem for a <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code>, a class also defined in
this file. Examples of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> include <code>Subgroup G</code> if <code>G</code> is a group, and
<code>Submodule R M</code> if <code>M</code> is an <code>R</code>-module. Using this approach the theorem need not be proved
separately for both groups and modules, the proof in this file can be applied to both.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><p>The main definitions in this file are <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> and <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code>,
and the relation <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></code> on <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code></p><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> is the class for which the Jordan Hölder theorem is proved. A
Jordan Hölder lattice is a lattice equipped with a notion of maximality, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a></code>, and a notion
of isomorphism of pairs <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code>. In the example of subgroups of a group, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> H K</code> means that
<code>H</code> is a maximal normal subgroup of <code>K</code>, and <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H₁, K₁) (H₂, K₂)</code> means that the quotient
<code>H₁ / K₁</code> is isomorphic to the quotient <code>H₂ / K₂</code>. <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code> must be symmetric and transitive and must
satisfy the second isomorphism theorem <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H, H ⊔ K) (H ⊓ K, K)</code>.</p><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is a finite nonempty series of elements of the lattice <code>X</code> such that
each element is maximal inside the next. The length of a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is
one less than the number of elements in the series. Note that there is no stipulation
that a series start from the bottom of the lattice and finish at the top.
For a composition series <code>s</code>, <code>s.last</code> is the largest element of the series,
and <code>s.head</code> is the least element.</p><p>Two <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code>, <code>s₁</code> and <code>s₂</code> are equivalent if there is a bijection
<code>e : <a href="../.././Init/Prelude.html#Fin">Fin</a> s₁.length ≃ <a href="../.././Init/Prelude.html#Fin">Fin</a> s₂.length</code> such that for any <code>i</code>,
<code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (s₁ i, s₁ i.succ) (s₂ (e i), s₂ (e i.succ))</code></p><h2 class="markdown-heading" id="Main-theorems">Main theorems <a class="hover-link" href="#Main-theorems">#</a></h2><p>The main theorem is <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.jordan_holder">CompositionSeries.jordan_holder</a></code>, which says that if two composition
series have the same least element and the same largest element,
then they are <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></code>.</p><h2 class="markdown-heading" id="TODO">TODO <a class="hover-link" href="#TODO">#</a></h2><p>Provide instances of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> for subgroups, and potentially for modular lattices.</p><p>It is not entirely clear how this should be done. Possibly there should be no global instances
of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code>, and the instances should only be defined locally in order to prove
the Jordan-Hölder theorem for modules/groups and the API should be transferred because many of the
theorems in this file will have stronger versions for modules. There will also need to be an API for
mapping composition series across homomorphisms. It is also probably possible to
provide an instance of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> for any <code>ModularLattice</code>, and in this case the
Jordan-Hölder theorem will say that there is a well-defined notion of length of a modular lattice.
However an instance of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> for a modular lattice will not be able to contain
the correct notion of isomorphism for modules, so a separate instance for modules will still be
required and this will clash with the instance for modular lattices, and so at least one of these
instances should not be a global instance.</p><blockquote>
<p>[!NOTE]
The previous paragraph indicates that the instance of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> for submodules should
be obtained via <code>ModularLattice</code>. This is not the case in <code>mathlib4</code>.
See <code>JordanHolderModule.instJordanHolderLattice</code>.</p>
</blockquote></div><div class="decl" id="JordanHolderLattice"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L76-L93">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice"><span class="name">JordanHolderLattice</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u</div></div><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> is the class for which the Jordan Hölder theorem is proved. A
Jordan Hölder lattice is a lattice equipped with a notion of maximality, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a></code>, and a notion
of isomorphism of pairs <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code>. In the example of subgroups of a group, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> H K</code> means that
<code>H</code> is a maximal normal subgroup of <code>K</code>, and <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H₁, K₁) (H₂, K₂)</code> means that the quotient
<code>H₁ / K₁</code> is isomorphic to the quotient <code>H₂ / K₂</code>. <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code> must be symmetric and transitive and must
satisfy the second isomorphism theorem <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H, H ⊔ K) (H ⊓ K, K)</code>.
Examples include <code>Subgroup G</code> if <code>G</code> is a group, and <code>Submodule R M</code> if <code>M</code> is an <code>R</code>-module.</p><ul class="structure_fields" id="JordanHolderLattice.mk"><li id="JordanHolderLattice.IsMaximal" class="structure_field"><div class="structure_field_info">IsMaximal : <span class="fn"><span class="fn">X</span> → <span class="fn">X</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li id="JordanHolderLattice.lt_of_isMaximal" class="structure_field"><div class="structure_field_info">lt_of_isMaximal<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn">x</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span></span></div></li><li id="JordanHolderLattice.sup_eq_of_isMaximal" class="structure_field"><div class="structure_field_info">sup_eq_of_isMaximal<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">z</span> : <span class="fn">X</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> → <span class="fn"><span class="fn">x</span> ⊔ <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">z</span></span></span></span></div></li><li id="JordanHolderLattice.isMaximal_inf_left_of_isMaximal_sup" class="structure_field"><div class="structure_field_info">isMaximal_inf_left_of_isMaximal_sup<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">(<span class="fn">x</span> ⊔ <span class="fn">y</span>)</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">y</span> <span class="fn">(<span class="fn">x</span> ⊔ <span class="fn">y</span>)</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">(<span class="fn">x</span> ⊓ <span class="fn">y</span>)</span> <span class="fn">x</span></span></span></span></div></li><li id="JordanHolderLattice.Iso" class="structure_field"><div class="structure_field_info">Iso : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span> → <span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li id="JordanHolderLattice.iso_symm" class="structure_field"><div class="structure_field_info">iso_symm<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <span class="fn">y</span> <span class="fn">x</span></span></span></div></li><li id="JordanHolderLattice.iso_trans" class="structure_field"><div class="structure_field_info">iso_trans<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">z</span> : <span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <span class="fn">x</span> <span class="fn">z</span></span></span></span></div></li><li id="JordanHolderLattice.second_iso" class="structure_field"><div class="structure_field_info">second_iso<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">(<span class="fn">x</span> ⊔ <span class="fn">y</span>)</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span> ⊔ <span class="fn">y</span></span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span> ⊓ <span class="fn">y</span></span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-JordanHolderLattice" class="instances-list"></ul></details></div></div><div class="decl" id="JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L99-L103">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_inf_right_of_isMaximal_sup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hxz</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">(<span class="fn">x</span> ⊔ <span class="fn">y</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hyz</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">y</span> <span class="fn">(<span class="fn">x</span> ⊔ <span class="fn">y</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">(<span class="fn">x</span> ⊓ <span class="fn">y</span>)</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="JordanHolderLattice.isMaximal_of_eq_inf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L105-L109">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_of_eq_inf"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_of_eq_inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">b</span> : <span class="fn">X</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn">x</span> ⊓ <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hxy</span> : <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hxb</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hyb</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">y</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">a</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="JordanHolderLattice.second_iso_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L111-L112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.second_iso_of_eq"><span class="name">JordanHolderLattice</span>.<span class="name">second_iso_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y </span><span class="fn">a </span><span class="fn">b</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hm</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><span class="fn">x</span> ⊔ <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><span class="fn">x</span> ⊓ <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">a</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">b</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span></div></div></div></div><div class="decl" id="JordanHolderLattice.IsMaximal.iso_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L114-L116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal.iso_refl"><span class="name">JordanHolderLattice</span>.<span class="name">IsMaximal</span>.<span class="name">iso_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span></div></div></div></div><div class="decl" id="CompositionSeries"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L126-L134">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries"><span class="name">CompositionSeries</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u</div></div><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is a finite nonempty series of elements of a
<code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> such that each element is maximal inside the next. The length of a
<code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is one less than the number of elements in the series.
Note that there is no stipulation that a series start from the bottom of the lattice and finish at
the top. For a composition series <code>s</code>, <code>s.last</code> is the largest element of the series,
and <code>s.head</code> is the least element.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries">RelSeries</a> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">{</a><a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span> <a href="../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">y</span></span><a href="../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></li></ul></details><details id="instances-for-list-CompositionSeries" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.lt_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L140-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.lt_succ"><span class="name">CompositionSeries</span>.<span class="name">lt_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span> <span class="fn"><span class="fn">i</span>.<a href="../.././Init/Data/Fin/Basic.html#Fin.castSucc">castSucc</a></span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span> <span class="fn"><span class="fn">i</span>.<a href="../.././Init/Data/Fin/Basic.html#Fin.succ">succ</a></span></span></div></div></div></div><div class="decl" id="CompositionSeries.strictMono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L144-L145">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.strictMono"><span class="name">CompositionSeries</span>.<span class="name">strictMono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span></span></div></div></div></div><div class="decl" id="CompositionSeries.injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L147-L148">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.injective"><span class="name">CompositionSeries</span>.<span class="name">injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Data/Function.html#Function.Injective">Function.Injective</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span></span></div></div></div></div><div class="decl" id="CompositionSeries.inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L150-L152">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.inj"><span class="name">CompositionSeries</span>.<span class="name">inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j</span> : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span>.<a href="../.././Init/Prelude.html#Nat.succ">succ</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span> <span class="fn">j</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">i</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></div></div></div></div><div class="decl" id="CompositionSeries.total"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L154-L158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.total"><span class="name">CompositionSeries</span>.<span class="name">total</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hy</span> : <span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">y</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="CompositionSeries.toList_sorted"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L160-L164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList_sorted"><span class="name">CompositionSeries</span>.<span class="name">toList_sorted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/List/Sort.html#List.Sorted">List.Sorted</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">X</span>) =&gt; <span class="fn">x1</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toList">RelSeries.toList</a> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.toList_nodup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L166-L167">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList_nodup"><span class="name">CompositionSeries</span>.<span class="name">toList_nodup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toList">RelSeries.toList</a> <span class="fn">s</span>)</span>.<a href="../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span></div></div></div></div><div class="decl" id="CompositionSeries.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L169-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ext"><span class="name">CompositionSeries</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span></div></div><p>Two <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code> are equal if they have the same elements. See also <code>ext_fun</code>.</p></div></div><div class="decl" id="CompositionSeries.ext_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L170-L170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ext_iff"><span class="name">CompositionSeries</span>.<span class="name">ext_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s₁</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s₂</span></span></div></div></div></div><div class="decl" id="CompositionSeries.le_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L180-L182">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.le_last"><span class="name">CompositionSeries</span>.<span class="name">le_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> (<span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.le_last_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L184-L186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.le_last_of_mem"><span class="name">CompositionSeries</span>.<span class="name">le_last_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.head_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L188-L190">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.head_le"><span class="name">CompositionSeries</span>.<span class="name">head_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> (<span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.toFun">toFun</a></span> <span class="fn">i</span></span></div></div></div></div><div class="decl" id="CompositionSeries.head_le_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L192-L194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.head_le_of_mem"><span class="name">CompositionSeries</span>.<span class="name">head_le_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="CompositionSeries.last_eraseLast_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L196-L197">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.last_eraseLast_le"><span class="name">CompositionSeries</span>.<span class="name">last_eraseLast_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">last</a></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.mem_eraseLast_of_ne_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L199-L206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseLast_of_ne_of_mem"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseLast_of_ne_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hxs</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.mem_eraseLast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L208-L216">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseLast"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseLast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></div></div></div></div><div class="decl" id="CompositionSeries.lt_last_of_mem_eraseLast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L218-L220">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.lt_last_of_mem_eraseLast"><span class="name">CompositionSeries</span>.<span class="name">lt_last_of_mem_eraseLast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.isMaximal_eraseLast_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L222-L228">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.isMaximal_eraseLast_last"><span class="name">CompositionSeries</span>.<span class="name">isMaximal_eraseLast_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">last</a></span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.eq_snoc_eraseLast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L230-L234">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eq_snoc_eraseLast"><span class="name">CompositionSeries</span>.<span class="name">eq_snoc_eraseLast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">snoc</a></span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="CompositionSeries.snoc_eraseLast_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L236-L241">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc_eraseLast_last"><span class="name">CompositionSeries</span>.<span class="name">snoc_eraseLast_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">last</a></span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.eraseLast">RelSeries.eraseLast</a> <span class="fn">s</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">snoc</a></span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s</span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L243-L249">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Two <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code>, <code>s₁</code> and <code>s₂</code> are equivalent if there is a bijection
<code>e : <a href="../.././Init/Prelude.html#Fin">Fin</a> s₁.length ≃ <a href="../.././Init/Prelude.html#Fin">Fin</a> s₂.length</code> such that for any <code>i</code>,
<code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (s₁ i) (s₁ i.succ) (s₂ (e i), s₂ (e i.succ))</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CompositionSeries.Equivalent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.Equivalent.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L253-L255">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.refl"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L257-L259">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.symm"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s₂</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₁</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L261-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.trans"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">s₃</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">s₂</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₃</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₃</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.smash"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L267-L282">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.smash"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">smash</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂ </span><span class="fn">t₁ </span><span class="fn">t₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">t₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">t₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">t₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">s₂</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">t₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.smash">RelSeries.smash</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">hs</span>)</span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.smash">RelSeries.smash</a> <span class="fn">t₁</span> <span class="fn">t₂</span> <span class="fn">ht</span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.snoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L284-L296">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x₁ </span><span class="fn">x₂</span> : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hsat₁</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₁</span>)</span> <span class="fn">x₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hsat₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₂</span>)</span> <span class="fn">x₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hequiv</span> : <span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hlast</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₁</span></span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x₁</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₂</span></span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x₂</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">RelSeries.snoc</a> <span class="fn">s₁</span> <span class="fn">x₁</span> <span class="fn">hsat₁</span>)</span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">RelSeries.snoc</a> <span class="fn">s₂</span> <span class="fn">x₂</span> <span class="fn">hsat₂</span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.length_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L298-L299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.length_eq"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">length_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s₂</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.snoc_snoc_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L301-L328">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc_snoc_swap"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc_snoc_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x₁ </span><span class="fn">x₂ </span><span class="fn">y₁ </span><span class="fn">y₂</span> : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hsat₁</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span> <span class="fn">x₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hsat₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span> <span class="fn">x₂</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hsaty₁</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">RelSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₁</span> <span class="fn">hsat₁</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">last</a></span> <span class="fn">y₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hsaty₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">RelSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₂</span> <span class="fn">hsat₂</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">last</a></span> <span class="fn">y₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr₁</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x₁</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x₂</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y₂</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hr₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x₁</span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y₁</span><a href="../.././Init/Prelude.html#Prod.mk">)</a> <a href="../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span></span><a href="../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">x₂</span><a href="../.././Init/Prelude.html#Prod.mk">)</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">RelSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₁</span> <span class="fn">hsat₁</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">snoc</a></span> <span class="fn">y₁</span> <span class="fn">hsaty₁</span>)</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">RelSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₂</span> <span class="fn">hsat₂</span>)</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">snoc</a></span> <span class="fn">y₂</span> <span class="fn">hsaty₂</span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L332-L337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">length_eq_zero_of_head_eq_head_of_last_eq_last_of_length_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs₁</span> : <span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s₂</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="CompositionSeries.length_pos_of_head_eq_head_of_last_eq_last_of_length_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L339-L344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length_pos_of_head_eq_head_of_last_eq_last_of_length_pos"><span class="name">CompositionSeries</span>.<span class="name">length_pos_of_head_eq_head_of_last_eq_last_of_length_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> → <span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s₂</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span></span></div></div></div></div><div class="decl" id="CompositionSeries.eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L346-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">eq_of_head_eq_head_of_last_eq_last_of_length_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs₁0</span> : <span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span></div></div></div></div><div class="decl" id="CompositionSeries.exists_last_eq_snoc_equivalent"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L359-L397">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.exists_last_eq_snoc_equivalent"><span class="name">CompositionSeries</span>.<span class="name">exists_last_eq_snoc_equivalent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hm</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">t</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>),
  <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn">t</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.length">length</a></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn">∃ (<span class="fn">htx</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span>), <span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.snoc">RelSeries.snoc</a> <span class="fn">t</span> <span class="fn">(<a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s</span>)</span> <span class="fn">⋯</span>)</span></span></span></span></div></div><p>Given a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code>, <code>s</code>, and an element <code>x</code>
such that <code>x</code> is maximal inside <code>s.last</code> there is a series, <code>t</code>,
such that <code>t.last = x</code>, <code>t.head = s.head</code>
and <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc">snoc</a> t s.last _</code> is equivalent to <code>s</code>.</p></div></div><div class="decl" id="CompositionSeries.jordan_holder"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Order/JordanHolder.lean#L399-L417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.jordan_holder"><span class="name">CompositionSeries</span>.<span class="name">jordan_holder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s₁ </span><span class="fn">s₂</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.head">RelSeries.head</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/RelSeries.html#RelSeries.last">RelSeries.last</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s₁</span>.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></span> <span class="fn">s₂</span></span></div></div><p>The <strong>Jordan-Hölder</strong> theorem, stated for any <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code>.
If two composition series start and finish at the same place, they are equivalent.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
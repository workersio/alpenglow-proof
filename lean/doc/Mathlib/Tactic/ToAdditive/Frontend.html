<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.ToAdditive.Frontend</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.ToAdditive.Frontend";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToAdditive</span>.<span class="name">Frontend</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Batteries/Tactic/Trans.html">Batteries.Tactic.Trans</a></li><li><a href="../../.././Lean/Compiler/NoncomputableAttr.html">Lean.Compiler.NoncomputableAttr</a></li><li><a href="../../.././Mathlib/Lean/Name.html">Mathlib.Lean.Name</a></li><li><a href="../../.././Mathlib/Tactic/Eqns.html">Mathlib.Tactic.Eqns</a></li><li><a href="../../.././Lean/Elab/Tactic/Ext.html">Lean.Elab.Tactic.Ext</a></li><li><a href="../../.././Lean/Meta/Tactic/Rfl.html">Lean.Meta.Tactic.Rfl</a></li><li><a href="../../.././Lean/Meta/Tactic/Symm.html">Lean.Meta.Tactic.Symm</a></li><li><a href="../../.././Lean/Meta/Tactic/TryThis.html">Lean.Meta.Tactic.TryThis</a></li><li><a href="../../.././Mathlib/Data/Array/Defs.html">Mathlib.Data.Array.Defs</a></li><li><a href="../../.././Mathlib/Data/Nat/Notation.html">Mathlib.Data.Nat.Notation</a></li><li><a href="../../.././Mathlib/Lean/Expr/ReplaceRec.html">Mathlib.Lean.Expr.ReplaceRec</a></li><li><a href="../../.././Mathlib/Lean/Meta/Simp.html">Mathlib.Lean.Meta.Simp</a></li><li><a href="../../.././Mathlib/Tactic/Simps/Basic.html">Mathlib.Tactic.Simps.Basic</a></li><li><a href="../../.././Mathlib/Tactic/ToAdditive/GuessName.html">Mathlib.Tactic.ToAdditive.GuessName</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.ToAdditive.Frontend" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#ToAdditive.to_additive_ignore_args"><span class="name">ToAdditive</span>.<span class="name">to_additive_ignore_args</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.to_additive_relevant_arg"><span class="name">ToAdditive</span>.<span class="name">to_additive_relevant_arg</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.to_additive_change_numeral"><span class="name">ToAdditive</span>.<span class="name">to_additive_change_numeral</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.to_additive_dont_translate"><span class="name">ToAdditive</span>.<span class="name">to_additive_dont_translate</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.toAdditiveAttrOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveAttrOption</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.toAdditiveReorderOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveReorderOption</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.toAdditiveRelevantOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveRelevantOption</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.toAdditiveDontTranslateOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveDontTranslateOption</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.toAdditiveOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveOption</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.toAdditiveNameHint"><span class="name">ToAdditive</span>.<span class="name">toAdditiveNameHint</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.toAdditiveRest"><span class="name">ToAdditive</span>.<span class="name">toAdditiveRest</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.to_additive"><span class="name">ToAdditive</span>.<span class="name">to_additive</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.attrTo_additive?_"><span class="name">ToAdditive</span>.<span class="name">attrTo_additive?_</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.linter.existingAttributeWarning"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">existingAttributeWarning</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.linter.toAdditiveGenerateName"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">toAdditiveGenerateName</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.linter.toAdditiveExisting"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">toAdditiveExisting</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.linter.toAdditiveRelevantArg"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">toAdditiveRelevantArg</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.ignoreArgsAttr"><span class="name">ToAdditive</span>.<span class="name">ignoreArgsAttr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.reorderAttr"><span class="name">ToAdditive</span>.<span class="name">reorderAttr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.relevantArgAttr"><span class="name">ToAdditive</span>.<span class="name">relevantArgAttr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.dontTranslateAttr"><span class="name">ToAdditive</span>.<span class="name">dontTranslateAttr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.changeNumeralAttr"><span class="name">ToAdditive</span>.<span class="name">changeNumeralAttr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.translations"><span class="name">ToAdditive</span>.<span class="name">translations</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.findTranslation?"><span class="name">ToAdditive</span>.<span class="name">findTranslation?</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.findPrefixTranslation"><span class="name">ToAdditive</span>.<span class="name">findPrefixTranslation</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.insertTranslation"><span class="name">ToAdditive</span>.<span class="name">insertTranslation</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.ArgInfo"><span class="name">ToAdditive</span>.<span class="name">ArgInfo</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.insertTranslationAndInfo"><span class="name">ToAdditive</span>.<span class="name">insertTranslationAndInfo</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.Config"><span class="name">ToAdditive</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.instReprConfig"><span class="name">ToAdditive</span>.<span class="name">instReprConfig</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.instReprConfig.repr"><span class="name">ToAdditive</span>.<span class="name">instReprConfig</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.etaExpandN"><span class="name">ToAdditive</span>.<span class="name">etaExpandN</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.expand"><span class="name">ToAdditive</span>.<span class="name">expand</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.additiveTestUnsafe"><span class="name">ToAdditive</span>.<span class="name">additiveTestUnsafe</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.additiveTestUnsafe.visit"><span class="name">ToAdditive</span>.<span class="name">additiveTestUnsafe</span>.<span class="name">visit</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.additiveTest"><span class="name">ToAdditive</span>.<span class="name">additiveTest</span></a></div><div class="nav_link"><a class="break_within" href="#List.swapFirstTwo"><span class="name">List</span>.<span class="name">swapFirstTwo</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.changeNumeral"><span class="name">ToAdditive</span>.<span class="name">changeNumeral</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.applyReplacementFun"><span class="name">ToAdditive</span>.<span class="name">applyReplacementFun</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.applyReplacementFun.aux"><span class="name">ToAdditive</span>.<span class="name">applyReplacementFun</span>.<span class="name">aux</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.renameBinderNames"><span class="name">ToAdditive</span>.<span class="name">renameBinderNames</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.reorderForall"><span class="name">ToAdditive</span>.<span class="name">reorderForall</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.reorderLambda"><span class="name">ToAdditive</span>.<span class="name">reorderLambda</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.applyReplacementForall"><span class="name">ToAdditive</span>.<span class="name">applyReplacementForall</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.applyReplacementLambda"><span class="name">ToAdditive</span>.<span class="name">applyReplacementLambda</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.declUnfoldAuxLemmas"><span class="name">ToAdditive</span>.<span class="name">declUnfoldAuxLemmas</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.getDontTranslates"><span class="name">ToAdditive</span>.<span class="name">getDontTranslates</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.updateDecl"><span class="name">ToAdditive</span>.<span class="name">updateDecl</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.declAbstractNestedProofs"><span class="name">ToAdditive</span>.<span class="name">declAbstractNestedProofs</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.findTargetName"><span class="name">ToAdditive</span>.<span class="name">findTargetName</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.findAuxDecls"><span class="name">ToAdditive</span>.<span class="name">findAuxDecls</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.transformDeclAux"><span class="name">ToAdditive</span>.<span class="name">transformDeclAux</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.copyInstanceAttribute"><span class="name">ToAdditive</span>.<span class="name">copyInstanceAttribute</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.warnAttrCore"><span class="name">ToAdditive</span>.<span class="name">warnAttrCore</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.warnAttr"><span class="name">ToAdditive</span>.<span class="name">warnAttr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.warnParametricAttr"><span class="name">ToAdditive</span>.<span class="name">warnParametricAttr</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.additivizeLemmas"><span class="name">ToAdditive</span>.<span class="name">additivizeLemmas</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.findMultiplicativeArg"><span class="name">ToAdditive</span>.<span class="name">findMultiplicativeArg</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.targetName"><span class="name">ToAdditive</span>.<span class="name">targetName</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.proceedFieldsAux"><span class="name">ToAdditive</span>.<span class="name">proceedFieldsAux</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.proceedFields"><span class="name">ToAdditive</span>.<span class="name">proceedFields</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.elabToAdditive"><span class="name">ToAdditive</span>.<span class="name">elabToAdditive</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.applyAttributes"><span class="name">ToAdditive</span>.<span class="name">applyAttributes</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.copyMetaData"><span class="name">ToAdditive</span>.<span class="name">copyMetaData</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.transformDecl"><span class="name">ToAdditive</span>.<span class="name">transformDecl</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.checkExistingType"><span class="name">ToAdditive</span>.<span class="name">checkExistingType</span></a></div><div class="nav_link"><a class="break_within" href="#ToAdditive.addToAdditiveAttr"><span class="name">ToAdditive</span>.<span class="name">addToAdditiveAttr</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-to-additive-attribute">The <code>@[to_additive]</code> attribute. <a class="hover-link" href="#The-to-additive-attribute">#</a></h1><p>Implementation of the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> attribute.
See the docstring of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">ToAdditive.to_additive</a></code> for more information</p></div><div class="decl" id="ToAdditive.to_additive_ignore_args"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L32-L36">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_ignore_args"><span class="name">ToAdditive</span>.<span class="name">to_additive_ignore_args</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An attribute that tells <code>@[to_additive]</code> that certain arguments of this definition are not
involved when using <code>@[to_additive]</code>.
This helps the heuristic of <code>@[to_additive]</code> by also transforming definitions if <code>ℕ</code> or another
fixed type occurs as one of these arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.to_additive_ignore_args" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.to_additive_relevant_arg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L38-L39">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_relevant_arg"><span class="name">ToAdditive</span>.<span class="name">to_additive_relevant_arg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>This attribute is deprecated. Use <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> (relevant_arg := ...)</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.to_additive_relevant_arg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.to_additive_change_numeral"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L41-L54">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_change_numeral"><span class="name">ToAdditive</span>.<span class="name">to_additive_change_numeral</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An attribute that stores all the declarations that deal with numeric literals on variable types.</p><p>Numeral literals occur in expressions without type information, so in order to decide whether <code>1</code>
needs to be changed to <code>0</code>, the context around the numeral is relevant.
Most numerals will be in an <code><a href="../../.././Init/Prelude.html#OfNat.ofNat">OfNat.ofNat</a></code> application, though tactics can add numeral literals
inside arbitrary functions. By default we assume that we do not change numerals, unless it is
in a function application with the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_change_numeral">to_additive_change_numeral</a></code> attribute.</p><p><code>@[to_additive_change_numeral n₁ ...]</code> should be added to all functions that take one or more
numerals as argument that should be changed if <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest">additiveTest</a></code> succeeds on the first argument,
i.e. when the numeral is only translated if the first argument is a variable
(or consists of variables).
The arguments <code>n₁ ...</code> are the positions of the numeral arguments (starting counting from 1).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.to_additive_change_numeral" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.to_additive_dont_translate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L56-L65">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_dont_translate"><span class="name">ToAdditive</span>.<span class="name">to_additive_dont_translate</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_dont_translate">to_additive_dont_translate</a></code> attribute, used to specify types that should be translated by
<code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>, but its operations should remain multiplicative.</p><p>Usage notes:</p><ul>
<li>Apply this together with the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> attribute.</li>
<li>The name generation of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> is not aware that the operations on this type should not be
translated, so you generally have to specify the name itself, if the name should remain
multiplicative.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_dont_translate">ToAdditive.to_additive_dont_translate</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`ToAdditive.to_additive_dont_translate</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;to_additive_dont_translate&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-ToAdditive.to_additive_dont_translate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.toAdditiveAttrOption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L67-L68">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.toAdditiveAttrOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveAttrOption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An <code>attr := ...</code> option for <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.toAdditiveAttrOption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.toAdditiveReorderOption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L69-L76">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.toAdditiveReorderOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveReorderOption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo.reorder">reorder</a> := ...</code> reorders the arguments/hypotheses in the generated declaration.
It uses cycle notation. For example <code>(reorder := 1 2, 5 6)</code> swaps the first two
arguments with each other and the fifth and the sixth argument and <code>(reorder := 3 4 5)</code> will move
the fifth argument before the third argument. This is used in <code>to_dual</code> to swap the arguments in
<code>≤</code>, <code>&lt;</code> and <code>⟶</code>. It is also used in <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> to translate from <code>^</code> to <code>•</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.toAdditiveReorderOption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.toAdditiveRelevantOption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L77-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.toAdditiveRelevantOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveRelevantOption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>the <code>relevant_arg := ...</code> option tells which argument is a type where this declaration uses the
multiplicative structure. This is inferred automatically using the function <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findMultiplicativeArg">findMultiplicativeArg</a></code>,
but it can also be overwritten using this syntax.</p><p>If there are multiple arguments with a multiplicative structure, we typically tag the first one.
If this argument contains a fixed type, this declaration will not be additivized.
See the Heuristics section of the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> doc-string for more details.</p><p>If a declaration is not tagged, it is presumed that the first argument is relevant.</p><p>To indicate that there is no relevant argument, set it to a number that is out of bounds,
i.e. larger than the number of arguments, e.g. <code>(relevant_arg := 100)</code>.</p><p>Implementation note: we only allow exactly 1 relevant argument, even though some declarations
(like <code>Prod.instGroup</code>) have multiple arguments with a multiplicative structure on it.
The reason is that whether we additivize a declaration is an all-or-nothing decision, and
we will not be able to additivize declarations that (e.g.) talk about multiplication on <code>ℕ × α</code>
anyway.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.toAdditiveRelevantOption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.toAdditiveDontTranslateOption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L98-L106">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.toAdditiveDontTranslateOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveDontTranslateOption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>dont_translate := ...</code> takes a list of type variables (separated by spaces) that should not be
considered for translation. For example in</p><pre><code><a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> foo {α β : Type} [Group α] [Group β] (a : α) (b : β) : a * a⁻¹ = 1 ↔ b * b⁻¹ = 1
</code></pre><p>we can choose to only additivize <code>α</code> by writing <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> (dont_translate := β)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.toAdditiveDontTranslateOption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.toAdditiveOption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L107-L109">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.toAdditiveOption"><span class="name">ToAdditive</span>.<span class="name">toAdditiveOption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Options to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.toAdditiveOption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.toAdditiveNameHint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L110-L111">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.toAdditiveNameHint"><span class="name">ToAdditive</span>.<span class="name">toAdditiveNameHint</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.existing">existing</a></code> or <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.self">self</a></code> name hint for <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.toAdditiveNameHint" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.toAdditiveRest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L112-L114">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.toAdditiveRest"><span class="name">ToAdditive</span>.<span class="name">toAdditiveRest</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Remaining arguments of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.toAdditiveRest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.to_additive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L116-L331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive"><span class="name">ToAdditive</span>.<span class="name">to_additive</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The attribute <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> can be used to automatically transport theorems
and definitions (but not inductive types and structures) from a multiplicative
theory to an additive theory.</p><p>To use this attribute, just write:</p><pre><code>@[to_additive]
theorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := mul_comm x y
</code></pre><p>This code will generate a theorem named <code>add_comm'</code>. It is also
possible to manually specify the name of the new declaration:</p><pre><code>@[to_additive add_foo]
theorem foo := sorry
</code></pre><p>An existing documentation string will <em>not</em> be automatically used, so if the theorem or definition
has a doc string, a doc string for the additive version should be passed explicitly to
<code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><pre><code>/-- Multiplication is commutative -/
@[to_additive /-- Addition is commutative -/]
theorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := CommSemigroup.mul_comm
</code></pre><p>The transport tries to do the right thing in most cases using several
heuristics described below.  However, in some cases it fails, and
requires manual intervention.</p><p>Use the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.existing">existing</a></code> syntax to use an existing additive declaration, instead of
automatically generating it.</p><p>Use the <code>(reorder := ...)</code> syntax to reorder the arguments in the generated additive declaration.
This is specified using cycle notation. For example <code>(reorder := 1 2, 5 6)</code> swaps the first two
arguments with each other and the fifth and the sixth argument and <code>(reorder := 3 4 5)</code> will move
the fifth argument before the third argument. This is mostly useful to translate declarations using
<code><a href="../../.././Init/Prelude.html#Pow">Pow</a></code> to those using <code><a href="../../.././Init/Prelude.html#SMul">SMul</a></code>.</p><p>Use the <code>(attr := ...)</code> syntax to apply attributes to both the multiplicative and the additive
version:</p><pre><code>@[to_additive (attr := simp)] <a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> mul_one' {G : Type*} [Group G] (x : G) : x * 1 = x := mul_one x
</code></pre><p>For <code>simps</code> this also ensures that some generated lemmas are added to the additive dictionary.
<code>@[to_additive (attr := to_additive)]</code> is a special case, where the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>
attribute is added to the generated lemma only, to additivize it again.
This is useful for lemmas about <code><a href="../../.././Init/Prelude.html#Pow">Pow</a></code> to generate both lemmas about <code><a href="../../.././Init/Prelude.html#SMul">SMul</a></code> and <code>VAdd</code>. Example:</p><pre><code>@[to_additive (attr := <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> VAdd_lemma, simp) SMul_lemma]
<a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> Pow_lemma ... :=
</code></pre><p>In the above example, the <code>simp</code> is added to all 3 lemmas. All other options to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>
(like the generated name or <code>(reorder := ...)</code>) are not passed down,
and can be given manually to each individual <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> call.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>The transport process generally works by taking all the names of
identifiers appearing in the name, type, and body of a declaration and
creating a new declaration by mapping those names to additive versions
using a simple string-based dictionary and also using all declarations
that have previously been labeled with <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>. The dictionary is <code><a href="../../.././Mathlib/Tactic/ToAdditive/GuessName.html#ToAdditive.nameDict">ToAdditive.nameDict</a></code>
and can be found in the <code>Tactic.ToAdditive.GuessName</code> file. If you introduce a new name which
should be translated by <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> you should add the translation to this dictionary.</p><p>In the <code>mul_comm'</code> example above, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> maps:</p><ul>
<li><code>mul_comm'</code> to <code>add_comm'</code>,</li>
<li><code>CommSemigroup</code> to <code>AddCommSemigroup</code>,</li>
<li><code>x * y</code> to <code>x + y</code> and <code>y * x</code> to <code>y + x</code>, and</li>
<li><code>CommSemigroup.mul_comm'</code> to <code>AddCommSemigroup.add_comm'</code>.</li>
</ul><h3 class="markdown-heading" id="Heuristics">Heuristics <a class="hover-link" href="#Heuristics">#</a></h3><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> uses heuristics to determine whether a particular identifier has to be
mapped to its additive version. The basic heuristic is</p><ul>
<li>Only map an identifier to its additive version if its first argument doesn't
contain any unapplied identifiers.</li>
</ul><p>Examples:</p><ul>
<li><code>@Mul.mul <a href="../../.././Init/Prelude.html#Nat">Nat</a> n m</code> (i.e. <code>(n * m : Nat)</code>) will not change to <code>+</code>, since its
first argument is <code><a href="../../.././Init/Prelude.html#Nat">Nat</a></code>, an identifier not applied to any arguments.</li>
<li><code>@Mul.mul (α × β) x y</code> will change to <code>+</code>. It's first argument contains only the identifier
<code><a href="../../.././Init/Prelude.html#Prod">Prod</a></code>, but this is applied to arguments, <code>α</code> and <code>β</code>.</li>
<li><code>@Mul.mul (α × Int) x y</code> will not change to <code>+</code>, since its first argument contains <code><a href="../../.././Init/Data/Int/Basic.html#Int">Int</a></code>.</li>
</ul><p>The reasoning behind the heuristic is that the first argument is the type which is &quot;additivized&quot;,
and this usually doesn't make sense if this is on a fixed type.</p><p>There are some exceptions to this heuristic:</p><ul>
<li>Identifiers that have the <code>@[to_additive]</code> attribute are ignored.
For example, multiplication in <code>↥Semigroup</code> is replaced by addition in <code>↥AddSemigroup</code>.
You can turn this behavior off by <em>also</em> adding the <code>@[to_additive_dont_translate]</code> attribute.</li>
<li>If an identifier <code>d</code> has attribute <code>@[to_additive (relevant_arg := n)]</code> then the argument
in position <code>n</code> is checked for a fixed type, instead of checking the first argument.
<code>@[to_additive]</code> will automatically add the attribute <code>(relevant_arg := n)</code> to a
declaration when the first argument has no multiplicative type-class, but argument <code>n</code> does.</li>
<li>If an identifier has attribute <code>@[to_additive_ignore_args n1 n2 ...]</code> then all the arguments in
positions <code>n1</code>, <code>n2</code>, ... will not be checked for unapplied identifiers (start counting from 1).
For example, <code>ContMDiffMap</code> has attribute <code>@[to_additive_ignore_args 21]</code>, which means
that its 21st argument <code>(n : WithTop ℕ)</code> can contain <code>ℕ</code>
(usually in the form <code>Top.top ℕ ...</code>) and still be additivized.
So <code>@Mul.mul (C^∞⟮I, N; I', G⟯) _ f g</code> will be additivized.</li>
</ul><h3 class="markdown-heading" id="Troubleshooting">Troubleshooting <a class="hover-link" href="#Troubleshooting">#</a></h3><p>If <code>@[to_additive]</code> fails because the additive declaration raises a type mismatch, there are
various things you can try.
The first thing to do is to figure out what <code>@[to_additive]</code> did wrong by looking at the type
mismatch error.</p><ul>
<li>Option 1: The most common case is that it didn't additivize a declaration that should be
additivized. This happened because the heuristic applied, and the first argument contains a
fixed type, like <code>ℕ</code> or <code>ℝ</code>. However, the heuristic misfires on some other declarations.
Solutions:<ul>
<li>First figure out what the fixed type is in the first argument of the declaration that didn't
get additivized. Note that this fixed type can occur in implicit arguments. If manually finding
it is hard, you can run <code>set_option trace.to_additive_detail true</code> and search the output for the
fragment &quot;contains the fixed type&quot; to find what the fixed type is.</li>
<li>If the fixed type has an additive counterpart (like <code>↥Semigroup</code>), give it the <code>@[to_additive]</code>
attribute.</li>
<li>If the fixed type has nothing to do with algebraic operations (like <code>TopCat</code>), add the attribute
<code>@[to_additive self]</code> to the fixed type <code>Foo</code>.</li>
<li>If the fixed type occurs inside the <code>k</code>-th argument of a declaration <code>d</code>, and the
<code>k</code>-th argument is not connected to the multiplicative structure on <code>d</code>, consider adding
attribute <code>[to_additive_ignore_args k]</code> to <code>d</code>.
Example: <code>ContMDiffMap</code> ignores the argument <code>(n : WithTop ℕ)</code></li>
<li>If none of the arguments have a multiplicative structure, then the heuristic should not apply at
all. This can be achieved by setting <code>relevant_arg</code> out of bounds, e.g. <code>(relevant_arg := 100)</code>.</li>
</ul>
</li>
<li>Option 2: It additivized a declaration <code>d</code> that should remain multiplicative. Solution:<ul>
<li>Make sure the first argument of <code>d</code> is a type with a multiplicative structure. If not, can you
reorder the (implicit) arguments of <code>d</code> so that the first argument becomes a type with a
multiplicative structure (and not some indexing type)?
The reason is that <code>@[to_additive]</code> doesn't additivize declarations if their first argument
contains fixed types like <code>ℕ</code> or <code>ℝ</code>. See section Heuristics.
If the first argument is not the argument with a multiplicative type-class, <code>@[to_additive]</code>
should have automatically added the attribute <code>(relevant_arg := ...)</code> to the declaration.
You can test this by running the following (where <code>d</code> is the full name of the declaration):<pre><code>  open <a href="../../.././Lean.html">Lean</a> in run_cmd logInfo m!&quot;{ToAdditive.relevantArgAttr.find? (← getEnv) `d}&quot;
</code></pre>
The expected output is <code>n</code> where the <code>n</code>-th (0-indexed) argument of <code>d</code> is a type (family)
with a multiplicative structure on it. <code>none</code> means <code>0</code>.
If you get a different output (or a failure), you could add the attribute
<code>@[to_additive (relevant_arg := n)]</code> manually, where <code>n</code> is an (1-indexed) argument with a
multiplicative structure.</li>
</ul>
</li>
<li>Option 3: Arguments / universe levels are incorrectly ordered in the additive version.
This likely only happens when the multiplicative declaration involves <code>pow</code>/<code>^</code>. Solutions:<ul>
<li>Ensure that the order of arguments of all relevant declarations are the same for the
multiplicative and additive version. This might mean that arguments have an &quot;unnatural&quot; order
(e.g. <code>Monoid.npow n x</code> corresponds to <code>x ^ n</code>, but it is convenient that <code>Monoid.npow</code> has this
argument order, since it matches <code>AddMonoid.nsmul n x</code>.</li>
<li>If this is not possible, add <code>(reorder := ...)</code> argument to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</li>
</ul>
</li>
</ul><p>If neither of these solutions work, and <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> is unable to automatically generate the
additive version of a declaration, manually write and prove the additive version.
Often the proof of a lemma/theorem can just be the multiplicative version of the lemma applied to
<code>multiplicative G</code>.
Afterwards, apply the attribute manually:</p><pre><code>attribute [to_additive foo_add_bar] foo_bar
</code></pre><p>This will allow future uses of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> to recognize that
<code>foo_bar</code> should be replaced with <code>foo_add_bar</code>.</p><h3 class="markdown-heading" id="Handling-of-hidden-definitions">Handling of hidden definitions <a class="hover-link" href="#Handling-of-hidden-definitions">#</a></h3><p>Before transporting the “main” declaration <code>src</code>, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> first
scans its type and value for names starting with <code>src</code>, and transports
them. This includes auxiliary definitions like <code>src._match_1</code></p><p>In addition to transporting the “main” declaration, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> transports
its equational lemmas and tags them as equational lemmas for the new declaration.</p><h3 class="markdown-heading" id="Structure-fields-and-constructors">Structure fields and constructors <a class="hover-link" href="#Structure-fields-and-constructors">#</a></h3><p>If <code>src</code> is a structure, then the additive version has to be already written manually.
In this case <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> adds all structure fields to its mapping.</p><h3 class="markdown-heading" id="Name-generation">Name generation <a class="hover-link" href="#Name-generation">#</a></h3><ul>
<li><p>If <code>@[to_additive]</code> is called without a <code>name</code> argument, then the
new name is autogenerated.  First, it takes the longest prefix of
the source name that is already known to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>, and replaces
this prefix with its additive counterpart. Second, it takes the last
part of the name (i.e., after the last dot), and replaces common
name parts (“mul”, “one”, “inv”, “prod”) with their additive versions.</p>
</li>
<li><p>[todo] Namespaces can be transformed using <code>map_namespace</code>. For example:</p>
<pre><code>run_cmd to_additive.map_namespace `QuotientGroup `QuotientAddGroup
</code></pre>
<p>Later uses of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> on declarations in the <code>QuotientGroup</code>
namespace will be created in the <code>QuotientAddGroup</code> namespaces.</p>
</li>
<li><p>If <code>@[to_additive]</code> is called with a <code>name</code> argument <code>new_name</code>
/without a dot/, then <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> updates the prefix as described
above, then replaces the last part of the name with <code>new_name</code>.</p>
</li>
<li><p>If <code>@[to_additive]</code> is called with a <code>name</code> argument
<code>NewNamespace.new_name</code> /with a dot/, then <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> uses this
new name as is.</p>
</li>
</ul><p>As a safety check, in the first case <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> double checks
that the new name differs from the original one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.to_additive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.attrTo_additive?_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L334-L334">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.attrTo_additive?_"><span class="name">ToAdditive</span>.<span class="name">attrTo_additive?_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The attribute <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> can be used to automatically transport theorems
and definitions (but not inductive types and structures) from a multiplicative
theory to an additive theory.</p><p>To use this attribute, just write:</p><pre><code>@[to_additive]
theorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := mul_comm x y
</code></pre><p>This code will generate a theorem named <code>add_comm'</code>. It is also
possible to manually specify the name of the new declaration:</p><pre><code>@[to_additive add_foo]
theorem foo := sorry
</code></pre><p>An existing documentation string will <em>not</em> be automatically used, so if the theorem or definition
has a doc string, a doc string for the additive version should be passed explicitly to
<code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><pre><code>/-- Multiplication is commutative -/
@[to_additive /-- Addition is commutative -/]
theorem mul_comm' {α} [CommSemigroup α] (x y : α) : x * y = y * x := CommSemigroup.mul_comm
</code></pre><p>The transport tries to do the right thing in most cases using several
heuristics described below.  However, in some cases it fails, and
requires manual intervention.</p><p>Use the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.existing">existing</a></code> syntax to use an existing additive declaration, instead of
automatically generating it.</p><p>Use the <code>(reorder := ...)</code> syntax to reorder the arguments in the generated additive declaration.
This is specified using cycle notation. For example <code>(reorder := 1 2, 5 6)</code> swaps the first two
arguments with each other and the fifth and the sixth argument and <code>(reorder := 3 4 5)</code> will move
the fifth argument before the third argument. This is mostly useful to translate declarations using
<code><a href="../../.././Init/Prelude.html#Pow">Pow</a></code> to those using <code><a href="../../.././Init/Prelude.html#SMul">SMul</a></code>.</p><p>Use the <code>(attr := ...)</code> syntax to apply attributes to both the multiplicative and the additive
version:</p><pre><code>@[to_additive (attr := simp)] <a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> mul_one' {G : Type*} [Group G] (x : G) : x * 1 = x := mul_one x
</code></pre><p>For <code>simps</code> this also ensures that some generated lemmas are added to the additive dictionary.
<code>@[to_additive (attr := to_additive)]</code> is a special case, where the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>
attribute is added to the generated lemma only, to additivize it again.
This is useful for lemmas about <code><a href="../../.././Init/Prelude.html#Pow">Pow</a></code> to generate both lemmas about <code><a href="../../.././Init/Prelude.html#SMul">SMul</a></code> and <code>VAdd</code>. Example:</p><pre><code>@[to_additive (attr := <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> VAdd_lemma, simp) SMul_lemma]
<a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> Pow_lemma ... :=
</code></pre><p>In the above example, the <code>simp</code> is added to all 3 lemmas. All other options to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>
(like the generated name or <code>(reorder := ...)</code>) are not passed down,
and can be given manually to each individual <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> call.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>The transport process generally works by taking all the names of
identifiers appearing in the name, type, and body of a declaration and
creating a new declaration by mapping those names to additive versions
using a simple string-based dictionary and also using all declarations
that have previously been labeled with <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>. The dictionary is <code><a href="../../.././Mathlib/Tactic/ToAdditive/GuessName.html#ToAdditive.nameDict">ToAdditive.nameDict</a></code>
and can be found in the <code>Tactic.ToAdditive.GuessName</code> file. If you introduce a new name which
should be translated by <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> you should add the translation to this dictionary.</p><p>In the <code>mul_comm'</code> example above, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> maps:</p><ul>
<li><code>mul_comm'</code> to <code>add_comm'</code>,</li>
<li><code>CommSemigroup</code> to <code>AddCommSemigroup</code>,</li>
<li><code>x * y</code> to <code>x + y</code> and <code>y * x</code> to <code>y + x</code>, and</li>
<li><code>CommSemigroup.mul_comm'</code> to <code>AddCommSemigroup.add_comm'</code>.</li>
</ul><h3 class="markdown-heading" id="Heuristics">Heuristics <a class="hover-link" href="#Heuristics">#</a></h3><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> uses heuristics to determine whether a particular identifier has to be
mapped to its additive version. The basic heuristic is</p><ul>
<li>Only map an identifier to its additive version if its first argument doesn't
contain any unapplied identifiers.</li>
</ul><p>Examples:</p><ul>
<li><code>@Mul.mul <a href="../../.././Init/Prelude.html#Nat">Nat</a> n m</code> (i.e. <code>(n * m : Nat)</code>) will not change to <code>+</code>, since its
first argument is <code><a href="../../.././Init/Prelude.html#Nat">Nat</a></code>, an identifier not applied to any arguments.</li>
<li><code>@Mul.mul (α × β) x y</code> will change to <code>+</code>. It's first argument contains only the identifier
<code><a href="../../.././Init/Prelude.html#Prod">Prod</a></code>, but this is applied to arguments, <code>α</code> and <code>β</code>.</li>
<li><code>@Mul.mul (α × Int) x y</code> will not change to <code>+</code>, since its first argument contains <code><a href="../../.././Init/Data/Int/Basic.html#Int">Int</a></code>.</li>
</ul><p>The reasoning behind the heuristic is that the first argument is the type which is &quot;additivized&quot;,
and this usually doesn't make sense if this is on a fixed type.</p><p>There are some exceptions to this heuristic:</p><ul>
<li>Identifiers that have the <code>@[to_additive]</code> attribute are ignored.
For example, multiplication in <code>↥Semigroup</code> is replaced by addition in <code>↥AddSemigroup</code>.
You can turn this behavior off by <em>also</em> adding the <code>@[to_additive_dont_translate]</code> attribute.</li>
<li>If an identifier <code>d</code> has attribute <code>@[to_additive (relevant_arg := n)]</code> then the argument
in position <code>n</code> is checked for a fixed type, instead of checking the first argument.
<code>@[to_additive]</code> will automatically add the attribute <code>(relevant_arg := n)</code> to a
declaration when the first argument has no multiplicative type-class, but argument <code>n</code> does.</li>
<li>If an identifier has attribute <code>@[to_additive_ignore_args n1 n2 ...]</code> then all the arguments in
positions <code>n1</code>, <code>n2</code>, ... will not be checked for unapplied identifiers (start counting from 1).
For example, <code>ContMDiffMap</code> has attribute <code>@[to_additive_ignore_args 21]</code>, which means
that its 21st argument <code>(n : WithTop ℕ)</code> can contain <code>ℕ</code>
(usually in the form <code>Top.top ℕ ...</code>) and still be additivized.
So <code>@Mul.mul (C^∞⟮I, N; I', G⟯) _ f g</code> will be additivized.</li>
</ul><h3 class="markdown-heading" id="Troubleshooting">Troubleshooting <a class="hover-link" href="#Troubleshooting">#</a></h3><p>If <code>@[to_additive]</code> fails because the additive declaration raises a type mismatch, there are
various things you can try.
The first thing to do is to figure out what <code>@[to_additive]</code> did wrong by looking at the type
mismatch error.</p><ul>
<li>Option 1: The most common case is that it didn't additivize a declaration that should be
additivized. This happened because the heuristic applied, and the first argument contains a
fixed type, like <code>ℕ</code> or <code>ℝ</code>. However, the heuristic misfires on some other declarations.
Solutions:<ul>
<li>First figure out what the fixed type is in the first argument of the declaration that didn't
get additivized. Note that this fixed type can occur in implicit arguments. If manually finding
it is hard, you can run <code>set_option trace.to_additive_detail true</code> and search the output for the
fragment &quot;contains the fixed type&quot; to find what the fixed type is.</li>
<li>If the fixed type has an additive counterpart (like <code>↥Semigroup</code>), give it the <code>@[to_additive]</code>
attribute.</li>
<li>If the fixed type has nothing to do with algebraic operations (like <code>TopCat</code>), add the attribute
<code>@[to_additive self]</code> to the fixed type <code>Foo</code>.</li>
<li>If the fixed type occurs inside the <code>k</code>-th argument of a declaration <code>d</code>, and the
<code>k</code>-th argument is not connected to the multiplicative structure on <code>d</code>, consider adding
attribute <code>[to_additive_ignore_args k]</code> to <code>d</code>.
Example: <code>ContMDiffMap</code> ignores the argument <code>(n : WithTop ℕ)</code></li>
<li>If none of the arguments have a multiplicative structure, then the heuristic should not apply at
all. This can be achieved by setting <code>relevant_arg</code> out of bounds, e.g. <code>(relevant_arg := 100)</code>.</li>
</ul>
</li>
<li>Option 2: It additivized a declaration <code>d</code> that should remain multiplicative. Solution:<ul>
<li>Make sure the first argument of <code>d</code> is a type with a multiplicative structure. If not, can you
reorder the (implicit) arguments of <code>d</code> so that the first argument becomes a type with a
multiplicative structure (and not some indexing type)?
The reason is that <code>@[to_additive]</code> doesn't additivize declarations if their first argument
contains fixed types like <code>ℕ</code> or <code>ℝ</code>. See section Heuristics.
If the first argument is not the argument with a multiplicative type-class, <code>@[to_additive]</code>
should have automatically added the attribute <code>(relevant_arg := ...)</code> to the declaration.
You can test this by running the following (where <code>d</code> is the full name of the declaration):<pre><code>  open <a href="../../.././Lean.html">Lean</a> in run_cmd logInfo m!&quot;{ToAdditive.relevantArgAttr.find? (← getEnv) `d}&quot;
</code></pre>
The expected output is <code>n</code> where the <code>n</code>-th (0-indexed) argument of <code>d</code> is a type (family)
with a multiplicative structure on it. <code>none</code> means <code>0</code>.
If you get a different output (or a failure), you could add the attribute
<code>@[to_additive (relevant_arg := n)]</code> manually, where <code>n</code> is an (1-indexed) argument with a
multiplicative structure.</li>
</ul>
</li>
<li>Option 3: Arguments / universe levels are incorrectly ordered in the additive version.
This likely only happens when the multiplicative declaration involves <code>pow</code>/<code>^</code>. Solutions:<ul>
<li>Ensure that the order of arguments of all relevant declarations are the same for the
multiplicative and additive version. This might mean that arguments have an &quot;unnatural&quot; order
(e.g. <code>Monoid.npow n x</code> corresponds to <code>x ^ n</code>, but it is convenient that <code>Monoid.npow</code> has this
argument order, since it matches <code>AddMonoid.nsmul n x</code>.</li>
<li>If this is not possible, add <code>(reorder := ...)</code> argument to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</li>
</ul>
</li>
</ul><p>If neither of these solutions work, and <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> is unable to automatically generate the
additive version of a declaration, manually write and prove the additive version.
Often the proof of a lemma/theorem can just be the multiplicative version of the lemma applied to
<code>multiplicative G</code>.
Afterwards, apply the attribute manually:</p><pre><code>attribute [to_additive foo_add_bar] foo_bar
</code></pre><p>This will allow future uses of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> to recognize that
<code>foo_bar</code> should be replaced with <code>foo_add_bar</code>.</p><h3 class="markdown-heading" id="Handling-of-hidden-definitions">Handling of hidden definitions <a class="hover-link" href="#Handling-of-hidden-definitions">#</a></h3><p>Before transporting the “main” declaration <code>src</code>, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> first
scans its type and value for names starting with <code>src</code>, and transports
them. This includes auxiliary definitions like <code>src._match_1</code></p><p>In addition to transporting the “main” declaration, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> transports
its equational lemmas and tags them as equational lemmas for the new declaration.</p><h3 class="markdown-heading" id="Structure-fields-and-constructors">Structure fields and constructors <a class="hover-link" href="#Structure-fields-and-constructors">#</a></h3><p>If <code>src</code> is a structure, then the additive version has to be already written manually.
In this case <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> adds all structure fields to its mapping.</p><h3 class="markdown-heading" id="Name-generation">Name generation <a class="hover-link" href="#Name-generation">#</a></h3><ul>
<li><p>If <code>@[to_additive]</code> is called without a <code>name</code> argument, then the
new name is autogenerated.  First, it takes the longest prefix of
the source name that is already known to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>, and replaces
this prefix with its additive counterpart. Second, it takes the last
part of the name (i.e., after the last dot), and replaces common
name parts (“mul”, “one”, “inv”, “prod”) with their additive versions.</p>
</li>
<li><p>[todo] Namespaces can be transformed using <code>map_namespace</code>. For example:</p>
<pre><code>run_cmd to_additive.map_namespace `QuotientGroup `QuotientAddGroup
</code></pre>
<p>Later uses of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> on declarations in the <code>QuotientGroup</code>
namespace will be created in the <code>QuotientAddGroup</code> namespaces.</p>
</li>
<li><p>If <code>@[to_additive]</code> is called with a <code>name</code> argument <code>new_name</code>
/without a dot/, then <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> updates the prefix as described
above, then replaces the last part of the name with <code>new_name</code>.</p>
</li>
<li><p>If <code>@[to_additive]</code> is called with a <code>name</code> argument
<code>NewNamespace.new_name</code> /with a dot/, then <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> uses this
new name as is.</p>
</li>
</ul><p>As a safety check, in the first case <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> double checks
that the new name differs from the original one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.attrTo_additive?_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.linter.existingAttributeWarning"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L339-L344">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.existingAttributeWarning"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">existingAttributeWarning</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Linter, mostly used by <code>@[to_additive]</code>, that checks that the source declaration doesn't have
certain attributes</p></div></div><div class="decl" id="ToAdditive.linter.toAdditiveGenerateName"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L346-L350">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveGenerateName"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">toAdditiveGenerateName</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Linter to check that the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> attribute is not given manually</p></div></div><div class="decl" id="ToAdditive.linter.toAdditiveExisting"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L352-L357">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveExisting"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">toAdditiveExisting</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Linter to check whether the user correctly specified that the additive declaration already
exists</p></div></div><div class="decl" id="ToAdditive.linter.toAdditiveRelevantArg"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L359-L362">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.linter.toAdditiveRelevantArg"><span class="name">ToAdditive</span>.<span class="name">linter</span>.<span class="name">toAdditiveRelevantArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Linter to check that the <code>relevant_arg</code> attribute is not given manually</p></div></div><div class="decl" id="ToAdditive.ignoreArgsAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L365-L375">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ignoreArgsAttr"><span class="name">ToAdditive</span>.<span class="name">ignoreArgsAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span></div></div><p>An attribute that tells <code>@[to_additive]</code> that certain arguments of this definition are not
involved when using <code>@[to_additive]</code>.
This helps the heuristic of <code>@[to_additive]</code> by also transforming definitions if <code>ℕ</code> or another
fixed type occurs as one of these arguments.</p></div></div><div class="decl" id="ToAdditive.reorderAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L377-L380">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderAttr"><span class="name">ToAdditive</span>.<span class="name">reorderAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>)</span></span></div></div><p>An extension that stores all the declarations that need their arguments reordered when
applying <code>@[to_additive]</code>. It is applied using the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> (reorder := ...)</code> syntax.</p></div></div><div class="decl" id="ToAdditive.relevantArgAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L382-L393">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.relevantArgAttr"><span class="name">ToAdditive</span>.<span class="name">relevantArgAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>This attribute is deprecated. Use <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> (relevant_arg := ...)</code> instead.</p></div></div><div class="decl" id="ToAdditive.dontTranslateAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L395-L403">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.dontTranslateAttr"><span class="name">ToAdditive</span>.<span class="name">dontTranslateAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>The <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_dont_translate">to_additive_dont_translate</a></code> attribute, used to specify types that should be translated by
<code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>, but its operations should remain multiplicative.</p><p>Usage notes:</p><ul>
<li>Apply this together with the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> attribute.</li>
<li>The name generation of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> is not aware that the operations on this type should not be
translated, so you generally have to specify the name itself, if the name should remain
multiplicative.</li>
</ul></div></div><div class="decl" id="ToAdditive.changeNumeralAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L405-L414">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeralAttr"><span class="name">ToAdditive</span>.<span class="name">changeNumeralAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span></div></div><p>An attribute that stores all the declarations that deal with numeric literals on variable types.</p><p>Numeral literals occur in expressions without type information, so in order to decide whether <code>1</code>
needs to be changed to <code>0</code>, the context around the numeral is relevant.
Most numerals will be in an <code><a href="../../.././Init/Prelude.html#OfNat.ofNat">OfNat.ofNat</a></code> application, though tactics can add numeral literals
inside arbitrary functions. By default we assume that we do not change numerals, unless it is
in a function application with the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive_change_numeral">to_additive_change_numeral</a></code> attribute.</p><p><code>@[to_additive_change_numeral n₁ ...]</code> should be added to all functions that take one or more
numerals as argument that should be changed if <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest">additiveTest</a></code> succeeds on the first argument,
i.e. when the numeral is only translated if the first argument is a variable
(or consists of variables).
The arguments <code>n₁ ...</code> are the positions of the numeral arguments (starting counting from 1).</p></div></div><div class="decl" id="ToAdditive.translations"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L416-L417">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.translations"><span class="name">ToAdditive</span>.<span class="name">translations</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Maps multiplicative names to their additive counterparts.</p></div></div><div class="decl" id="ToAdditive.findTranslation?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L419-L421">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTranslation?"><span class="name">ToAdditive</span>.<span class="name">findTranslation?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></span></div></div><p>Get the multiplicative → additive translation for the given name.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTranslation?">ToAdditive.findTranslation?</a> <span class="fn">env</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Lean/EnvExtension.html#Lean.SimplePersistentEnvExtension.getState">Lean.SimplePersistentEnvExtension.getState</a> <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.translations">ToAdditive.translations</a> <span class="fn">env</span>)</span>.<a href="../../.././Lean/Data/NameMap/Basic.html#Lean.NameMap.find?">find?</a></span></li></ul></details><details id="instances-for-list-ToAdditive.findTranslation?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.findPrefixTranslation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L423-L427">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findPrefixTranslation"><span class="name">ToAdditive</span>.<span class="name">findPrefixTranslation</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">nm</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Get the multiplicative → additive translation for the given name,
falling back to translating a prefix of the name if the full name can't be translated.
This allows translating automatically generated declarations such as <code>IsRegular.casesOn</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findPrefixTranslation">ToAdditive.findPrefixTranslation</a> <span class="fn">env</span> <span class="fn">nm</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Lean/Expr/Basic.html#Lean.Name.mapPrefix">Lean.Name.mapPrefix</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTranslation?">ToAdditive.findTranslation?</a> <span class="fn">env</span>)</span> <span class="fn">nm</span></span></li></ul></details><details id="instances-for-list-ToAdditive.findPrefixTranslation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.insertTranslation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L429-L438">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.insertTranslation"><span class="name">ToAdditive</span>.<span class="name">insertTranslation</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">failIfExists</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add a (multiplicative → additive) name translation to the translations map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.insertTranslation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.ArgInfo"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L440-L445">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo"><span class="name">ToAdditive</span>.<span class="name">ArgInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a></code> stores information about how a constant should be translated.</p><ul class="structure_fields" id="ToAdditive.ArgInfo.mk"><li id="ToAdditive.ArgInfo.reorder" class="structure_field"><div class="structure_field_info">reorder : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span></div><div class="structure_field_doc"><p>The arguments that should be reordered by <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>, using cycle notation.</p></div></li><li id="ToAdditive.ArgInfo.relevantArg" class="structure_field"><div class="structure_field_info">relevantArg : <a href="../../.././Init/Prelude.html#Nat">ℕ</a></div><div class="structure_field_doc"><p>The argument used to determine whether this constant should be translated.</p></div></li></ul><details id="instances-for-list-ToAdditive.ArgInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.insertTranslationAndInfo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L447-L456">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.insertTranslationAndInfo"><span class="name">ToAdditive</span>.<span class="name">insertTranslationAndInfo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">argInfo</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">failIfExists</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add a name translation to the translations map and add the <code>argInfo</code> information to <code>src</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.insertTranslationAndInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L458-L495">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config"><span class="name">ToAdditive</span>.<span class="name">Config</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a></code> is the type of the arguments that can be provided to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><ul class="structure_fields" id="ToAdditive.Config.mk"><li id="ToAdditive.Config.trace" class="structure_field"><div class="structure_field_info">trace : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>View the trace of the to_additive procedure.
Equivalent to <code>set_option trace.<a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a> true</code>.</p></div></li><li id="ToAdditive.Config.tgt" class="structure_field"><div class="structure_field_info">tgt : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div><div class="structure_field_doc"><p>The name of the target (the additive declaration).</p></div></li><li id="ToAdditive.Config.doc" class="structure_field"><div class="structure_field_info">doc : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#String">String</a></span></div><div class="structure_field_doc"><p>An optional doc string.</p></div></li><li id="ToAdditive.Config.allowAutoName" class="structure_field"><div class="structure_field_info">allowAutoName : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.allowAutoName">allowAutoName</a></code> is <code>false</code> (default) then
<code>@[to_additive]</code> will check whether the given name can be auto-generated.</p></div></li><li id="ToAdditive.Config.reorder" class="structure_field"><div class="structure_field_info">reorder : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span></div><div class="structure_field_doc"><p>The arguments that should be reordered by <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>, using cycle notation.</p></div></li><li id="ToAdditive.Config.relevantArg?" class="structure_field"><div class="structure_field_info">relevantArg? : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div><div class="structure_field_doc"><p>The argument used to determine whether this constant should be translated.</p></div></li><li id="ToAdditive.Config.attrs" class="structure_field"><div class="structure_field_info">attrs : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div><div class="structure_field_doc"><p>The attributes which we want to give to both the multiplicative and additive versions.
For <code>simps</code> this will also add generated lemmas to the translation dictionary.</p></div></li><li id="ToAdditive.Config.dontTranslate" class="structure_field"><div class="structure_field_info">dontTranslate : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Meta/Defs.html#Lean.Syntax.Ident">Lean.Ident</a></span></div><div class="structure_field_doc"><p>A list of type variables that should not be translated by <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p></div></li><li id="ToAdditive.Config.ref" class="structure_field"><div class="structure_field_info">ref : <a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div><div class="structure_field_doc"><p>The <code>Syntax</code> element corresponding to the original multiplicative declaration
(or the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> attribute if it is added later),
which we need for adding definition ranges.</p></div></li><li id="ToAdditive.Config.existing" class="structure_field"><div class="structure_field_info">existing : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>An optional flag stating that the additive declaration already exists.
If this flag is wrong about whether the additive declaration exists, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> will
raise a linter error.
Note: the linter will never raise an error for inductive types and structures.</p></div></li><li id="ToAdditive.Config.self" class="structure_field"><div class="structure_field_info">self : <a href="../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>An optional flag stating that the target of the translation is the target itself.
This can be used to reorder arguments, such as in
<code>attribute [to_dual <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.self">self</a> (reorder := 3 4)] <a href="../../.././Init/Prelude.html#LE.le">LE.le</a></code>.
It can also be used to give a hint to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest">additiveTest</a></code>, such as in
<code>attribute [to_additive self] <a href="../../.././Init/Prelude.html#Unit">Unit</a></code>.
If <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.self">self</a> := true</code>, we should also have <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.existing">existing</a> := true</code>.</p></div></li></ul><details id="instances-for-list-ToAdditive.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.instReprConfig"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L495-L495">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.instReprConfig"><span class="name">ToAdditive</span>.<span class="name">instReprConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.instReprConfig">ToAdditive.instReprConfig</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.instReprConfig.repr">ToAdditive.instReprConfig.repr</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="ToAdditive.instReprConfig.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L495-L495">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.instReprConfig.repr"><span class="name">ToAdditive</span>.<span class="name">instReprConfig</span>.<span class="name">repr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <a href="../../.././Init/Data/Format/Basic.html#Std.Format">Std.Format</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.instReprConfig.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.etaExpandN"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L500-L502">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.etaExpandN"><span class="name">ToAdditive</span>.<span class="name">etaExpandN</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Eta expands <code>e</code> at most <code>n</code> times.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.etaExpandN" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.expand"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L504-L540">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.expand"><span class="name">ToAdditive</span>.<span class="name">expand</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code>e.<a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.expand">expand</a></code> eta-expands all expressions that have as head a constant <code>n</code> in <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo.reorder">reorder</a></code>.
They are expanded until they are applied to one more argument than the maximum in <code>reorder.find n</code>.
It also expands all kernel projections that have as head a constant <code>n</code> in <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo.reorder">reorder</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.expand" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.additiveTestUnsafe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L542-L581">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe"><span class="name">ToAdditive</span>.<span class="name">additiveTestUnsafe</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dontTranslate</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> (<a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Core.html#Sum">⊕</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></div></div><p>Implementation function for <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest">additiveTest</a></code>.
Failure means that in that subexpression there is no constant that blocks <code>e</code> from being translated.
We cache previous applications of the function, using an expression cache using ptr equality
to avoid visiting the same subexpression many times. Note that we only need to cache the
expressions without taking the value of <code>inApp</code> into account, since <code>inApp</code> only matters when
the expression is a constant. However, for this reason we have to make sure that we never
cache constant expressions, so that's why the <code>if</code>s in the implementation are in this order.</p><p>Note that this function is still called many times by <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun">applyReplacementFun</a></code>
and we're not remembering the cache between these calls.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe">ToAdditive.additiveTestUnsafe</a> <span class="fn">env</span> <span class="fn">e</span> <span class="fn">dontTranslate</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../.././Init/Control/State.html#StateT.run'">StateT.run'</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe.visit">ToAdditive.additiveTestUnsafe.visit</a> <span class="fn">env</span> <span class="fn">dontTranslate</span> <span class="fn">e</span>)</span> <a href="../../.././Lean/Util/PtrSet.html#Lean.mkPtrSet">Lean.mkPtrSet</a>)</span>.<a href="../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-ToAdditive.additiveTestUnsafe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.additiveTestUnsafe.visit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L554-L580">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTestUnsafe.visit"><span class="name">ToAdditive</span>.<span class="name">additiveTestUnsafe</span>.<span class="name">visit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dontTranslate</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">inApp</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Control/Option.html#OptionT">OptionT</a> <span class="fn">(<a href="../../.././Init/Control/State.html#StateM">StateM</a> <span class="fn">(<a href="../../.././Lean/Util/PtrSet.html#Lean.PtrSet">Lean.PtrSet</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span>)</span> (<a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Core.html#Sum">⊕</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.additiveTestUnsafe.visit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.additiveTest"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L583-L592">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest"><span class="name">ToAdditive</span>.<span class="name">additiveTest</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dontTranslate</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span> := <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> (<a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href="../../.././Init/Core.html#Sum">⊕</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a>)</span></div></div><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest">additiveTest</a> e</code> tests whether the expression <code>e</code> contains a constant
<code>nm</code> that is not applied to any arguments, and such that <code>translations.find?[nm] = none</code>.
This is used in <code>@[to_additive]</code> for deciding which subexpressions to transform: we only transform
constants if <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest">additiveTest</a></code> applied to their relevant argument returns <code>true</code>.
This means we will replace expression applied to e.g. <code>α</code> or <code>α × β</code>, but not when applied to
e.g. <code>ℕ</code> or <code>ℝ × α</code>.
We ignore all arguments specified by the <code>ignore</code> <code>NameMap</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest">ToAdditive.additiveTest</a> <span class="fn">env</span> <span class="fn">e</span> <span class="fn">dontTranslate</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additiveTest.unsafe_impl_3">ToAdditive.additiveTest.unsafe_impl_3</a> <span class="fn">env</span> <span class="fn">e</span> <span class="fn">dontTranslate</span></span></li></ul></details><details id="instances-for-list-ToAdditive.additiveTest" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.swapFirstTwo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L594-L598">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#List.swapFirstTwo"><span class="name">List</span>.<span class="name">swapFirstTwo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></div></div><p>Swap the first two elements of a list</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a>.<a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#List.swapFirstTwo">swapFirstTwo</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">x_1</span><a href="../../.././Init/Prelude.html#List.cons">]</a>.<a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#List.swapFirstTwo">swapFirstTwo</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">x_1</span><a href="../../.././Init/Prelude.html#List.cons">]</a></li><li class="equation"><span class="fn">(<span class="fn">x_1</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>).<a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#List.swapFirstTwo">swapFirstTwo</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">x_1</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></li></ul></details><details id="instances-for-list-List.swapFirstTwo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.changeNumeral"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L600-L604">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeral"><span class="name">ToAdditive</span>.<span class="name">changeNumeral</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Change the numeral <code>nat_lit 1</code> to the numeral <code>nat_lit 0</code>.
Leave all other expressions unchanged.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeral">ToAdditive.changeNumeral</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.Expr.lit">Lean.Expr.lit</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.Literal.natVal">Lean.Literal.natVal</a> <span class="fn">1</span>)</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Expr.html#Lean.mkRawNatLit">Lean.mkRawNatLit</a> <span class="fn">0</span></span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.changeNumeral">ToAdditive.changeNumeral</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x✝</span></li></ul></details><details id="instances-for-list-ToAdditive.changeNumeral" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.applyReplacementFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L606-L695">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun"><span class="name">ToAdditive</span>.<span class="name">applyReplacementFun</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dontTranslate</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span> := <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun">applyReplacementFun</a> e</code> replaces the expression <code>e</code> with its additive counterpart.
It translates each identifier (inductive type, defined function etc) in an expression, unless</p><ul>
<li>The identifier occurs in an application with first argument <code>arg</code>; and</li>
<li><code>test arg</code> is false.
However, if <code>f</code> is in the dictionary <code>relevant</code>, then the argument <code>relevant.find f</code>
is tested, instead of the first argument.</li>
</ul><p>It will also reorder arguments of certain functions, using <code>reorderFn</code>:
e.g. <code>g x₁ x₂ x₃ ... xₙ</code> becomes <code>g x₂ x₁ x₃ ... xₙ</code> if <code>reorderFn g = some [1]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.applyReplacementFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.applyReplacementFun.aux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L628-L695">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun.aux"><span class="name">ToAdditive</span>.<span class="name">applyReplacementFun</span>.<span class="name">aux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">dontTranslate</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">trace</span> : <a href="../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Implementation of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun">applyReplacementFun</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.applyReplacementFun.aux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.renameBinderNames"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L697-L701">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.renameBinderNames"><span class="name">ToAdditive</span>.<span class="name">renameBinderNames</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Rename binder names in pi type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.renameBinderNames">ToAdditive.renameBinderNames</a> <span class="fn">src</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">src</span>.<a href="../../.././Mathlib/Lean/Expr/Basic.html#Lean.Expr.mapForallBinderNames">mapForallBinderNames</a></span> <span class="fn">fun (<span class="fn">x</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>) =&gt;
    <span class="fn">match <span class="fn">x</span> with
    | <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">s</span></span> =&gt; <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../.././Init/Prelude.html#Lean.Name.str">str</a></span> <span class="fn">(<a href="../../.././Mathlib/Tactic/ToAdditive/GuessName.html#ToAdditive.guessName">ToAdditive.guessName</a> <span class="fn">s</span>)</span></span>
    | <span class="fn">n</span> =&gt; <span class="fn">n</span></span></span></span></li></ul></details><details id="instances-for-list-ToAdditive.renameBinderNames" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.reorderForall"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L703-L713">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderForall"><span class="name">ToAdditive</span>.<span class="name">reorderForall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">reorder</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">src</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Reorder pi-binders. See doc of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderAttr">reorderAttr</a></code> for the interpretation of the argument</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.reorderForall" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.reorderLambda"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L715-L728">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderLambda"><span class="name">ToAdditive</span>.<span class="name">reorderLambda</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">reorder</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">src</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Reorder lambda-binders. See doc of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.reorderAttr">reorderAttr</a></code> for the interpretation of the argument</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.reorderLambda" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.applyReplacementForall"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L730-L745">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementForall"><span class="name">ToAdditive</span>.<span class="name">applyReplacementForall</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">dontTranslate</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Run <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun">applyReplacementFun</a></code> on an expression <code>∀ x₁ .. xₙ, e</code>,
making sure not to translate type-classes on <code>xᵢ</code> if <code>i</code> is in <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.dontTranslate">dontTranslate</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.applyReplacementForall" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.applyReplacementLambda"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L747-L762">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementLambda"><span class="name">ToAdditive</span>.<span class="name">applyReplacementLambda</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">dontTranslate</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Run <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyReplacementFun">applyReplacementFun</a></code> on an expression <code>fun x₁ .. xₙ ↦ e</code>,
making sure not to translate type-classes on <code>xᵢ</code> if <code>i</code> is in <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.dontTranslate">dontTranslate</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.applyReplacementLambda" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.declUnfoldAuxLemmas"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L764-L774">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.declUnfoldAuxLemmas"><span class="name">ToAdditive</span>.<span class="name">declUnfoldAuxLemmas</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">decl</span> : <a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">Lean.ConstantInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">Lean.ConstantInfo</a></span></div></div><p>Unfold auxlemmas in the type and value.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.declUnfoldAuxLemmas" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.getDontTranslates"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L776-L788">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.getDontTranslates"><span class="name">ToAdditive</span>.<span class="name">getDontTranslates</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">given</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Meta/Defs.html#Lean.Syntax.Ident">Lean.Ident</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">type</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span></div></div><p>Given a list of variable local identifiers that shouldn't be translated,
determine the arguments that shouldn't be translated.</p><p>TODO: Currently, this function doesn't deduce any <code>dont_translate</code> types from <code>type</code>.
In the future we would like that the presence of <code>MonoidAlgebra k G</code> will automatically
flag <code>k</code> as a type to not be translated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.getDontTranslates" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.updateDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L790-L804">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.updateDecl"><span class="name">ToAdditive</span>.<span class="name">updateDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">srcDecl</span> : <a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">Lean.ConstantInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">reorder</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dont</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Meta/Defs.html#Lean.Syntax.Ident">Lean.Ident</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">Lean.ConstantInfo</a></span></div></div><p>Run applyReplacementFun on the given <code>srcDecl</code> to make a new declaration with name <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.tgt">tgt</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.updateDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.declAbstractNestedProofs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L806-L812">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.declAbstractNestedProofs"><span class="name">ToAdditive</span>.<span class="name">declAbstractNestedProofs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">decl</span> : <a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">Lean.ConstantInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Declaration.html#Lean.ConstantInfo">Lean.ConstantInfo</a></span></div></div><p>Abstracts the nested proofs in the value of <code>decl</code> if it is a def.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.declAbstractNestedProofs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.findTargetName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L814-L830">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findTargetName"><span class="name">ToAdditive</span>.<span class="name">findTargetName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">env</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">pre </span><span class="fn">tgt_pre</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Find the target name of <code>pre</code> and all created auxiliary declarations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.findTargetName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.findAuxDecls"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L832-L848">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findAuxDecls"><span class="name">ToAdditive</span>.<span class="name">findAuxDecls</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pre</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Data/NameMap/Basic.html#Lean.NameSet">Lean.NameSet</a></div></div><p>Returns a <code>NameSet</code> of all auxiliary constants in <code>e</code> that might have been generated
when adding <code>pre</code> to the environment.
Examples include <code>pre.match_5</code> and
<code>_private.Mathlib.MyFile.someOtherNamespace.someOtherDeclaration._eq_2</code>.
The last two examples may or may not have been generated by this declaration.
The last example may or may not be the equation lemma of a declaration with the <code>@[to_additive]</code>
attribute. We will only translate it if it has the <code>@[to_additive]</code> attribute.</p><p>Note that this function would return <code>proof_nnn</code> aux lemmas if
we hadn't unfolded them in <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.declUnfoldAuxLemmas">declUnfoldAuxLemmas</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findAuxDecls">ToAdditive.findAuxDecls</a> <span class="fn">e</span> <span class="fn">pre</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../../.././Lean/Util/FoldConsts.html#Lean.Expr.foldConsts">foldConsts</a></span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> <span class="fn">fun (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>) (<span class="fn">l</span> : <a href="../../.././Lean/Data/NameMap/Basic.html#Lean.NameSet">Lean.NameSet</a>) =&gt;
    <a href="../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">n</span>.<a href="../../.././Lean/Data/Name.html#Lean.Name.getPrefix">getPrefix</a></span> <a href="../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">pre</span> <a href="../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../.././Lean/PrivateName.html#Lean.isPrivateName">Lean.isPrivateName</a> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">n</span>.<a href="../../.././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Lean/Data/NameMap/Basic.html#Lean.NameSet.insert">insert</a></span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-ToAdditive.findAuxDecls" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.transformDeclAux"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L850-L955">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.transformDeclAux"><span class="name">ToAdditive</span>.<span class="name">transformDeclAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pre </span><span class="fn">tgt_pre</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></div><p>Transform the declaration <code>src</code> and all declarations <code>pre._proof_i</code> occurring in <code>src</code>
using the transforms dictionary.</p><p><code>replace_all</code>, <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.trace">trace</a></code>, <code>ignore</code> and <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo.reorder">reorder</a></code> are configuration options.</p><p><code>pre</code> is the declaration that got the <code>@[to_additive]</code> attribute and <code>tgt_pre</code> is the target of this
declaration.</p></div></div><div class="decl" id="ToAdditive.copyInstanceAttribute"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L957-L964">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.copyInstanceAttribute"><span class="name">ToAdditive</span>.<span class="name">copyInstanceAttribute</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Copy the instance attribute in a <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code></p><p>[todo] it seems not to work when the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> is added as an attribute later.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.copyInstanceAttribute" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.warnAttrCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L966-L978">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnAttrCore"><span class="name">ToAdditive</span>.<span class="name">warnAttrCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">thisAttr </span><span class="fn">attrName </span><span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Warn the user when the multiplicative declaration has an attribute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.warnAttrCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.warnAttr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L980-L983">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnAttr"><span class="name">ToAdditive</span>.<span class="name">warnAttr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">attr</span> : <span class="fn"><a href="../../.././Lean/ScopedEnvExtension.html#Lean.SimpleScopedEnvExtension">Lean.SimpleScopedEnvExtension</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">thisAttr </span><span class="fn">attrName </span><span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Warn the user when the multiplicative declaration has a simple scoped attribute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnAttr">ToAdditive.warnAttr</a> <span class="fn">stx</span> <span class="fn">attr</span> <span class="fn">f</span> <span class="fn">thisAttr</span> <span class="fn">attrName</span> <span class="fn">src</span> <span class="fn">tgt</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnAttrCore">ToAdditive.warnAttrCore</a> <span class="fn">stx</span> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../.././Lean/Environment.html#Lean.Environment">Lean.Environment</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../.././Lean/ScopedEnvExtension.html#Lean.ScopedEnvExtension.getState">Lean.ScopedEnvExtension.getState</a> <span class="fn">attr</span> <span class="fn">x</span>)</span></span>)</span> <span class="fn">thisAttr</span>
    <span class="fn">attrName</span> <span class="fn">src</span> <span class="fn">tgt</span></span></li></ul></details><details id="instances-for-list-ToAdditive.warnAttr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.warnParametricAttr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L985-L988">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.warnParametricAttr"><span class="name">ToAdditive</span>.<span class="name">warnParametricAttr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">attr</span> : <span class="fn"><a href="../../.././Lean/Attributes.html#Lean.ParametricAttribute">Lean.ParametricAttribute</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">thisAttr </span><span class="fn">attrName </span><span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Warn the user when the multiplicative declaration has a parametric attribute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.warnParametricAttr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.additivizeLemmas"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L990-L1003">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additivizeLemmas"><span class="name">ToAdditive</span>.<span class="name">additivizeLemmas</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../.././foundational_types.html">Type</a> → <a href="../../.././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Lean/Exception.html#Lean.MonadError">Lean.MonadError</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">names</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">argInfo</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">desc</span> : <a href="../../.././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><span class="fn">m</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.additivizeLemmas">additivizeLemmas</a> names argInfo desc t</code> runs <code>t</code> on all elements of <code>names</code>
and adds translations between the generated lemmas (the output of <code>t</code>).
<code>names</code> must be non-empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.additivizeLemmas" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.findMultiplicativeArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1005-L1028">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.findMultiplicativeArg"><span class="name">ToAdditive</span>.<span class="name">findMultiplicativeArg</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">nm</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>Find the argument of <code>nm</code> that appears in the first multiplicative (type-class) argument.
Returns 1 if there are no types with a multiplicative class as arguments.
E.g. <code>Prod.instGroup</code> returns 1, and <code>Pi.instOne</code> returns 2.
Note: we only consider the relevant argument (<code>(relevant_arg := ...)</code>) of each type-class.
E.g. <code>[Pow A N]</code> is a multiplicative type-class on <code>A</code>, not on <code>N</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.findMultiplicativeArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.targetName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1030-L1056">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.targetName"><span class="name">ToAdditive</span>.<span class="name">targetName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">src</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Return the provided target name or autogenerate one if one was not provided.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.targetName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.proceedFieldsAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1058-L1067">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.proceedFieldsAux"><span class="name">ToAdditive</span>.<span class="name">proceedFieldsAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">argInfo</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>if <code>f src = #[a_1, ..., a_n]</code> and <code>f <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.tgt">tgt</a> = #[b_1, ... b_n]</code> then <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.proceedFieldsAux">proceedFieldsAux</a> src <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.tgt">tgt</a> f</code>
will insert translations from <code>a_i</code> to <code>b_i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.proceedFieldsAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.proceedFields"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1069-L1091">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.proceedFields"><span class="name">ToAdditive</span>.<span class="name">proceedFields</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">argInfo</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add the structure fields of <code>src</code> to the translations dictionary
so that future uses of <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> will map them to the corresponding <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.tgt">tgt</a></code> fields.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.proceedFields" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.elabToAdditive"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1093-L1172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.elabToAdditive"><span class="name">ToAdditive</span>.<span class="name">elabToAdditive</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a></span></span></div></div><p>Elaboration of the configuration options for <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.elabToAdditive" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.applyAttributes"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1175-L1238">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.applyAttributes"><span class="name">ToAdditive</span>.<span class="name">applyAttributes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rawAttrs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">thisAttr </span><span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">argInfo</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span></div></div><p>Apply attributes to the multiplicative and additive declarations.</p></div></div><div class="decl" id="ToAdditive.copyMetaData"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1240-L1256">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.copyMetaData"><span class="name">ToAdditive</span>.<span class="name">copyMetaData</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">argInfo</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span></div></div><p>Copies equation lemmas and attributes from <code>src</code> to <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config.tgt">tgt</a></code></p></div></div><div class="decl" id="ToAdditive.transformDecl"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1258-L1266">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.transformDecl"><span class="name">ToAdditive</span>.<span class="name">transformDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">argInfo</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo">ArgInfo</a> := <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo.mk">{</a> <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.ArgInfo.mk">}</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span></div></div><p>Make a new copy of a declaration, replacing fragments of the names of identifiers in the type and
the body using the <code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.translations">translations</a></code> dictionary.
This is used to implement <code>@[to_additive]</code>.</p></div></div><div class="decl" id="ToAdditive.checkExistingType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1268-L1289">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.checkExistingType"><span class="name">ToAdditive</span>.<span class="name">checkExistingType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src </span><span class="fn">tgt</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">reorder</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dont</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Meta/Defs.html#Lean.Syntax.Ident">Lean.Ident</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Verify that the type of given <code>srcDecl</code> translates to that of <code>tgtDecl</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-ToAdditive.checkExistingType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="ToAdditive.addToAdditiveAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/ToAdditive/Frontend.lean#L1291-L1341">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.addToAdditiveAttr"><span class="name">ToAdditive</span>.<span class="name">addToAdditiveAttr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">src</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cfg</span> : <a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.Config">Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">kind</span> : <a href="../../.././Lean/Attributes.html#Lean.AttributeKind">Lean.AttributeKind</a> := <a href="../../.././Lean/Attributes.html#Lean.AttributeKind.global">Lean.AttributeKind.global</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Attributes.html#Lean.AttrM">Lean.AttrM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span></div></div><p><code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.addToAdditiveAttr">addToAdditiveAttr</a> src cfg</code> adds a <code>@[to_additive]</code> attribute to <code>src</code> with configuration <code>cfg</code>.
See the attribute implementation for more details.
It returns an array with names of additive declarations (usually 1, but more if there are nested
<code><a href="../../.././Mathlib/Tactic/ToAdditive/Frontend.html#ToAdditive.to_additive">to_additive</a></code> calls.</p></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.IntervalCases</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.IntervalCases";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Control/Basic.html">Mathlib.Control.Basic</a></li><li><a href="../.././Mathlib/Tactic/FinCases.html">Mathlib.Tactic.FinCases</a></li><li><a href="../.././Mathlib/Tactic/NormNum.html">Mathlib.Tactic.NormNum</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.IntervalCases" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">IntervalCasesSubgoal</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.Bound"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Bound</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.Bound.asLower"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Bound</span>.<span class="name">asLower</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.Bound.asUpper"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Bound</span>.<span class="name">asUpper</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.parseBound"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">parseBound</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.Methods"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_not_lt_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_lt_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_not_lt_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_lt_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_not_le_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_le_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_not_le_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_le_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_lt_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_lt_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_lt_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_lt_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_le_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_le_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.of_le_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_le_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.Methods.getBound"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span>.<span class="name">getBound</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.le_of_not_le_of_le"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">le_of_not_le_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span>.<span class="name">inconsistentBounds</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.Methods.bisect"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span>.<span class="name">bisect</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.natMethods"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">natMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Int.add_one_le_of_not_le"><span class="name">Int</span>.<span class="name">add_one_le_of_not_le</span></a></div><div class="nav_link"><a class="break_within" href="#Int.le_sub_one_of_not_le"><span class="name">Int</span>.<span class="name">le_sub_one_of_not_le</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.intMethods"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">intMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.IntervalCases.intervalCases"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">intervalCases</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.intervalCases"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">intervalCases</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Case-bash-on-variables-in-finite-intervals">Case bash on variables in finite intervals <a class="hover-link" href="#Case-bash-on-variables-in-finite-intervals">#</a></h1><p>This file provides the tactic <code>interval_cases</code>. <code>interval_cases n</code> will:</p><ol>
<li>inspect hypotheses looking for lower and upper bounds of the form <code>a ≤ n</code> or <code>a &lt; n</code> and <code>n &lt; b</code>
or <code>n ≤ b</code>, including the bound <code>0 ≤ n</code> for <code>n : ℕ</code> automatically.</li>
<li>call <code>fin_cases</code> on the synthesised hypothesis <code>n ∈ <a href="../.././Mathlib/Order/Interval/Set/Defs.html#Set.Ico">Set.Ico</a> a b</code>,
assuming an appropriate <code><a href="../.././Mathlib/Data/Fintype/Defs.html#Fintype">Fintype</a></code> instance can be found for the type of <code>n</code>.</li>
</ol><p>Currently, <code>n</code> must be of type <code>ℕ</code> or <code>ℤ</code> (TODO: generalize).</p><p>You can also explicitly specify a lower and upper bound to use, as <code>interval_cases using hl hu</code>,
where the hypotheses should be of the form <code>hl : a ≤ n</code> and <code>hu : n &lt; b</code>. In that case,
<code>interval_cases</code> calls <code>fin_cases</code> on the resulting hypothesis <code>h : n ∈ <a href="../.././Mathlib/Order/Interval/Set/Defs.html#Set.Ico">Set.Ico</a> a b</code>.</p></div><div class="decl" id="Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L32-L40">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">IntervalCasesSubgoal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The result of <code>interval_cases</code> is a list of goals,
one for each integer value between the bounds.</p><ul class="structure_fields" id="Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.mk"><li id="Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs" class="structure_field"><div class="structure_field_info">rhs : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The target expression, a numeral in the input type</p></div></li><li id="Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.value" class="structure_field"><div class="structure_field_info">value : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></div><div class="structure_field_doc"><p>The numeric value of the target expression</p></div></li><li id="Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal" class="structure_field"><div class="structure_field_info">goal : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></div><div class="structure_field_doc"><p>The new subgoal, of the form <code>⊢ x = <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs">rhs</a> → tgt</code></p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.Bound"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L42-L54">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Bound</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>A <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a></code> represents the result of analyzing a lower or upper bound expression.
If <code>e</code> is the scrutinee expression, then a lower bound expression like <code>3 &lt; e</code>
is normalized to <code>¬e ≤ 3</code> and represented as <code>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.lt">lt</a> 3</code>, and an upper bound expression
like <code>e ≤ 5</code> is represented as <code>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le">le</a> 5</code>.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.IntervalCases.Bound.lt">lt<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
 : <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a><div class="inductive_ctor_doc"><p>A strictly less-than lower bound <code>n ≱ e</code> or upper bound <code>e ≱ n</code>. (<code>interval_cases</code> uses
less-equal exclusively, so less-than bounds are actually written as not-less-equal
with flipped arguments.)</p></div></li><li class="constructor" id="Mathlib.Tactic.IntervalCases.Bound.le">le<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
 : <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a><div class="inductive_ctor_doc"><p>A less-than-or-equal lower bound <code>n ≤ e</code> or upper bound <code>e ≤ n</code>.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.IntervalCases.Bound" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.Bound.asLower"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L56-L63">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asLower"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Bound</span>.<span class="name">asLower</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a> → <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div></div><p>Assuming <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a></code> represents a lower bound, this returns the (inclusive)
least integer value which is allowed. So <code>3 ≤ e</code> means the lower bound is 3 and
<code>3 &lt; e</code> means the lower bound is <code>4</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.lt">Mathlib.Tactic.IntervalCases.Bound.lt</a> <span class="fn">n</span>)</span>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asLower">asLower</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le">Mathlib.Tactic.IntervalCases.Bound.le</a> <span class="fn">n</span>)</span>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asLower">asLower</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.Bound.asLower" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.Bound.asUpper"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L65-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asUpper"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Bound</span>.<span class="name">asUpper</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a> → <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div></div><p>Assuming <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a></code> represents an upper bound, this returns the (inclusive)
greatest integer value which is allowed. So <code>e ≤ 3</code> means the lower bound is 3 and
<code>e &lt; 3</code> means the upper bound is <code>2</code>. Note that in the case of <code>e &lt; 0</code> on <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code>
the upper bound is <code>-1</code>, which is not representable as a <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code>;
this is why we have to treat the <code>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.lt">lt</a></code> and <code>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le">le</a></code> cases separately instead of normalizing
everything to <code>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le">le</a></code> bounds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.lt">Mathlib.Tactic.IntervalCases.Bound.lt</a> <span class="fn">n</span>)</span>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asUpper">asUpper</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.le">Mathlib.Tactic.IntervalCases.Bound.le</a> <span class="fn">n</span>)</span>.<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound.asUpper">asUpper</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.Bound.asUpper" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.parseBound"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L77-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.parseBound"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">parseBound</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ty</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></div></div><p>Given a type <code>ty</code> (the type of a hypothesis in the context or a provided expression),
attempt to parse it as an inequality, and return <code>(a, b, strict, positive)</code>, where
<code>positive</code> means it is a negated inequality and <code>strict</code> means it is a strict inequality
(<code>a &lt; b</code> or <code>a ≱ b</code>). <code>a</code> is always the lesser argument and <code>b</code> the greater one.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.parseBound" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.Methods"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L98-L120">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>A &quot;typeclass&quot; (not actually a class) of methods for the type-specific handling of
<code>interval_cases</code>. To add support for a new type, you have to implement this interface and add
a dispatch case for it in <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intervalCases">intervalCases</a></code>.</p><ul class="structure_fields" id="Mathlib.Tactic.IntervalCases.Methods.mk"><li id="Mathlib.Tactic.IntervalCases.Methods.initLB" class="structure_field"><div class="structure_field_info">initLB<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
 : <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div><div class="structure_field_doc"><p>Given <code>e</code>, construct <code>(bound, n, p)</code> where <code>p</code> is a proof of <code>n ≤ e</code> or <code>n &lt; e</code>
(characterized by <code>bound</code>), or <code>failure</code> if the type is not lower-bounded.</p></div></li><li id="Mathlib.Tactic.IntervalCases.Methods.initUB" class="structure_field"><div class="structure_field_info">initUB<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
 : <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div><div class="structure_field_doc"><p>Given <code>e</code>, construct <code>(bound, n, p)</code> where <code>p</code> is a proof of <code>e ≤ n</code> or <code>e &lt; n</code>
(characterized by <code>bound</code>), or <code>failure</code> if the type is not upper-bounded.</p></div></li><li id="Mathlib.Tactic.IntervalCases.Methods.proveLE" class="structure_field"><div class="structure_field_info">proveLE : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></span></div><div class="structure_field_doc"><p>Given <code>a, b</code>, prove <code>a ≤ b</code> or fail.</p></div></li><li id="Mathlib.Tactic.IntervalCases.Methods.proveLT" class="structure_field"><div class="structure_field_info">proveLT : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></span></div><div class="structure_field_doc"><p>Given <code>a, b</code>, prove <code>a ≱ b</code> or fail.</p></div></li><li id="Mathlib.Tactic.IntervalCases.Methods.roundUp" class="structure_field"><div class="structure_field_info">roundUp : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></span></div><div class="structure_field_doc"><p>Given <code>a, b, a', p</code> where <code>p</code> proves <code>a ≱ b</code> and <code>a' := a+1</code>, prove <code>a' ≤ b</code>.</p></div></li><li id="Mathlib.Tactic.IntervalCases.Methods.roundDown" class="structure_field"><div class="structure_field_info">roundDown : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></span></div><div class="structure_field_doc"><p>Given <code>a, b, b', p</code> where <code>p</code> proves <code>a ≱ b</code> and <code>b' := b-1</code>, prove <code>a ≤ b'</code>.</p></div></li><li id="Mathlib.Tactic.IntervalCases.Methods.eval" class="structure_field"><div class="structure_field_info">eval : <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span></div><div class="structure_field_doc"><p>Given <code>e</code>, return <code>(z, n, p)</code> where <code>p : e = n</code> and <code>n</code> is a numeral
appropriate for the type denoting the integer <code>z</code>.</p></div></li><li id="Mathlib.Tactic.IntervalCases.Methods.mkNumeral" class="structure_field"><div class="structure_field_info">mkNumeral : <span class="fn"><a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></span></div><div class="structure_field_doc"><p>Construct the canonical numeral for integer <code>z</code>, or fail if <code>z</code> is out of range.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.IntervalCases.Methods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_not_lt_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L124-L124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_lt_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a'</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_not_lt_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L125-L125">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_lt_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_lt_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">b'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b'</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_not_le_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L126-L126">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_le_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a'</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_not_le_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L127-L127">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_not_le_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_not_le_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">b'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b'</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_lt_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L128-L128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_lt_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a'</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_lt_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L129-L129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_lt_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_lt_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">b'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b'</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_le_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L130-L130">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_le_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.of_le_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L131-L131">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.of_le_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">of_le_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">b'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b'</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.Methods.getBound"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L133-L158">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.getBound"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span>.<span class="name">getBound</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods">Methods</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">pf</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lb</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div></div><p>Given a proof <code>pf</code>, attempts to parse it as an upper (<code>lb = false</code>) or lower (<code>lb = true</code>)
bound on <code>n</code>. If successful, it returns <code>(bound, n, pf')</code> where <code>n</code> is a numeral and
<code>pf'</code> proves <code>n ≤ e</code> or <code>n ≱ e</code> (as described by <code>bound</code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.Methods.getBound" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.le_of_not_le_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L160-L162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.le_of_not_le_of_le"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">le_of_not_le_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hi </span><span class="fn">n </span><span class="fn">lo</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h1</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">hi</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h2</span> : <span class="fn">hi</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">lo</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">n</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">lo</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L164-L182">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span>.<span class="name">inconsistentBounds</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods">Methods</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">z1 </span><span class="fn">z2</span> : <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e1 </span><span class="fn">e2 </span><span class="fn">p1 </span><span class="fn">p2 </span><span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Given <code>(z1, e1, p1)</code> a lower bound on <code>e</code> and <code>(z2, e2, p2)</code> an upper bound on <code>e</code>,
such that the distance between the bounds is negative, returns a proof of <code><a href="../.././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.Methods.bisect"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L184-L211">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods.bisect"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">Methods</span>.<span class="name">bisect</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods">Methods</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cases</span> : <span class="fn"><a href="../.././Init/Data/Array/Subarray.html#Subarray">Subarray</a> <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal">IntervalCasesSubgoal</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">z1 </span><span class="fn">z2</span> : <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Bound">Bound</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e1 </span><span class="fn">e2 </span><span class="fn">p1 </span><span class="fn">p2 </span><span class="fn">e</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given <code>(z1, e1, p1)</code> a lower bound on <code>e</code> and <code>(z2, e2, p2)</code> an upper bound on <code>e</code>, such that the
distance between the bounds matches the number of <code>cases</code> in the subarray (which must be positive),
proves the goal <code>g</code> using the metavariables in the array by recursive bisection.
This is the core of the tactic, producing a case tree of if statements which bottoms out
at the <code>cases</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.natMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L213-L227">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.natMethods"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">natMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods">Methods</a></div></div><p>A <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods">Methods</a></code> implementation for <code>ℕ</code>.
This tells <code>interval_cases</code> how to work on natural numbers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.natMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Int.add_one_le_of_not_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L229-L230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Int.add_one_le_of_not_le"><span class="name">Int</span>.<span class="name">add_one_le_of_not_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Int.le_sub_one_of_not_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L231-L232">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Int.le_sub_one_of_not_le"><span class="name">Int</span>.<span class="name">le_sub_one_of_not_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <a href="../.././Init/Data/Int/Basic.html#Int">ℤ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.intMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L234-L246">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intMethods"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">intMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods">Methods</a></div></div><p>A <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.Methods">Methods</a></code> implementation for <code>ℤ</code>.
This tells <code>interval_cases</code> how to work on integers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.intMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.IntervalCases.intervalCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L248-L316">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intervalCases"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">IntervalCases</span>.<span class="name">intervalCases</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e </span><span class="fn">e'</span> : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lbs </span><span class="fn">ubs</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mustUseBounds</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal">IntervalCasesSubgoal</a>)</span></span></div></div><p><code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.intervalCases">intervalCases</a></code> proves goal <code>g</code> by splitting into cases for each integer between the given bounds.</p><p>Parameters:</p><ul>
<li><code>g</code>: the goal, which can have any type <code>⊢ tgt</code> (it works in both proofs and programs)</li>
<li><code>e</code>: the scrutinee, the expression we are proving is bounded between integers</li>
<li><code>e'</code>: a version of <code>e</code> used for error messages. (This is used by the <code>interval_cases</code> frontend
tactic because it uses a fresh variable for <code>e</code>, so it is more helpful to show the
pre-generalized expression in error messages.)</li>
<li><code>lbs</code>: A list of candidate lower bound expressions.
The tactic will automatically pick the best lower bound it can find from the list.</li>
<li><code>ubs</code>: A list of candidate upper bound expressions.
The tactic will automatically pick the best upper bound it can find from the list.</li>
<li><code>mustUseBounds</code>: If true, the tactic will fail if it is unable to parse any of the
given <code>ubs</code> or <code>lbs</code> into bounds. If false (the default), these will be silently skipped
and an error message is only produced if we could not find any bounds (including those supplied
by the type itself, e.g. if we are working over <code><a href="../.././Init/Prelude.html#Nat">Nat</a></code> or <code><a href="../.././Init/Prelude.html#Fin">Fin</a> n</code>).</li>
</ul><p>Returns an array of <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal">IntervalCasesSubgoal</a></code>, one per subgoal. A subgoal has the following fields:</p><ul>
<li><code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs">rhs</a></code>: the numeral expression for this case</li>
<li><code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.value">value</a></code>: the integral value of <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs">rhs</a></code></li>
<li><code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal">goal</a></code>: the subgoal of type <code>⊢ e = <a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.rhs">rhs</a> → tgt</code></li>
</ul><p>Note that this tactic does not perform any substitution or introduction steps -
all subgoals are in the same context as <code><a href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal.goal">goal</a></code> itself.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.IntervalCases.intervalCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.intervalCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/IntervalCases.lean#L322-L344">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.intervalCases"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">intervalCases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>interval_cases n</code> searches for upper and lower bounds on a variable <code>n</code>,
and if bounds are found,
splits into separate cases for each possible value of <code>n</code>.</p><p>As an example, in</p><pre><code>example (n : ℕ) (w₁ : n ≥ 3) (w₂ : n &lt; 5) : n = 3 ∨ n = 4 := by
  interval_cases n
  all_goals simp
</code></pre><p>after <code>interval_cases n</code>, the goals are <code>3 = 3 ∨ 3 = 4</code> and <code>4 = 3 ∨ 4 = 4</code>.</p><p>You can also explicitly specify a lower and upper bound to use,
as <code>interval_cases using hl, hu</code>.
The hypotheses should be in the form <code>hl : a ≤ n</code> and <code>hu : n &lt; b</code>,
in which case <code>interval_cases</code> calls <code>fin_cases</code> on the resulting fact <code>n ∈ <a href="../.././Mathlib/Order/Interval/Set/Defs.html#Set.Ico">Set.Ico</a> a b</code>.</p><p>You can specify a name <code>h</code> for the new hypothesis,
as <code>interval_cases h : n</code> or <code>interval_cases h : n using hl, hu</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.intervalCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
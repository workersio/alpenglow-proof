<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Sat.FromLRAT</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Sat.FromLRAT";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">FromLRAT</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Tactic/ByContra.html">Mathlib.Tactic.ByContra</a></li><li><a href="../../.././Mathlib/Algebra/Group/Nat/Defs.html">Mathlib.Algebra.Group.Nat.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Sat.FromLRAT" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Sat.Literal"><span class="name">Sat</span>.<span class="name">Literal</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Literal.ofInt"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">ofInt</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Literal.negate"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">negate</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.instToExprLiteral"><span class="name">Sat</span>.<span class="name">instToExprLiteral</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Clause"><span class="name">Sat</span>.<span class="name">Clause</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Clause.nil"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">nil</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Clause.cons"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">cons</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla"><span class="name">Sat</span>.<span class="name">Fmla</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.one"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">one</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.and"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">and</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.subsumes"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.subsumes_self"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes_self</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.subsumes_left"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes_left</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.subsumes_right"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes_right</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation"><span class="name">Sat</span>.<span class="name">Valuation</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation.neg"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">neg</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation.satisfies"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">satisfies</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation.satisfies_fmla"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">satisfies_fmla</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.proof"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">proof</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.proof_of_subsumes"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">proof_of_subsumes</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation.by_cases"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">by_cases</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation.implies"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">implies</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation.mk"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Valuation.mk_implies"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">mk_implies</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.reify"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">reify</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.refute"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">refute</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.reify_or"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">reify_or</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Clause.reify"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Fmla.reify_one"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">reify_one</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Literal.reify"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">reify</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Clause.reify_and"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify_and</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Clause.reify_zero"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Clause.reify_one"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify_one</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Literal.reify_pos"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">reify_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Sat.Literal.reify_neg"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">reify_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.Clause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Clause</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildClause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildClause</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildConj"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildConj</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildClauses"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildClauses</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.LClause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">LClause</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildProofStep"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildProofStep</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.LRATStep"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">LRATStep</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildProof</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify.mkPS"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">mkPS</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify.v"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">v</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify.reifyFmla"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyFmla</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify.reifyClause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyClause</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify.reifyClause1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyClause1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify.reifyLiteral"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyLiteral</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.buildReify.reifyVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyVar</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.Parser.parseNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.Parser.parseInt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseInt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.Parser.parseInts"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseInts</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.Parser.parseNats"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseNats</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.Parser.parseDimacs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseDimacs</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.Parser.parseLRAT"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseLRAT</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.fromLRATAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">fromLRATAux</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.fromLRAT"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">fromLRAT</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.commandLrat_proof_Example____"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">commandLrat_proof_Example____</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Sat.termFrom_lrat___"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">termFrom_lrat___</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="lrat-proof-command"><code>lrat_proof</code> command <a class="hover-link" href="#lrat-proof-command">#</a></h1><p>Defines a macro for producing SAT proofs from CNF / LRAT files.
These files are commonly used in the SAT community for writing proofs.</p><p>Most SAT solvers support export to <a href="https://arxiv.org/abs/1610.06229">DRAT</a> format,
but this format can be expensive to reconstruct because it requires recomputing all
unit propagation steps. The <a href="https://arxiv.org/abs/1612.02353">LRAT</a> format solves this
issue by attaching a proof to the deduction of each new clause.
(The L in LRAT stands for Linear time verification.)
There are several verified checkers for the LRAT format, and the program implemented here
makes it possible to use the lean kernel as an LRAT checker as well and expose the results
as a standard propositional theorem.</p><p>The input to the <code>lrat_proof</code> command is the name of the theorem to define,
and the statement (written in CNF format) and the proof (in LRAT format).
For example:</p><pre><code>lrat_proof foo
  &quot;p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0&quot;
  &quot;5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0&quot;
</code></pre><p>produces a theorem:</p><pre><code>foo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1
</code></pre><ul>
<li>You can see the theorem statement by hovering over the word <code>foo</code>.</li>
<li>You can use the <code>example</code> keyword in place of <code>foo</code> to avoid generating a theorem.</li>
<li>You can use the <code>include_str</code> macro in place of the two strings
to load CNF / LRAT files from disk.</li>
</ul></div><div class="decl" id="Sat.Literal"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L48-L52">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal"><span class="name">Sat</span>.<span class="name">Literal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A literal is a positive or negative occurrence of an atomic propositional variable.
Note that unlike DIMACS, 0 is a valid variable index.</p><ul class="constructors"><li class="constructor" id="Sat.Literal.pos">pos : <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a></span></li><li class="constructor" id="Sat.Literal.neg">neg : <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a></span></li></ul><details id="instances-for-list-Sat.Literal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Literal.ofInt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L54-L57">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.ofInt"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">ofInt</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a></div></div><p>Construct a literal. Positive numbers are translated to positive literals,
and negative numbers become negative literals. The input is assumed to be nonzero.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.ofInt">Sat.Literal.ofInt</a> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">0</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">Sat.Literal.neg</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">i</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>).<a href="../../.././Init/Data/Int/Basic.html#Int.toNat">toNat</a></span></span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos">Sat.Literal.pos</a> <span class="fn">(<span class="fn">i</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>).<a href="../../.././Init/Data/Int/Basic.html#Int.toNat">toNat</a></span></span></li></ul></details><details id="instances-for-list-Sat.Literal.ofInt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Literal.negate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L59-L62">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">negate</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a> → <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a></span></div></div><p>Swap the polarity of a literal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos">Sat.Literal.pos</a> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate">negate</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">Sat.Literal.neg</a> <span class="fn">i</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">Sat.Literal.neg</a> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate">negate</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos">Sat.Literal.pos</a> <span class="fn">i</span></span></li></ul></details><details id="instances-for-list-Sat.Literal.negate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.instToExprLiteral"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L64-L68">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.instToExprLiteral"><span class="name">Sat</span>.<span class="name">instToExprLiteral</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/ToExpr.html#Lean.ToExpr">Lean.ToExpr</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Sat.Clause"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L70-L71">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause"><span class="name">Sat</span>.<span class="name">Clause</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A clause is a list of literals, thought of as a disjunction like <code>a ∨ b ∨ ¬c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Sat.Clause</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Sat.Literal</a></span></li></ul></details><details id="instances-for-list-Sat.Clause" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Clause.nil"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L73-L74">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">nil</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a></div></div><p>The empty clause</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil">Sat.Clause.nil</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></li></ul></details><details id="instances-for-list-Sat.Clause.nil" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Clause.cons"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L76-L77">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">cons</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a> → <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a> → <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a></span></span></div></div><p>Append a literal to a clause.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons">Sat.Clause.cons</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.cons">List.cons</a></li></ul></details><details id="instances-for-list-Sat.Clause.cons" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L79-L80">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla"><span class="name">Sat</span>.<span class="name">Fmla</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A formula is a list of clauses, thought of as a conjunction like <code>(a ∨ b) ∧ c ∧ (¬c ∨ ¬d)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Sat.Fmla</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Sat.Clause</a></span></li></ul></details><details id="instances-for-list-Sat.Fmla" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.one"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L82-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">one</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a></div></div><p>A single clause as a formula.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one">Sat.Fmla.one</a> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">c</span><a href="../../.././Init/Prelude.html#List.cons">]</a></li></ul></details><details id="instances-for-list-Sat.Fmla.one" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.and"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L85-L86">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">and</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a></div></div><p>A conjunction of formulas.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">a</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and">and</a></span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">b</span></li></ul></details><details id="instances-for-list-Sat.Fmla.and" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.subsumes"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L88-L91">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f'</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Formula <code>f</code> subsumes <code>f'</code> if all the clauses in <code>f'</code> are in <code>f</code>.
We use this to prove that all clauses in the formula are subsumed by it.</p><ul class="structure_fields" id="Sat.Fmla.subsumes.mk"><li id="Sat.Fmla.subsumes.prop" class="structure_field"><div class="structure_field_info">prop<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>)</span></span>
 : <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f'</span> → <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span></span></div></li></ul><details id="instances-for-list-Sat.Fmla.subsumes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.subsumes_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L93-L93">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_self"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes_self</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes">subsumes</a></span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Sat.Fmla.subsumes_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L94-L95">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_left"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes_left</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f₁ </span><span class="fn">f₂</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes">subsumes</a></span> <span class="fn">(<span class="fn"><span class="fn">f₁</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and">and</a></span> <span class="fn">f₂</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes">subsumes</a></span> <span class="fn">f₁</span></span></div></div></div></div><div class="decl" id="Sat.Fmla.subsumes_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L96-L97">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes_right"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">subsumes_right</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">f₁ </span><span class="fn">f₂</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes">subsumes</a></span> <span class="fn">(<span class="fn"><span class="fn">f₁</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and">and</a></span> <span class="fn">f₂</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes">subsumes</a></span> <span class="fn">f₂</span></span></div></div></div></div><div class="decl" id="Sat.Valuation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L99-L100">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation"><span class="name">Sat</span>.<span class="name">Valuation</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A valuation is an assignment of values to all the propositional variables.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Sat.Valuation</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <a href="../../.././foundational_types.html">Prop</a>)</span></li></ul></details><details id="instances-for-list-Sat.Valuation" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Valuation.neg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L102-L105">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">neg</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p><code>v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> lit</code> asserts that literal <code>lit</code> is falsified in the valuation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg">neg</a></span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos">Sat.Literal.pos</a> <span class="fn">i</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">v</span> <span class="fn">i</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg">neg</a></span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">Sat.Literal.neg</a> <span class="fn">i</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">v</span> <span class="fn">i</span></span></li></ul></details><details id="instances-for-list-Sat.Valuation.neg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Valuation.satisfies"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L107-L113">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">satisfies</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p><code>v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies">satisfies</a> c</code> asserts that clause <code>c</code> satisfied by the valuation.
It is written in a negative way: A clause like <code>a ∨ ¬b ∨ c</code> is rewritten as
<code>¬a → b → ¬c → <a href="../../.././Init/Prelude.html#False">False</a></code>, so we are asserting that it is not the case that
all literals in the clause are falsified.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies">satisfies</a></span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#False">False</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies">satisfies</a></span> (<span class="fn">l</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">c</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg">neg</a></span> <span class="fn">l</span></span> → <span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies">satisfies</a></span> <span class="fn">c</span></span>)</span></li></ul></details><details id="instances-for-list-Sat.Valuation.satisfies" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Valuation.satisfies_fmla"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L115-L118">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">satisfies_fmla</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla">satisfies_fmla</a> f</code> asserts that formula <code>f</code> is satisfied by the valuation.
A formula is satisfied if all clauses in it are satisfied.</p><ul class="structure_fields" id="Sat.Valuation.satisfies_fmla.mk"><li id="Sat.Valuation.satisfies_fmla.prop" class="structure_field"><div class="structure_field_info">prop<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>)</span></span>
 : <span class="fn"><span class="fn">c</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">f</span> → <span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies">satisfies</a></span> <span class="fn">c</span></span></span></div></li></ul><details id="instances-for-list-Sat.Valuation.satisfies_fmla" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.proof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L120-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">proof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>f.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> c</code> asserts that <code>c</code> is derivable from <code>f</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a></span> <span class="fn">c</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ (<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Sat.Valuation</a>), <span class="fn"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla">satisfies_fmla</a></span> <span class="fn">f</span></span> → <span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies">satisfies</a></span> <span class="fn">c</span></span></span></span></li></ul></details><details id="instances-for-list-Sat.Fmla.proof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.proof_of_subsumes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L124-L127">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof_of_subsumes"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">proof_of_subsumes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes">subsumes</a></span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one">one</a> <span class="fn">c</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a></span> <span class="fn">c</span></span></div></div><p>If <code>f</code> subsumes <code>c</code> (i.e. <code>c ∈ f</code>), then <code>f.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> c</code>.</p></div></div><div class="decl" id="Sat.Valuation.by_cases"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L129-L142">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.by_cases"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">by_cases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg">neg</a></span> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate">negate</a></span></span> → <a href="../../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg">neg</a></span> <span class="fn">l</span></span> → <a href="../../.././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#False">False</a></div></div><p>The core unit-propagation step.</p><p>We have a local context of assumptions <code>¬l'</code> (sometimes called an assignment)
and we wish to add <code>¬l</code> to the context, that is, we want to prove <code>l</code> is also falsified.
This is because there is a clause <code>a ∨ b ∨ ¬l</code> in the global context
such that all literals in the clause are falsified except for <code>¬l</code>;
so in the context <code>h₁</code> where we suppose that <code>¬l</code> is falsified,
the clause itself is falsified so we can prove <code><a href="../../.././Init/Prelude.html#False">False</a></code>.
We continue the proof in <code>h₂</code>, with the assumption that <code>l</code> is falsified.</p></div></div><div class="decl" id="Sat.Valuation.implies"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L144-L148">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">implies</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././foundational_types.html">Prop</a></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <a href="../../.././foundational_types.html">Prop</a></span></span></div></div><p><code>v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a> p [a, b, c] 0</code> definitionally unfolds to <code>(v 0 ↔ a) → (v 1 ↔ b) → (v 2 ↔ c) → p</code>.
This is used to introduce assumptions about the first <code>n</code> values of <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a></code> during reification.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a></span> <span class="fn">p</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">p</span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a></span> <span class="fn">p</span> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>) <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">((<span class="fn"><span class="fn">v</span> <span class="fn">x✝</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span>) → <span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a></span> <span class="fn">p</span> <span class="fn">as</span> (<span class="fn">x✝</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span>)</span></li></ul></details><details id="instances-for-list-Sat.Valuation.implies" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Valuation.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L150-L155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">mk</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././foundational_types.html">Prop</a></span> → <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a></span></div></div><p><code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk">Valuation.mk</a> [a, b, c]</code> is a valuation which is <code>a</code> at 0, <code>b</code> at 1 and <code>c</code> at 2, and false
everywhere else.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk">Sat.Valuation.mk</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#False">False</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk">Sat.Valuation.mk</a> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>) <span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk">Sat.Valuation.mk</a> (<span class="fn">head</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span>) <span class="fn"><span class="fn">n</span>.<a href="../../.././Init/Prelude.html#Nat.succ">succ</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk">Sat.Valuation.mk</a> <span class="fn">as</span> <span class="fn">n</span></span></li></ul></details><details id="instances-for-list-Sat.Valuation.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Valuation.mk_implies"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L157-L170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk_implies"><span class="name">Sat</span>.<span class="name">Valuation</span>.<span class="name">mk_implies</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">as </span><span class="fn">ps</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">as₁</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">as</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">as₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverseAux">reverseAux</a></span> <span class="fn">ps</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.mk">mk</a> <span class="fn">as</span>)</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a></span> <span class="fn">p</span> <span class="fn">ps</span> <span class="fn"><span class="fn">as₁</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span></span> → <span class="fn">p</span></span></span></div></div><p>The fundamental relationship between <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.subsumes.mk">mk</a></code> and <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a></code>:
<code>(mk ps).<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a> p ps 0</code> is equivalent to <code>p</code>.</p></div></div><div class="decl" id="Sat.Fmla.reify"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L172-L174">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">reify</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Asserts that <code>¬⟦f⟧_v</code> implies <code>p</code>.</p><ul class="structure_fields" id="Sat.Fmla.reify.mk"><li id="Sat.Fmla.reify.prop" class="structure_field"><div class="structure_field_info">prop : <span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla">satisfies_fmla</a></span> <span class="fn">f</span></span> → <span class="fn">p</span></span></div></li></ul><details id="instances-for-list-Sat.Fmla.reify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.refute"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L178-L183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.refute"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">refute</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ps</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a></span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hv</span> : <span class="fn">∀ (<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>), <span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a></span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <span class="fn">v</span> <span class="fn">f</span> <span class="fn">p</span>)</span> <span class="fn">ps</span> <span class="fn">0</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p>If <code>f</code> is unsatisfiable, and every <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a></code> which agrees with <code>ps</code> implies <code>¬⟦f⟧_v → p</code>, then <code>p</code>.
Equivalently, there exists a valuation <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a></code> which agrees with <code>ps</code>,
and every such valuation yields <code>¬⟦f⟧_v</code> because <code>f</code> is unsatisfiable.</p></div></div><div class="decl" id="Sat.Fmla.reify_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L185-L191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_or"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">reify_or</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f₁</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f₂</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla">Fmla</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <span class="fn">v</span> <span class="fn">f₁</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <span class="fn">v</span> <span class="fn">f₂</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <span class="fn">v</span> <span class="fn">(<span class="fn"><span class="fn">f₁</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and">and</a></span> <span class="fn">f₂</span>)</span> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn">b</span>)</span></div></div><p>Negation turns AND into OR, so <code>¬⟦f₁ ∧ f₂⟧_v ≡ ¬⟦f₁⟧_v ∨ ¬⟦f₂⟧_v</code>.</p></div></div><div class="decl" id="Sat.Clause.reify"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L193-L195">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Asserts that <code>¬⟦c⟧_v</code> implies <code>p</code>.</p><ul class="structure_fields" id="Sat.Clause.reify.mk"><li id="Sat.Clause.reify.prop" class="structure_field"><div class="structure_field_info">prop : <span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies">satisfies</a></span> <span class="fn">c</span></span> → <span class="fn">p</span></span></div></li></ul><details id="instances-for-list-Sat.Clause.reify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Fmla.reify_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L197-L200">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify_one"><span class="name">Sat</span>.<span class="name">Fmla</span>.<span class="name">reify_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify">Clause.reify</a> <span class="fn">v</span> <span class="fn">c</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <span class="fn">v</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.one">one</a> <span class="fn">c</span>)</span> <span class="fn">a</span></span></div></div><p>Reification of a single clause formula.</p></div></div><div class="decl" id="Sat.Literal.reify"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L202-L204">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">reify</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../.././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>Asserts that <code>¬⟦l⟧_v</code> implies <code>p</code>.</p><ul class="structure_fields" id="Sat.Literal.reify.mk"><li id="Sat.Literal.reify.prop" class="structure_field"><div class="structure_field_info">prop : <span class="fn"><span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.neg">neg</a></span> <span class="fn">l</span></span> → <span class="fn">p</span></span></div></li></ul><details id="instances-for-list-Sat.Literal.reify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Sat.Clause.reify_and"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L206-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_and"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify_and</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify">Literal.reify</a> <span class="fn">v</span> <span class="fn">l</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify">reify</a> <span class="fn">v</span> <span class="fn">c</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify">reify</a> <span class="fn">v</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons">cons</a> <span class="fn">l</span> <span class="fn">c</span>)</span> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn">b</span>)</span></div></div><p>Negation turns OR into AND, so <code>¬⟦l ∨ c⟧_v ≡ ¬⟦l⟧_v ∧ ¬⟦c⟧_v</code>.</p></div></div><div class="decl" id="Sat.Clause.reify_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L212-L213">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_zero"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify">reify</a> <span class="fn">v</span> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil">nil</a> <a href="../../.././Init/Prelude.html#True">True</a></span></div></div><p>The reification of the empty clause is <code><a href="../../.././Init/Prelude.html#True">True</a></code>: <code>¬⟦⊥⟧_v ≡ <a href="../../.././Init/Prelude.html#True">True</a></code>.</p></div></div><div class="decl" id="Sat.Clause.reify_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L215-L218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify_one"><span class="name">Sat</span>.<span class="name">Clause</span>.<span class="name">reify_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal">Literal</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify">Literal.reify</a> <span class="fn">v</span> <span class="fn">l</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.reify">reify</a> <span class="fn">v</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons">cons</a> <span class="fn">l</span> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.nil">nil</a>)</span> <span class="fn">a</span></span></div></div><p>The reification of a singleton clause <code>¬⟦l⟧_v ≡ ¬⟦l⟧_v</code>.</p></div></div><div class="decl" id="Sat.Literal.reify_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L220-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_pos"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">reify_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">v</span> <span class="fn">n</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify">reify</a> <span class="fn">v</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos">pos</a> <span class="fn">n</span>)</span> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div><p>The reification of a positive literal <code>¬⟦a⟧_v ≡ ¬a</code>.</p></div></div><div class="decl" id="Sat.Literal.reify_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L223-L224">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify_neg"><span class="name">Sat</span>.<span class="name">Literal</span>.<span class="name">reify_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation">Valuation</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../../.././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">v</span> <span class="fn">n</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.reify">reify</a> <span class="fn">v</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> <span class="fn">n</span>)</span> <span class="fn">a</span></span></div></div><p>The reification of a negative literal <code>¬⟦¬a⟧_v ≡ a</code>.</p></div></div><div class="decl" id="Mathlib.Tactic.Sat.Clause"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L230-L241">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Clause</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>The representation of a global clause.</p><ul class="structure_fields" id="Mathlib.Tactic.Sat.Clause.mk"><li id="Mathlib.Tactic.Sat.Clause.lits" class="structure_field"><div class="structure_field_info">lits : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div><div class="structure_field_doc"><p>The list of literals as read from the input file</p></div></li><li id="Mathlib.Tactic.Sat.Clause.expr" class="structure_field"><div class="structure_field_info">expr : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The clause expression of type <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a></code></p></div></li><li id="Mathlib.Tactic.Sat.Clause.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>A proof of <code>⊢ ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> c</code>.
Note that we do not use <code>have</code> statements to cache these proofs:
this is literally the proof expression itself. As a result, the proof terms
rely heavily on dag-like sharing of the expression, and printing these proof terms
directly is likely to crash lean for larger examples.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Sat.Clause" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildClause"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L243-L248">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildClause</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">arr</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Construct the clause expression from the input list. For example <code>[1, -2]</code> is translated to
<code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons">Clause.cons</a> (Literal.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.pos">pos</a> 1) (Clause.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause.cons">cons</a> (Literal.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> 2) Clause.nil)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildClause" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildConj"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L250-L257">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildConj"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildConj</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">arr</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">start </span><span class="fn">stop</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Constructs the formula expression from the input CNF, as a balanced tree of <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and">Fmla.and</a></code> nodes.</p></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildClauses"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L259-L277">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildClauses"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildClauses</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">arr</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ctx</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">start </span><span class="fn">stop</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f </span><span class="fn">p</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">accum</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause">Clause</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause">Clause</a></span></div></div><p>Constructs the proofs of <code>⊢ ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> c</code> for each clause <code>c</code> in <code>ctx</code>.
The proofs are stashed in a <code>HashMap</code> keyed on the clause ID.</p></div></div><div class="decl" id="Mathlib.Tactic.Sat.LClause"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L279-L289">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LClause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">LClause</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>A localized clause reference.
It is the same as <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a></code> except that the proof is now a local variable.</p><ul class="structure_fields" id="Mathlib.Tactic.Sat.LClause.mk"><li id="Mathlib.Tactic.Sat.LClause.lits" class="structure_field"><div class="structure_field_info">lits : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div><div class="structure_field_doc"><p>The list of literals as read from the input file</p></div></li><li id="Mathlib.Tactic.Sat.LClause.expr" class="structure_field"><div class="structure_field_info">expr : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div><div class="structure_field_doc"><p>The clause expression of type <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Clause">Clause</a></code></p></div></li><li id="Mathlib.Tactic.Sat.LClause.depth" class="structure_field"><div class="structure_field_info">depth : <a href="../../.././Init/Prelude.html#Nat">ℕ</a></div><div class="structure_field_doc"><p>The bound variable index of the hypothesis asserting <code>⊢ ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> c</code>,
<em>counting from the outside and 1-based</em>. (We use this numbering because we will need to
reference the variable from multiple binder depths.)</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Sat.LClause" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildProofStep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L291-L380">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProofStep"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildProofStep</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">db</span> : <span class="fn"><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Clause">Clause</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ns </span><span class="fn">pf</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ctx </span><span class="fn">clause</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Except">Except</a> <a href="../../.././Init/Prelude.html#String">String</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Construct an individual proof step <code>⊢ ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> c</code>.</p><ul>
<li><code>db</code>: the current global context</li>
<li><code>ns</code>, <code>clause</code>: the new clause</li>
<li><code>pf</code>: the LRAT proof trace</li>
<li><code>ctx</code>: the main formula</li>
</ul><p>The proof has three steps:</p><ol>
<li><p>Introduce local assumptions <code>have h1 : ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> c1 := p1</code> for each clause <code>c1</code>
referenced in the proof. We actually do all the introductions at once,
as in <code>(fun h1 h2 h3 ↦ ...) p1 p2 p3</code>, because we want <code>p_i</code> to not be under any binders
to avoid the cost of <code>instantiate</code> during typechecking and get the benefits of dag-like
sharing in the <code>pi</code> (which are themselves previous proof steps which may be large terms).
The hypotheses are in <code>gctx</code>, keyed on the clause ID.</p>
</li>
<li><p>Unfold <code>⊢ ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> [a, b, c]</code> to
<code>∀ v, v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.satisfies_fmla">satisfies_fmla</a> ctx → v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> a → v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> b → v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> c → <a href="../../.././Init/Prelude.html#False">False</a></code> and <code>intro <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> hv ha hb hc</code>,
storing each <code>ha : v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> a</code> in <code>lctx</code>, keyed on the literal <code>a</code>.</p>
</li>
<li><p>For each LRAT step <code>hc : ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> [x, y]</code>, <code>hc <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> hv : v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> x → v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> y → <a href="../../.././Init/Prelude.html#False">False</a></code>.
We look for a literal that is not falsified in the clause. Since it is a unit propagation
step, there can be at most one such literal.</p>
<ul>
<li>If <code>x</code> is the non-falsified clause, let <code>x'</code> denote the negated literal of <code>x</code>.
Then <code>x'.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate">negate</a></code> reduces to <code>x</code>, so <code>hnx : v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> x'.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate">negate</a> |- hc <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> hv hnx hy : <a href="../../.././Init/Prelude.html#False">False</a></code>,
so we construct the term
<code><a href="../../.././Mathlib/Logic/Basic.html#by_cases">by_cases</a> (fun hnx : v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> x'.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.negate">negate</a> ↦ hc <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> hv hnx hy) (fun hx : v.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Literal.neg">neg</a> x ↦ ...)</code>
and <code>hx</code> is added to the local context.</li>
<li>If all clauses are falsified, then we are done: <code>hc <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> hv hx hy : <a href="../../.././Init/Prelude.html#False">False</a></code>.</li>
</ul>
</li>
</ol><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildProofStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.LRATStep"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L382-L387">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">LRATStep</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>An LRAT step is either an addition or a deletion step.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Sat.LRATStep.add">add<span class="decl_args">
<span class="fn">(<span class="fn">id</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">lits </span><span class="fn">proof</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a></span>)</span></span>
 : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep">LRATStep</a><div class="inductive_ctor_doc"><p>An addition step, with the clause ID, the clause literal list, and the proof trace</p></div></li><li class="constructor" id="Mathlib.Tactic.Sat.LRATStep.del">del<span class="decl_args">
<span class="fn">(<span class="fn">ids</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span>)</span></span>
 : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep">LRATStep</a><div class="inductive_ctor_doc"><p>A (multiple) deletion step, which deletes all the listed clause IDs from the context</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Sat.LRATStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L389-L410">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildProof"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">arr</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ctx </span><span class="fn">ctx'</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">steps</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep">LRATStep</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Build the main proof of <code>⊢ ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> []</code> using the LRAT proof trace.</p><ul>
<li><code>arr</code>: The input CNF</li>
<li><code>ctx</code>: The abbreviated formula, a constant like <code>foo.ctx_1</code></li>
<li><code>ctx'</code>: The definitional expansion of the formula, a tree of <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and">Fmla.and</a></code> nodes</li>
<li><code>steps</code>: The input LRAT proof trace</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L412-L497">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ctx </span><span class="fn">ctx' </span><span class="fn">proof</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">nvars</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Build the type and value of the reified theorem. This rewrites all the SAT definitions
into standard operators on <code>Prop</code>, for example if the formula is <code>[[1, 2], [-1, 2], [-2]]</code> then
this produces a proof of <code>⊢ ∀ a b : Prop, (a ∧ b) ∨ (¬a ∧ b) ∨ ¬b</code>. We use the input <code>nvars</code> to
decide how many quantifiers to use.</p><p>Most of the proof is under <code>2 * nvars + 1</code> quantifiers
<code>a1 .. an : Prop, <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> : Valuation, h1 : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> 0 ↔ a1, ... hn : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> (n-1) ↔ an ⊢ ...</code>, and we do the index
arithmetic by hand.</p><ol>
<li>First, we call <code>reifyFormula ctx'</code> which returns <code>a</code> and <code>pr : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> ctx' a</code></li>
<li>Then we build <code>fun (v : Valuation) (h1 : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> 0 ↔ a1) ... (hn : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> (n-1) ↔ an) ↦ pr</code></li>
<li>We have to lower expression <code>a</code> from step 1 out of the quantifiers by lowering all variable
indices by <code>nvars+1</code>. This is okay because <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a></code> and <code>h1..hn</code> do not appear in <code>a</code>.</li>
<li>We construct the expression <code>ps</code>, which is <code>a1 .. an : Prop ⊢ [a1, ..., an] : <a href="../../.././Init/Prelude.html#List">List</a> Prop</code></li>
<li><code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.refute">refute</a> ctx (hf : ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> []) (fun <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> h1 .. hn ↦ pr) : a</code> forces some definitional unfolding
since <code>fun h1 .. hn ↦ pr</code> should have type <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> (reify <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> ctx a) [a1, ..., an] a</code>,
which involves unfolding <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Valuation.implies">implies</a></code> n times as well as <code>ctx ↦ ctx'</code>.</li>
<li>Finally, we <code>intro a1 ... an</code> so that we have a proof of <code>∀ a1 ... an, a</code>.</li>
</ol><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildReify" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify.mkPS"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L442-L444">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.mkPS"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">mkPS</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cons</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">depth</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify.v"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L452-L452">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">v</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">nvars</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>The <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a></code> variable under the <code>a1 ... an, v, h1 ... hn</code> context</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">Mathlib.Tactic.Sat.buildReify.v</a> <span class="fn">nvars</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Lean/Expr.html#Lean.mkBVar">Lean.mkBVar</a> <span class="fn">nvars</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildReify.v" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify.reifyFmla"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L454-L466">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyFmla"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyFmla</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">nvars</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Returns <code>a</code> and <code>pr : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> f a</code> given a formula <code>f</code></p></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify.reifyClause"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L468-L471">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyClause</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">nvars</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Returns <code>a</code> and <code>pr : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> c a</code> given a clause <code>c</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildReify.reifyClause" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify.reifyClause1"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L473-L481">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyClause1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyClause1</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">nvars</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Returns <code>a</code> and <code>pr : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> c a</code> given a nonempty clause <code>c</code></p></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify.reifyLiteral"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L483-L491">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyLiteral"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyLiteral</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">nvars</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Returns <code>a</code> and <code>pr : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.reify">reify</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> l a</code> given a literal <code>c</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildReify.reifyLiteral" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.buildReify.reifyVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L495-L497">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">buildReify</span>.<span class="name">reifyVar</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">nvars</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></div><p>Returns <code>a</code> and <code>pr : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> n ↔ a</code> given a variable index <code>n</code>.
These are both lookups into the context
<code>(a0 .. a(n-1) : Prop) (v) (h1 : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> 0 ↔ a0) ... (hn : <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.v">v</a> (n-1) ↔ a(n-1))</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.buildReify.reifyVar">Mathlib.Tactic.Sat.buildReify.reifyVar</a> <span class="fn">nvars</span> <span class="fn">v</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><a href="../../.././Lean/Expr.html#Lean.mkBVar">Lean.mkBVar</a> (<span class="fn">2</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">nvars</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Lean/Expr.html#Lean.Expr.rawNatLit?">rawNatLit?</a></span>.<a href="../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span>)</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><a href="../../.././Lean/Expr.html#Lean.mkBVar">Lean.mkBVar</a> (<span class="fn">nvars</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn"><span class="fn">v</span>.<a href="../../.././Lean/Expr.html#Lean.Expr.rawNatLit?">rawNatLit?</a></span>.<a href="../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>)</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.buildReify.reifyVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.Parser.parseNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L503-L504">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser">Std.Internal.Parsec.String.Parser</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>Parse a natural number</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNat">Mathlib.Tactic.Sat.Parser.parseNat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Lean/Data/Json/Parser.html#Lean.Json.Parser.natMaybeZero">Lean.Json.Parser.natMaybeZero</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.Parser.parseNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.Parser.parseInt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L506-L508">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseInt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser">Std.Internal.Parsec.String.Parser</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a></span></div></div><p>Parse an integer</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.Parser.parseInt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.Parser.parseInts"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L510-L514">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseInts"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseInts</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">arr</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a></span> := <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser">Std.Internal.Parsec.String.Parser</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span></div></div><p>Parse a list of integers terminated by 0</p></div></div><div class="decl" id="Mathlib.Tactic.Sat.Parser.parseNats"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L516-L520">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseNats"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseNats</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">arr</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span> := <a href="../../.././Init/Prelude.html#List.toArray">#[</a><a href="../../.././Init/Prelude.html#List.toArray">]</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser">Std.Internal.Parsec.String.Parser</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span></div></div><p>Parse a list of natural numbers terminated by 0</p></div></div><div class="decl" id="Mathlib.Tactic.Sat.Parser.parseDimacs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L522-L531">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseDimacs"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseDimacs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser">Std.Internal.Parsec.String.Parser</a> (<a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Init/Prelude.html#Array">Array</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>)</span></span>)</span></div></div><p>Parse a DIMACS format <code>.cnf</code> file.
This is not very robust; we assume the file has had comments stripped.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.Parser.parseDimacs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.Parser.parseLRAT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L533-L537">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.Parser.parseLRAT"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">Parser</span>.<span class="name">parseLRAT</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Internal/Parsec/String.html#Std.Internal.Parsec.String.Parser">Std.Internal.Parsec.String.Parser</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Array">Array</a> <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.LRATStep">LRATStep</a>)</span></span></div></div><p>Parse an LRAT file into a list of steps.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.Parser.parseLRAT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.fromLRATAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L543-L576">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRATAux"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">fromLRATAux</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cnf </span><span class="fn">lrat</span> : <a href="../../.././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<a href="../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../../.././Init/Prelude.html#Prod">×</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></div></div><p>Core of <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRAT">fromLRAT</a></code>. Constructs the context and main proof definitions,
but not the reification theorem. Returns:</p><ul>
<li><code>nvars</code>: the number of variables specified in the CNF file</li>
<li><code>ctx</code>: The abbreviated formula, a constant like <code>foo.ctx_1</code></li>
<li><code>ctx'</code>: The definitional expansion of the formula, a tree of <code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.and">Fmla.and</a></code> nodes</li>
<li><code><a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a></code>: A proof of <code>ctx.<a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a> []</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.fromLRATAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.fromLRAT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L578-L587">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.fromLRAT"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">fromLRAT</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">cnf </span><span class="fn">lrat</span> : <a href="../../.././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Main entry point. Given strings <code>cnf</code> and <code>lrat</code> with unparsed file data, and a name <code>name</code>,
adds <code>theorem name : type := <a href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Sat.Fmla.proof">proof</a></code> where <code>type</code> is a propositional theorem like
<code>∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1</code>.</p><p>Also creates auxiliaries named <code>name.ctx_1</code> (for the CNF formula)
and <code>name.proof_1</code> (for the LRAT proof), with <code>name</code> itself containing the reification proof.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.fromLRAT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.commandLrat_proof_Example____"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L592-L624">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.commandLrat_proof_Example____"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">commandLrat_proof_Example____</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A macro for producing SAT proofs from CNF / LRAT files.
These files are commonly used in the SAT community for writing proofs.</p><p>The input to the <code>lrat_proof</code> command is the name of the theorem to define,
and the statement (written in CNF format) and the proof (in LRAT format).
For example:</p><pre><code>lrat_proof foo
  &quot;p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0&quot;
  &quot;5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0&quot;
</code></pre><p>produces a theorem:</p><pre><code>foo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1
</code></pre><ul>
<li>You can see the theorem statement by hovering over the word <code>foo</code>.</li>
<li>You can use the <code>example</code> keyword in place of <code>foo</code> to avoid generating a theorem.</li>
<li>You can use the <code>include_str</code> macro in place of the two strings
to load CNF / LRAT files from disk.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.commandLrat_proof_Example____" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Sat.termFrom_lrat___"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Sat/FromLRAT.lean#L644-L674">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Sat/FromLRAT.html#Mathlib.Tactic.Sat.termFrom_lrat___"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Sat</span>.<span class="name">termFrom_lrat___</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>A macro for producing SAT proofs from CNF / LRAT files.
These files are commonly used in the SAT community for writing proofs.</p><p>The input to the <code>from_lrat</code> term syntax is two string expressions with
the statement (written in CNF format) and the proof (in LRAT format).
For example:</p><pre><code>def foo := from_lrat
  &quot;p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0&quot;
  &quot;5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0&quot;
</code></pre><p>produces a theorem:</p><pre><code>foo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1
</code></pre><ul>
<li>You can use this term after <code>have :=</code> or in <code>def foo :=</code> to produce the term
without constraining the type.</li>
<li>You can use it when a specific type is expected, but it currently does not
pay any attention to the shape of the goal and always produces the same theorem,
so you can only use this to do alpha renaming.</li>
<li>You can use the <code>include_str</code> macro in place of the two strings
to load CNF / LRAT files from disk.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Sat.termFrom_lrat___" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>
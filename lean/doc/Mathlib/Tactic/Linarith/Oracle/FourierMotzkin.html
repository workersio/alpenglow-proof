<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Linarith.Oracle.FourierMotzkin</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Linarith.Oracle.FourierMotzkin";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">Oracle</span>.<span class="name">FourierMotzkin</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init.html">Init</a></li><li><a href="../../../.././Batteries/Lean/HashMap.html">Batteries.Lean.HashMap</a></li><li><a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html">Mathlib.Tactic.Linarith.Datatypes</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Linarith.Oracle.FourierMotzkin" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.TreeSet.union"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">union</span></a></div><div class="nav_link"><a class="break_within" href="#Std.TreeSet.instUnion_mathlib"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">instUnion_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Std.TreeSet.sdiff"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">sdiff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.TreeSet.instSDiff_mathlib"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">instSDiff_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.CompSource"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CompSource</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.instInhabitedCompSource.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instInhabitedCompSource</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.instInhabitedCompSource"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instInhabitedCompSource</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.CompSource.flatten"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CompSource</span>.<span class="name">flatten</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.CompSource.toString"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CompSource</span>.<span class="name">toString</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.instToFormatCompSource"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instToFormatCompSource</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PComp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PComp.maybeMinimal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">maybeMinimal</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PComp.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">cmp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PComp.scale"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">scale</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PComp.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PComp.assump"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">assump</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.instToFormatPComp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instToFormatPComp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.instToStringPComp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instToStringPComp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PCompSet"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PCompSet</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.elimVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimVar</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.pelimVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">pelimVar</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.PComp.isContr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">isContr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.elimWithSet"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimWithSet</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.LinarithData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">LinarithData</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.LinarithM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">LinarithM</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.getMaxVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">getMaxVar</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.getPCompSet"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">getPCompSet</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.validate"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">validate</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.update"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">update</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.splitSetByVarSign"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">splitSetByVarSign</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.elimVarM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimVarM</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.elimAllVarsM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimAllVarsM</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.mkLinarithData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">mkLinarithData</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Linarith.CertificateOracle.fourierMotzkin"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CertificateOracle</span>.<span class="name">fourierMotzkin</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-Fourier-Motzkin-elimination-procedure">The Fourier-Motzkin elimination procedure <a class="hover-link" href="#The-Fourier-Motzkin-elimination-procedure">#</a></h1><p>The Fourier-Motzkin procedure is a variable elimination method for linear inequalities.
<a href="https://en.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination">https://en.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination</a></p><p>Given a set of linear inequalities <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a> = {tᵢ Rᵢ 0}</code>,
we aim to eliminate a single variable <code>a</code> from the set.
We partition <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> into <code>comps_pos</code>, <code>comps_neg</code>, and <code>comps_zero</code>,
where <code>comps_pos</code> contains the comparisons <code>tᵢ Rᵢ 0</code> in which
the coefficient of <code>a</code> in <code>tᵢ</code> is positive, and similar.</p><p>For each pair of comparisons <code>tᵢ Rᵢ 0 ∈ comps_pos</code>, <code>tⱼ Rⱼ 0 ∈ comps_neg</code>,
we compute coefficients <code>vᵢ, vⱼ ∈ ℕ</code> such that <code>vᵢ*tᵢ + vⱼ*tⱼ</code> cancels out <code>a</code>.
We collect these sums <code>vᵢ*tᵢ + vⱼ*tⱼ R' 0</code> in a set <code>S</code> and set <code>comps' = S ∪ comps_zero</code>,
a new set of comparisons in which <code>a</code> has been eliminated.</p><p>Theorem: <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> and <code>comps'</code> are equisatisfiable.</p><p>We recursively eliminate all variables from the system. If we derive an empty clause <code>0 &lt; 0</code>,
we conclude that the original system was unsatisfiable.</p></div><div class="decl" id="Std.TreeSet.union"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L39-L44">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.union"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cmp</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t₁ </span><span class="fn">t₂</span> : <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">TreeSet</a> <span class="fn">α</span> <span class="fn">cmp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">TreeSet</a> <span class="fn">α</span> <span class="fn">cmp</span></span></div></div><p><code>O(n₂ * log (n₁ + n₂))</code>. Merges the maps <code>t₁</code> and <code>t₂</code>.
If equal keys exist in both, the key from <code>t₂</code> is preferred.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">t₁</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.union">union</a></span> <span class="fn">t₂</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet.foldl">Std.TreeSet.foldl</a> <a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet.insert">Std.TreeSet.insert</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span></li></ul></details><details id="instances-for-list-Std.TreeSet.union" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.TreeSet.instUnion_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L46-L46">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instUnion_mathlib"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">instUnion_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cmp</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Core.html#Union">Union</a> <span class="fn">(<a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">TreeSet</a> <span class="fn">α</span> <span class="fn">cmp</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instUnion_mathlib">Std.TreeSet.instUnion_mathlib</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Union.mk">{</a> <span class="fn">union</span> := <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.union">Std.TreeSet.union</a> <a href="../../../.././Init/Core.html#Union.mk">}</a></li></ul></details></div></div><div class="decl" id="Std.TreeSet.sdiff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L48-L51">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">sdiff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cmp</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t₁ </span><span class="fn">t₂</span> : <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">TreeSet</a> <span class="fn">α</span> <span class="fn">cmp</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">TreeSet</a> <span class="fn">α</span> <span class="fn">cmp</span></span></div></div><p><code>O(n₁ * (log n₁ + log n₂))</code>. Constructs the set of all elements of <code>t₁</code> that are not in <code>t₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">t₁</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff">sdiff</a></span> <span class="fn">t₂</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet.filter">Std.TreeSet.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn"><span class="fn">t₂</span>.<a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet.contains">contains</a></span> <span class="fn">x</span></span>)</span> <span class="fn">t₁</span></span></li></ul></details><details id="instances-for-list-Std.TreeSet.sdiff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.TreeSet.instSDiff_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L53-L53">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instSDiff_mathlib"><span class="name">Std</span>.<span class="name">TreeSet</span>.<span class="name">instSDiff_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">cmp</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Core.html#SDiff">SDiff</a> <span class="fn">(<a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">TreeSet</a> <span class="fn">α</span> <span class="fn">cmp</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instSDiff_mathlib">Std.TreeSet.instSDiff_mathlib</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#SDiff.mk">{</a> <span class="fn">sdiff</span> := <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff">Std.TreeSet.sdiff</a> <a href="../../../.././Init/Core.html#SDiff.mk">}</a></li></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Datatypes">Datatypes <a class="hover-link" href="#Datatypes">#</a></h3><p>The <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></code> and <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> datatypes are specific to the FM elimination routine;
they are not shared with other components of <code>linarith</code>.</p></div><div class="decl" id="Mathlib.Tactic.Linarith.CompSource"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L66-L76">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CompSource</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></code> tracks the source of a comparison.
The atomic source of a comparison is an assumption, indexed by a natural number.
Two comparisons can be added to produce a new comparison,
and one comparison can be scaled by a natural number to produce a new comparison.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Linarith.CompSource.assump">assump : <span class="fn"><a href="../../../.././Init/Prelude.html#Nat">ℕ</a> → <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></span></li><li class="constructor" id="Mathlib.Tactic.Linarith.CompSource.add">add : <span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a> → <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a> → <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></span></li><li class="constructor" id="Mathlib.Tactic.Linarith.CompSource.scale">scale : <span class="fn"><a href="../../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a> → <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></span></span></li></ul><details id="instances-for-list-Mathlib.Tactic.Linarith.CompSource" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.instInhabitedCompSource.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L76-L76">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource.default"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instInhabitedCompSource</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource.default">Mathlib.Tactic.Linarith.instInhabitedCompSource.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.assump">Mathlib.Tactic.Linarith.CompSource.assump</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.instInhabitedCompSource.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.instInhabitedCompSource"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L76-L76">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instInhabitedCompSource</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource">Mathlib.Tactic.Linarith.instInhabitedCompSource</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource.default">Mathlib.Tactic.Linarith.instInhabitedCompSource.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.CompSource.flatten"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L78-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CompSource</span>.<span class="name">flatten</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a> → <span class="fn"><a href="../../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a></span></span></div></div><p>Given a <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></code> <code>cs</code>, <code>cs.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></code> maps an assumption index
to the number of copies of that assumption that appear in the history of <code>cs</code>.</p><p>For example, suppose <code>cs</code> is produced by scaling assumption 2 by 5,
and adding to that the sum of assumptions 1 and 2.
<code>cs.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></code> maps <code>1 ↦ 1, 2 ↦ 6</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.assump">Mathlib.Tactic.Linarith.CompSource.assump</a> <span class="fn">n</span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a>.<a href="../../../.././Std/Data/HashMap/Basic.html#Std.HashMap.insert">insert</a></span> <span class="fn">n</span> <span class="fn">1</span></span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.add">add</a></span> <span class="fn">c2</span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Batteries/Lean/HashMap.html#Std.HashMap.mergeWith">Std.HashMap.mergeWith</a> <span class="fn">(fun (<span class="fn">x</span> <span class="fn">b</span> <span class="fn">b'</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>) =&gt; <span class="fn">b</span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b'</span>)</span> <span class="fn"><span class="fn">c1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></span> <span class="fn"><span class="fn">c2</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.scale">Mathlib.Tactic.Linarith.CompSource.scale</a> <span class="fn">n</span> <span class="fn">c</span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/HashMap/AdditionalOperations.html#Std.HashMap.map">Std.HashMap.map</a> <span class="fn">(fun (<span class="fn">x</span> <span class="fn">v</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>) =&gt; <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">n</span>)</span> <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten">flatten</a></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.CompSource.flatten" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.CompSource.toString"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L92-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CompSource</span>.<span class="name">toString</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a> → <a href="../../../.././Init/Prelude.html#String">String</a></span></div></div><p>Formats a <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></code> for printing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.assump">Mathlib.Tactic.Linarith.CompSource.assump</a> <span class="fn">n</span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString">toString</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/ToString/Basic.html#ToString.toString">toString</a> <span class="fn">n</span></span></li><li class="equation"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">c1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.add">add</a></span> <span class="fn">c2</span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString">toString</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">c1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString">toString</a></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">&quot; + &quot;</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><span class="fn">c2</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString">toString</a></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.scale">Mathlib.Tactic.Linarith.CompSource.scale</a> <span class="fn">n</span> <span class="fn">c</span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString">toString</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/ToString/Basic.html#ToString.toString">toString</a> <span class="fn">n</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">&quot; * &quot;</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString">toString</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.CompSource.toString" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.instToFormatCompSource"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatCompSource"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instToFormatCompSource</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat">Std.ToFormat</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatCompSource">Mathlib.Tactic.Linarith.instToFormatCompSource</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat.mk">{</a> <span class="fn">format</span> := <span class="fn">fun (<span class="fn">a</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">Mathlib.Tactic.Linarith.CompSource</a>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString">toString</a></span></span></span> <a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PComp"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L101-L141">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>A <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> stores a linear comparison <code>Σ cᵢ*xᵢ R 0</code>,
along with information about how this comparison was derived.
The original expressions fed into <code>linarith</code> are each assigned a unique natural number label.
The <em>historical set</em> <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.history">PComp.history</a></code> stores the labels of expressions
that were used in deriving the current <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code>.
Variables are also indexed by natural numbers. The sets <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.effective">PComp.effective</a></code>, <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.implicit">PComp.implicit</a></code>,
and <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">PComp.vars</a></code> contain variable indices.</p><ul>
<li><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">PComp.vars</a></code> contains the variables that appear in any inequality in the historical set.</li>
<li><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.effective">PComp.effective</a></code> contains the variables that have been effectively eliminated from <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code>.
A variable <code>n</code> is said to be <em>effectively eliminated</em> in <code>p : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> if the elimination of <code>n</code>
produced at least one of the ancestors of <code>p</code> (or <code>p</code> itself).</li>
<li><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.implicit">PComp.implicit</a></code> contains the variables that have been implicitly eliminated from <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code>.
A variable <code>n</code> is said to be <em>implicitly eliminated</em> in <code>p</code> if it satisfies the following
properties:<ul>
<li><code>n</code> appears in some inequality in the historical set (i.e. in <code>p.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code>).</li>
<li><code>n</code> does not appear in <code>p.c.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code> (i.e. it has been eliminated).</li>
<li><code>n</code> was not effectively eliminated.</li>
</ul>
</li>
</ul><p>We track these sets in order to compute whether the history of a <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> is <em>minimal</em>.
Checking this directly is expensive, but effective approximations can be defined in terms of these
sets. During the variable elimination process, a <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> with non-minimal history can be discarded.</p><ul class="structure_fields" id="Mathlib.Tactic.Linarith.PComp.mk"><li id="Mathlib.Tactic.Linarith.PComp.c" class="structure_field"><div class="structure_field_info">c : <a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp">Comp</a></div><div class="structure_field_doc"><p>The comparison <code>Σ cᵢ*xᵢ R 0</code>.</p></div></li><li id="Mathlib.Tactic.Linarith.PComp.src" class="structure_field"><div class="structure_field_info">src : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></div><div class="structure_field_doc"><p>We track how the comparison was constructed by adding and scaling previous comparisons,
back to the original assumptions.</p></div></li><li id="Mathlib.Tactic.Linarith.PComp.history" class="structure_field"><div class="structure_field_info">history : <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a></span></div><div class="structure_field_doc"><p>The set of original assumptions which have been used in constructing this comparison.</p></div></li><li id="Mathlib.Tactic.Linarith.PComp.effective" class="structure_field"><div class="structure_field_info">effective : <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a></span></div><div class="structure_field_doc"><p>The variables which have been <em>effectively eliminated</em>,
i.e. by running the elimination algorithm on that variable.</p></div></li><li id="Mathlib.Tactic.Linarith.PComp.implicit" class="structure_field"><div class="structure_field_info">implicit : <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a></span></div><div class="structure_field_doc"><p>The variables which have been <em>implicitly eliminated</em>.
These are variables that appear in the historical set,
do not appear in <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></code> itself, and are not in `effective.</p></div></li><li id="Mathlib.Tactic.Linarith.PComp.vars" class="structure_field"><div class="structure_field_info">vars : <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../../.././Init/Data/Ord/Basic.html#Ord.compare">compare</a></span></div><div class="structure_field_doc"><p>The union of all variables appearing in those original assumptions
which appear in the <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.history">history</a></code> set.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Linarith.PComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PComp.maybeMinimal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L143-L165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.maybeMinimal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">maybeMinimal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">elimedGE</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>Any comparison whose history is not minimal is redundant,
and need not be included in the new set of comparisons.
<code>elimedGE : ℕ</code> is a natural number such that all variables with index ≥ <code>elimedGE</code> have been
removed from the system.</p><p>This test is an overapproximation to minimality. It gives necessary but not sufficient conditions.
If the history of <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></code> is minimal, then <code>c.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.maybeMinimal">maybeMinimal</a></code> is true,
but <code>c.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.maybeMinimal">maybeMinimal</a></code> may also be true for some <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></code> with non-minimal history.
Thus, if <code>c.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.maybeMinimal">maybeMinimal</a></code> is false, <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></code> is known not to be minimal and must be redundant.
See <a href="https://doi.org/10.1016/B978-0-444-88771-9.50019-2">https://doi.org/10.1016/B978-0-444-88771-9.50019-2</a> (Theorem 13).
The condition described there considers only implicitly eliminated variables that have been
officially eliminated from the system. This is not the case for every implicitly eliminated
variable. Consider eliminating <code>z</code> from <code>{x + y + z &lt; 0, x - y - z &lt; 0}</code>. The result is the set
<code>{2*x &lt; 0}</code>; <code>y</code> is implicitly but not officially eliminated.</p><p>This implementation of Fourier-Motzkin elimination processes variables in decreasing order of
indices. Immediately after a step that eliminates variable <code>k</code>, variable <code>k'</code> has been eliminated
iff <code>k' ≥ k</code>. Thus we can compute the intersection of officially and implicitly eliminated variables
by taking the set of implicitly eliminated variables with indices ≥ <code>elimedGE</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.maybeMinimal">maybeMinimal</a></span> <span class="fn">elimedGE</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a>
    (<span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.history">history</a></span>.<a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet.size">size</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a>       <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet.filter">Std.TreeSet.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">x</span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">elimedGE</span>)</span>)</span> <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.implicit">implicit</a></span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.union">union</a></span> <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.effective">effective</a></span>)</span>.<a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet.size">size</a></span>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.PComp.maybeMinimal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PComp.cmp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L167-L171">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">cmp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p1 </span><span class="fn">p2</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Data/Ord/Basic.html#Ordering">Ordering</a></div></div><p>The <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.src">src</a> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></code> field is ignored when comparing <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code>s. Two <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code>s proving the same
comparison, with different sources, are considered equivalent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">p1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.cmp">cmp</a></span> <span class="fn">p2</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">p1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span>.<a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp.cmp">cmp</a></span> <span class="fn"><span class="fn">p2</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.PComp.cmp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PComp.scale"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L173-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.scale"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">scale</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.scale">PComp.scale</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a> n</code> scales the coefficients of <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></code> by <code>n</code> and notes this in the <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.scale">scale</a></span> <span class="fn">n</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.mk">{</a> <span class="fn">c</span> := <span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span>.<a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp.scale">scale</a></span> <span class="fn">n</span></span>, <span class="fn">src</span> := <span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.scale">Mathlib.Tactic.Linarith.CompSource.scale</a> <span class="fn">n</span> <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.src">src</a></span></span>, <span class="fn">history</span> := <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.history">history</a></span>,
    <span class="fn">effective</span> := <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.effective">effective</a></span>, <span class="fn">implicit</span> := <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.implicit">implicit</a></span>, <span class="fn">vars</span> := <span class="fn"><span class="fn">c</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></span> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.mk">}</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.PComp.scale" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PComp.add"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L177-L203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">add</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c1 </span><span class="fn">c2</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">elimVar</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.add">PComp.add</a> c1 c2 <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar">elimVar</a></code> creates the result of summing the linear comparisons <code>c1</code> and <code>c2</code>,
during the process of eliminating the variable <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar">elimVar</a></code>.
The computation assumes, but does not enforce, that <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar">elimVar</a></code> appears in both <code>c1</code> and <code>c2</code>
and does not appear in the sum.
Computing the sum of the two comparisons is easy; the complicated details lie in tracking the
additional fields of <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code>.</p><ul>
<li>The historical set <code>pcomp.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.history">history</a></code> of <code>c1 + c2</code> is the union of the two historical sets.</li>
<li><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code> is the union of <code>c1.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code> and <code>c2.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code>.</li>
<li>The effectively eliminated variables of <code>c1 + c2</code> are the union of the two effective sets,
with <code>elim_var</code> inserted.</li>
<li>The implicitly eliminated variables of <code>c1 + c2</code> are those that appear in
<code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code> but not <code>c.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code> or <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.effective">effective</a></code>.
(Note that the description of the implicitly eliminated variables of <code>c1 + c2</code> in the algorithm
described in Section 6 of <a href="https://doi.org/10.1016/B978-0-444-88771-9.50019-2">https://doi.org/10.1016/B978-0-444-88771-9.50019-2</a> seems to be wrong:
that says it should be <code>(c1.implicit.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.union">union</a> c2.implicit).<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff">sdiff</a> explicit</code>.
Since the implicitly eliminated sets start off empty for the assumption,
this formula would leave them always empty.)</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.PComp.add" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PComp.assump"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L205-L217">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.assump"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">assump</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp">Comp</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.assump">PComp.assump</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a> n</code> creates a <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> whose comparison is <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></code> and whose source is
<code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.assump">CompSource.assump</a> n</code>, that is, <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></code> is derived from the <code>n</code>th hypothesis.
The history is the singleton set <code>{n}</code>.
No variables have been eliminated (effectively or implicitly).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.PComp.assump" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.instToFormatPComp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L219-L220">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatPComp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instToFormatPComp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat">Std.ToFormat</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatPComp">Mathlib.Tactic.Linarith.instToFormatPComp</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat.mk">{</a>     <span class="fn">format</span> := <span class="fn">fun (<span class="fn">p</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">Mathlib.Tactic.Linarith.PComp</a>) =&gt;
      <span class="fn"><a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat.format">Std.format</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span>.<a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp.coeffs">coeffs</a></span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">(<a href="../../../.././Init/Data/ToString/Basic.html#ToString.toString">toString</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span>.<a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp.str">str</a></span>)</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot;0&quot;</span></span></span> <a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.instToStringPComp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L222-L223">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToStringPComp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">instToStringPComp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/ToString/Basic.html#ToString">ToString</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToStringPComp">Mathlib.Tactic.Linarith.instToStringPComp</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Data/ToString/Basic.html#ToString.mk">{</a> <span class="fn">toString</span> := <span class="fn">fun (<span class="fn">p</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">Mathlib.Tactic.Linarith.PComp</a>) =&gt; <span class="fn"><a href="../../../.././Init/Data/ToString/Basic.html#ToString.toString">toString</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span>.<a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp.coeffs">coeffs</a></span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Init/Data/ToString/Basic.html#ToString.toString">toString</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span>.<a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp.str">str</a></span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">&quot;0&quot;</span></span> <a href="../../../.././Init/Data/ToString/Basic.html#ToString.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PCompSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L225-L226">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PCompSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>A collection of comparisons.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">Mathlib.Tactic.Linarith.PCompSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/TreeSet/Basic.html#Std.TreeSet">Std.TreeSet</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">Mathlib.Tactic.Linarith.PComp</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.cmp">Mathlib.Tactic.Linarith.PComp.cmp</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.PCompSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Elimination-procedure">Elimination procedure <a class="hover-link" href="#Elimination-procedure">#</a></h3></div><div class="decl" id="Mathlib.Tactic.Linarith.elimVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L230-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimVar</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c1 </span><span class="fn">c2</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp">Comp</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> (<a href="../../../.././Init/Prelude.html#Nat">ℕ</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></div></div><p>If <code>c1</code> and <code>c2</code> both contain variable <code>a</code> with opposite coefficients,
produces <code>v1</code> and <code>v2</code> such that <code>a</code> has been cancelled in <code>v1*c1 + v2*c2</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.elimVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.pelimVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L240-L247">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.pelimVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">pelimVar</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p1 </span><span class="fn">p2</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></span></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.pelimVar">pelimVar</a> p1 p2</code> calls <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar">elimVar</a></code> on the <code>Comp</code> components of <code>p1</code> and <code>p2</code>.
If this returns <code>v1</code> and <code>v2</code>, it creates a new <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> equal to <code>v1*p1 + v2*p2</code>,
and tracks this in the <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource">CompSource</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.pelimVar">Mathlib.Tactic.Linarith.pelimVar</a> <span class="fn">p1</span> <span class="fn">p2</span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar">Mathlib.Tactic.Linarith.elimVar</a> <span class="fn"><span class="fn">p1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span> <span class="fn"><span class="fn">p2</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span> <span class="fn">a</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">n1</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">n2</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><span class="fn">p1</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.scale">scale</a></span> <span class="fn">n1</span>)</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.add">add</a></span> <span class="fn">(<span class="fn"><span class="fn">p2</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.scale">scale</a></span> <span class="fn">n2</span>)</span> <span class="fn">a</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.pelimVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.PComp.isContr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L249-L252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.isContr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">PComp</span>.<span class="name">isContr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>A <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> represents a contradiction if its <code>Comp</code> field represents a contradiction.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.isContr">isContr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c">c</a></span>.<a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp.isContr">isContr</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.PComp.isContr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.elimWithSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L254-L262">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimWithSet"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimWithSet</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">comps</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimWithSet">elimWithSet</a> a p <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> collects the result of calling <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.pelimVar">pelimVar</a> p p' a</code>
for every <code>p' ∈ <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.elimWithSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.LinarithData"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L264-L276">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">LinarithData</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The state for the elimination monad.</p><ul>
<li><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.maxVar">maxVar</a></code>: the largest variable index that has not been eliminated.</li>
<li><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code>: a set of comparisons</li>
</ul><p>The elimination procedure proceeds by eliminating variable <code>v</code> from <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> progressively
in decreasing order.</p><ul class="structure_fields" id="Mathlib.Tactic.Linarith.LinarithData.mk"><li id="Mathlib.Tactic.Linarith.LinarithData.maxVar" class="structure_field"><div class="structure_field_info">maxVar : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a></div><div class="structure_field_doc"><p>The largest variable index that has not been (officially) eliminated.</p></div></li><li id="Mathlib.Tactic.Linarith.LinarithData.comps" class="structure_field"><div class="structure_field_info">comps : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a></div><div class="structure_field_doc"><p>The set of comparisons.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Linarith.LinarithData" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.LinarithM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L278-L283">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">LinarithM</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a></span></div></div><p>The linarith monad extends an exceptional monad with a <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData">LinarithData</a></code> state.
An exception produces a contradictory <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM">Mathlib.Tactic.Linarith.LinarithM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Control/State.html#StateT">StateT</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData">Mathlib.Tactic.Linarith.LinarithData</a> <span class="fn">(<a href="../../../.././Init/Control/Except.html#ExceptT">ExceptT</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">Mathlib.Tactic.Linarith.PComp</a> <a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.LinarithM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.getMaxVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L285-L287">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getMaxVar"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">getMaxVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM">LinarithM</a> <a href="../../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>Returns the current max variable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getMaxVar">Mathlib.Tactic.Linarith.getMaxVar</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.maxVar">Mathlib.Tactic.Linarith.LinarithData.maxVar</a> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <a href="../../../.././Init/Prelude.html#MonadState.get">get</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.getMaxVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.getPCompSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L289-L291">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getPCompSet"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">getPCompSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM">LinarithM</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a></span></div></div><p>Return the current comparison set.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getPCompSet">Mathlib.Tactic.Linarith.getPCompSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">Mathlib.Tactic.Linarith.LinarithData.comps</a> <a href="../../../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a> <a href="../../../.././Init/Prelude.html#MonadState.get">get</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.getPCompSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.validate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L293-L297">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.validate"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">validate</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM">LinarithM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Throws an exception if a contradictory <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp">PComp</a></code> is contained in the current state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.validate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.update"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L299-L305">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.update"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">update</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">maxVar</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">comps</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM">LinarithM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Updates the current state with a new max variable and comparisons,
and calls <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.validate">validate</a></code> to check for a contradiction.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.update">Mathlib.Tactic.Linarith.update</a> <span class="fn">maxVar</span> <span class="fn">comps</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  <span class="fn"><a href="../../../.././Init/Control/State.html#StateT.set">StateT.set</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.mk">{</a> <span class="fn">maxVar</span> := <span class="fn">maxVar</span>, <span class="fn">comps</span> := <span class="fn">comps</span> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.mk">}</a></span>
  <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.validate">Mathlib.Tactic.Linarith.validate</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.update" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.splitSetByVarSign"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L307-L321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.splitSetByVarSign"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">splitSetByVarSign</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">comps</span> : <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet">PCompSet</a></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.splitSetByVarSign">splitSetByVarSign</a> a <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> partitions the set <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> into three parts.</p><ul>
<li><code>pos</code> contains the elements of <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> in which <code>a</code> has a positive coefficient.</li>
<li><code>neg</code> contains the elements of <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> in which <code>a</code> has a negative coefficient.</li>
<li><code>notPresent</code> contains the elements of <code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps">comps</a></code> in which <code>a</code> has coefficient 0.</li>
</ul><p>Returns <code>(pos, neg, notPresent)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.splitSetByVarSign" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.elimVarM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L323-L336">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVarM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimVarM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM">LinarithM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVarM">elimVarM</a> a</code> performs one round of Fourier-Motzkin elimination, eliminating the variable <code>a</code>
from the <code>linarith</code> state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.elimVarM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.elimAllVarsM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L338-L344">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimAllVarsM"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">elimAllVarsM</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM">LinarithM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimAllVarsM">elimAllVarsM</a></code> eliminates all variables from the linarith state, leaving it with a set of
ground comparisons. If this succeeds without exception, the original <code>linarith</code> state is consistent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.elimAllVarsM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.mkLinarithData"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L346-L351">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.mkLinarithData"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">mkLinarithData</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">hyps</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp">Comp</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">maxVar</span> : <a href="../../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData">LinarithData</a></div></div><p><code><a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.mkLinarithData">mkLinarithData</a> hyps <a href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars">vars</a></code> takes a list of hypotheses and the largest variable present in
those hypotheses. It produces an initial state for the elimination monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.mkLinarithData" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Linarith.CertificateOracle.fourierMotzkin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/6b1d0f08cb89b784bfb1bb9cabf8016cc8059f07/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L353-L361">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CertificateOracle.fourierMotzkin"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Linarith</span>.<span class="name">CertificateOracle</span>.<span class="name">fourierMotzkin</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.CertificateOracle">CertificateOracle</a></div></div><p>An oracle that uses Fourier-Motzkin elimination.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Linarith.CertificateOracle.fourierMotzkin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>